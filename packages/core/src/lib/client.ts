import { Breadcrumb, Context, SentryEvent } from './domain';
import { DSN } from './dsn';
import { SentryError } from './error';

/** Console logging verbosity for the SDK. */
export enum LogLevel {
  /** No logs will be generated. */
  None = 0,
  /** Only SDK internal errors will be logged. */
  Error = 1,
  /** Information useful for debugging the SDK will be logged. */
  Debug = 2,
  /** All SDK actions will be logged. */
  Verbose = 3,
}

/**
 * Base configuration options for every SDK.
 * Note that specific SDKs might add more options.
 */
export interface Options {
  /** The current environment of your application (e.g. "production"). */
  environment?: string;

  /** Console logging verbosity for the SDK Client. */
  logLevel?: LogLevel;

  /** The maximum number of breadcrumbs sent with events. Defaults to 100. */
  maxBreadcrumbs?: number;

  /**
   * A pattern for error messages which should not be sent to Sentry.
   * By default, all errors will be sent.
   */
  ignoreErrors?: Array<string | RegExp>;

  /**
   * A pattern for error URLs which should not be sent to Sentry.
   * To whitelist certain errors instead, use {@link Options.whitelistUrls}.
   * By default, all errors will be sent.
   */
  ignoreUrls?: Array<string | RegExp>;

  /**
   * A pattern for error URLs which should exclusively be sent to Sentry.
   * This is the opposite of {@link Options.ignoreUrls}.
   * By default, all errors will be sent.
   */
  whitelistUrls?: Array<string | RegExp>;

  /**
   * Defines a list source code file paths. Only errors including these paths in
   * their stack traces will be sent to Sentry.
   * By default, all errors will be sent.
   */
  includePaths?: Array<string | RegExp>;

  /**
   * The release identifier used when uploading respective source maps.
   * Specify this value to allow Sentry to resolve the correct source maps when
   * processing events.
   */
  release?: string;

  /**
   * A callback invoked during event submission, allowing to cancel the
   * process. If unspecified, all events will be sent to Sentry.
   *
   * This function is called for both error and message events before all other
   * callbacks. Note that the SDK might perform other actions after calling
   * this function. Use {@link Options.beforeSend} for notifications on events
   * instead.
   *
   * @param event The error or message event generated by the SDK.
   * @returns True if the event should be sent, false otherwise.
   */
  shouldSend?(event: SentryEvent): boolean;

  /**
   * A callback invoked during event submission, allowing to optionally modify
   * the event before it is sent to Sentry.
   *
   * This function is called after {@link Options.shouldSend} and just before
   * sending the event and must return synchronously.
   *
   * Note that you must return a valid event from this callback. If you do not
   * wish to modify the event, simply return it at the end. To cancel event
   * submission instead, use {@link Options.shouldSend}.
   *
   * @param event The error or message event generated by the SDK.
   * @returns A new event that will be sent.
   */
  beforeSend?(event: SentryEvent): SentryEvent;

  /**
   * A callback invoked after event submission has completed.
   * @param event The error or message event sent to Sentry.
   */
  afterSend?(event: SentryEvent): void;

  /**
   * A callback allowing to skip breadcrumbs.
   *
   * This function is called for both manual and automatic breadcrumbs before
   * all other callbacks. Note that the SDK might perform other actions after
   * calling this function. Use {@link Options.beforeBreadcrumb} for
   * notifications on breadcrumbs instead.
   *
   * @param breadcrumb The breadcrumb as created by the SDK.
   * @returns True if the breadcrumb should be added, false otherwise.
   */
  shouldAddBreadcrumb?(breadcrumb: Breadcrumb): boolean;

  /**
   * A callback invoked when adding a breadcrumb, allowing to optionally modify
   * it before adding it to future events.
   *
   * This function is called after {@link Options.shouldAddBreadcrumb} and just
   * before persisting the breadcrumb. It must return synchronously.
   *
   * Note that you must return a valid breadcrumb from this callback. If you do
   * not wish to modify the breadcrumb, simply return it at the end. To skip a
   * breadcrumb instead, use {@link Options.shouldAddBreadcrumb}.
   *
   * @param breadcrumb The breadcrumb as created by the SDK.
   * @returns The breadcrumb that will be added.
   */
  beforeBreadcrumb?(breadcrumb: Breadcrumb): Breadcrumb;

  /**
   * A callback invoked after adding a breadcrumb.
   * @param breadcrumb The breadcrumb as created by the SDK.
   */
  afterBreadcrumb?(breadcrumb: Breadcrumb): void;
}

/**
 * Common interface for platform-specific SDK implementations, used internally
 * by the {@link Client}.
 */
export interface Adapter {
  /** Options passed to the {@link Client}. */
  readonly options: Options;

  /** Integrates the SDK into the environment. */
  install(): Promise<boolean>;
  captureException(exception: any): Promise<SentryEvent>;
  captureMessage(message: string): Promise<SentryEvent>;
  captureBreadcrumb(breadcrumb: Breadcrumb): Promise<Breadcrumb>;
  send(event: SentryEvent): Promise<void>;
  setOptions(options: Options): Promise<void>;
  getContext(): Promise<Context>;
  setContext(context: Context): Promise<void>;
}

/** Default options used for the Client. */
const DEFAULT_OPTIONS = { logLevel: LogLevel.Error, maxBreadcrumbs: 100 };

/**
 * Sentry SDK Client.
 *
 * This class contains all methods to interface with the SDK once it has been
 * installed. It allows to send events to Sentry, record breadcrumbs and set a
 * context included in every event. Since the SDK mutates its environment, there
 * will only be one instance during runtime. To retrieve that instance, use
 * {@link Sentry.getSharedClient}.
 *
 * Note that the call to {@link Sentry.install} should occur as early as
 * possible so that even errors during startup can be recorded reliably:
 *
 * @example
 * const Sentry = require('@sentry/core');
 * const { SentryNode } = require('@sentry/node');
 *
 * const options = {
 *   // Add SDK-specific options here
 * };
 *
 * Sentry.create(__DSN__, options)
 *   .use(SentryNode, options)
 *   .install();
 *
 * @example
 * const Sentry = require('@sentry/core');
 *
 * // SDK must be installed at this point
 * const client = Sentry.getSharedClient();
 * client.captureMessage('Custom message');
 */
export class Client {
  /** The DSN configured during installation. */
  public readonly dsn: DSN;
  /** Generic client options. */
  public options: Options;
  /** The adapter created with {@link Client.use} */
  private adapter?: Adapter;
  /** A promise that resolves during installation. */
  private isInstalled?: Promise<boolean>;

  /**
   * Create a new instance of {@link Client}.
   *
   * @param dsn The DSN used to connect to and authenticate with Sentry.
   * @param options Configuration options for the client.
   */
  public constructor(dsn: string, options: Options = DEFAULT_OPTIONS) {
    this.dsn = new DSN(dsn);
    this.options = options;
    return this;
  }

  /**
   * Returns an instance of the used adapter casted to its inner type.
   */
  public getAdapter<A extends Adapter>(): A {
    if (!this.adapter) {
      throw new SentryError('No adapter in use, please call .use(<Adapter>)');
    }

    return this.adapter as A;
  }

  /**
   * This will tell the {@link Client} to use the adapter internally.
   *
   * The {@link Client} will delegate all calls to the {@link Adapter}. Please
   * note that there must be one and only one {@link Adapter} used at any time.
   *
   * @param adapter
   * @param options
   * @returns Client
   */
  public use<A extends Adapter, O extends {}>(
    adapter: { new (client: Client, options?: O): A },
    options?: O,
  ): Client {
    if (this.adapter) {
      // TODO: implement unregister
      throw new RangeError(
        'There is already a Adapter registered, call unregister() to remove current adapter',
      );
    }
    this.adapter = new adapter(this, options);
    return this;
  }

  /**
   * Integrates the configured {@link Adapter} into the environment.
   *
   * Since this performs modifications in the environment, such as instrumenting
   * library functionality or adding signal handlers, this method should only
   * be called once.
   *
   * The installation is performed asynchronously. While it is possible to use
   * the SDK before the installation has finished, it is advised to wait until
   * the returned Promise has resolved before issuing methods such as
   * {@link Client.captureException} or {@link Client.captureBreadcrumb}.
   *
   * @returns A Promise that resolves when installation has finished.
   */
  public async install(): Promise<this> {
    if (!this.isInstalled) {
      this.isInstalled = this.getAdapter().install();
    }

    await this.isInstalled;
    return this;
  }

  /**
   * Capture an exception and send it to Sentry.
   *
   * @param exception An exception-like object.
   * @returns A promise that resolves when the exception has been sent.
   */
  public async captureException(exception: any): Promise<SentryEvent> {
    const adapter = await this.awaitAdapter();
    const event = await adapter.captureException(exception);
    return this.send(event);
  }

  /**
   * Capture a message and send it to Sentry.
   *
   * @param message The message to send to Sentry.
   * @returns A promise that resolves when the message has been sent.
   */
  public async captureMessage(message: string): Promise<SentryEvent> {
    const adapter = await this.awaitAdapter();
    const event = await adapter.captureMessage(message);
    return this.send(event);
  }

  /**
   * Adds a new breadcrumb.
   *
   * Breadcrumbs will be added to subsequent events to provide more context on
   * user's actions prior to an error or crash. To configure the maximum number
   * of breadcrumbs, use {@link Options.maxBreadcrumbs}.
   *
   * @param crumb The breadcrumb to record.
   * @returns A promise that resolves when the breadcrumb has been persisted.
   */
  public async captureBreadcrumb(crumb: Breadcrumb): Promise<Breadcrumb> {
    const {
      shouldAddBreadcrumb,
      beforeBreadcrumb,
      afterBreadcrumb,
    } = this.options;

    if (!shouldAddBreadcrumb || shouldAddBreadcrumb(crumb)) {
      const finalCrumb = beforeBreadcrumb ? beforeBreadcrumb(crumb) : crumb;
      const adapter = await this.awaitAdapter();
      await adapter.captureBreadcrumb(finalCrumb);
      if (afterBreadcrumb) {
        afterBreadcrumb(finalCrumb);
      }
    }

    return crumb;
  }

  /**
   * Sends an event to Sentry by delegating to the internal {@link Adapter}.
   *
   * It should not be necessary to call this function directly, instead use
   * {@link captureException} or {@link captureMessage}. The client will process
   * the respective data, create an event with metadata and then send it to
   * Sentry.
   *
   * Before sending, this function invokes the configured "beforeSend" hook,
   * which allows to modify the event.
   *
   * @param event A processed event.
   * @returns A promise that resolves once the event has been sent.
   */
  public async send(event: SentryEvent): Promise<SentryEvent> {
    const { shouldSend, beforeSend, afterSend } = this.options;
    if (shouldSend && !shouldSend(event)) {
      return event;
    }

    const finalEvent = beforeSend ? beforeSend(event) : event;
    const adapter = await this.awaitAdapter();
    await adapter.send(finalEvent);
    if (afterSend) {
      afterSend(finalEvent);
    }
    return finalEvent;
  }

  /**
   * Set new options on the fly (not supported by every SDK).
   *
   * @param options New options to replace the previous ones.
   * @returns A promise that resolves when the options have been updated.
   */
  public async setOptions(options: Options): Promise<Adapter> {
    const adapter = await this.awaitAdapter();
    await adapter.setOptions(options);
    return adapter;
  }

  /**
   * Resolves the current {@link Context}.
   * @returns A promise that resolves when the context is ready.
   */
  public async getContext(): Promise<Context> {
    // TODO: Migrate context to core, using Context interface
    // TODO: check for cyclic objects
    const adapter = await this.awaitAdapter();
    const context = await adapter.getContext();
    return JSON.parse(JSON.stringify(context)) as Context;
  }

  /**
   * Merge new context information into the current content.
   *
   * @param data New context data.
   * @returns A promise that resolves when the context has been updated.
   */
  public async setContext(data: Context): Promise<Adapter> {
    const adapter = await this.awaitAdapter();
    await adapter.setContext(data);
    return adapter;
  }

  /**
   * Logs debugging information if {@link LogLevel} is set to Debug or Verbose.
   *
   * @param args Arguments to log to the console
   */
  public log(...args: any[]): void {
    if (
      this.options &&
      this.options.logLevel &&
      this.options.logLevel >= LogLevel.Debug
    ) {
      // tslint:disable-next-line:no-console
      console.log(...args);
    }
  }

  /**
   * Asynchronously resolves the adapter.
   *
   * This function may be called during installation and will bock until
   * installation has finished.
   *
   * If installation has not started or no adapter has been configured, an
   * exception will be thrown.
   *
   * @returns A promise that resolves to the {@link Adapter}.
   */
  private async awaitAdapter(): Promise<Adapter> {
    if (!this.isInstalled) {
      throw new SentryError(
        'SDK not installed. Please call install() before using the SDK',
      );
    }

    await this.isInstalled;
    return this.getAdapter();
  }
}
