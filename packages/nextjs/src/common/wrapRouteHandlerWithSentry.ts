import {
  SEMANTIC_ATTRIBUTE_SENTRY_OP,
  SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN,
  SEMANTIC_ATTRIBUTE_SENTRY_SOURCE,
  SPAN_STATUS_ERROR,
  captureException,
  getActiveSpan,
  getRootSpan,
  handleCallbackErrors,
  setHttpStatus,
  spanToJSON,
  startSpan,
} from '@sentry/core';
import type { Span } from '@sentry/types';
import { winterCGHeadersToDict } from '@sentry/utils';
import { isNotFoundNavigationError, isRedirectNavigationError } from './nextNavigationErrorUtils';
import type { RouteHandlerContext } from './types';
import { platformSupportsStreaming } from './utils/platformSupportsStreaming';
import { flushQueue } from './utils/responseEnd';
import { withIsolationScopeOrReuseFromRootSpan } from './utils/withIsolationScopeOrReuseFromRootSpan';

/** As our own HTTP integration is disabled (src/server/index.ts) the rootSpan comes from Next.js.
 * In case there is no root span, we start a new span. */
function startOrUpdateSpan(spanName: string, cb: (rootSpan: Span) => Promise<Response>): Promise<Response> {
  const activeSpan = getActiveSpan();
  const rootSpan = activeSpan && getRootSpan(activeSpan);

  // We have different possible scenarios here:
  // 1. If we have no root span, we just create a new span
  // 2. We have a root span that that we want to update here
  // 3. We have a root span that was already updated (e.g. if this is a nested call)

  const attributes = {
    [SEMANTIC_ATTRIBUTE_SENTRY_SOURCE]: 'route',
    [SEMANTIC_ATTRIBUTE_SENTRY_OP]: 'http.server',
    [SEMANTIC_ATTRIBUTE_SENTRY_ORIGIN]: 'auto.function.nextjs',
  } as const;

  if (!rootSpan) {
    return startSpan(
      {
        name: spanName,
        forceTransaction: true,
        attributes,
      },
      cb,
    );
  }

  // If `op` is set, we assume this was already processed before
  // Probably this is a nested call, no need to update anything anymore
  // OR, if we don't have next.span_type, we don't know where this comes from and don't want to mess with it
  const existingAttributes = spanToJSON(rootSpan).data || {};
  if (existingAttributes[SEMANTIC_ATTRIBUTE_SENTRY_OP] || !existingAttributes['next.span_type']) {
    return cb(rootSpan);
  }

  // Finally, we want to update the root span, as the ones generated by next are often not good enough for us
  rootSpan.updateName(spanName);
  rootSpan.setAttributes(attributes);

  return cb(rootSpan);
}

/**
 * Wraps a Next.js route handler with performance and error instrumentation.
 */
// eslint-disable-next-line @typescript-eslint/no-explicit-any
export function wrapRouteHandlerWithSentry<F extends (...args: any[]) => any>(
  routeHandler: F,
  context: RouteHandlerContext,
): (...args: Parameters<F>) => ReturnType<F> extends Promise<unknown> ? ReturnType<F> : Promise<ReturnType<F>> {
  const { method, parameterizedRoute, headers } = context;

  return new Proxy(routeHandler, {
    apply: (originalFunction, thisArg, args) => {
      return withIsolationScopeOrReuseFromRootSpan(async isolationScope => {
        isolationScope.setSDKProcessingMetadata({
          request: {
            headers: headers ? winterCGHeadersToDict(headers) : undefined,
          },
        });

        try {
          return await startOrUpdateSpan(`${method} ${parameterizedRoute}`, async (rootSpan: Span) => {
            const response: Response = await handleCallbackErrors(
              () => originalFunction.apply(thisArg, args),
              error => {
                // Next.js throws errors when calling `redirect()`. We don't wanna report these.
                if (isRedirectNavigationError(error)) {
                  // Don't do anything
                } else if (isNotFoundNavigationError(error) && rootSpan) {
                  rootSpan.setStatus({ code: SPAN_STATUS_ERROR, message: 'not_found' });
                } else {
                  captureException(error, {
                    mechanism: {
                      handled: false,
                    },
                  });
                }
              },
            );

            try {
              if (rootSpan && response.status) {
                setHttpStatus(rootSpan, response.status);
              }
            } catch {
              // best effort - response may be undefined?
            }

            return response;
          });
        } finally {
          if (!platformSupportsStreaming() || process.env.NEXT_RUNTIME === 'edge') {
            // 1. Edge transport requires manual flushing
            // 2. Lambdas require manual flushing to prevent execution freeze before the event is sent
            await flushQueue();
          }
        }
      });
    },
  });
}
