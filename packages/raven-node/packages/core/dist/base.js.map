{"version":3,"file":"base.js","sourceRoot":"","sources":["../src/base.ts"],"names":[],"mappings":"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","sourcesContent":["import { Breadcrumb, SdkInfo, SentryEvent } from '@sentry/types';\nimport { DSN } from './dsn';\nimport { Backend, Client, Options } from './interfaces';\nimport { Scope } from './scope';\nimport { SendStatus } from './status';\n\n/**\n * Default maximum number of breadcrumbs added to an event. Can be overwritten\n * with {@link Options.maxBreadcrumbs}.\n */\nconst DEFAULT_BREADCRUMBS = 30;\n\n/**\n * Absolute maximum number of breadcrumbs added to an event. The\n * `maxBreadcrumbs` option cannot be higher than this value.\n */\nconst MAX_BREADCRUMBS = 100;\n\n/** A class object that can instanciate Backend objects. */\nexport interface BackendClass<B extends Backend, O extends Options> {\n  new (options: O): B;\n}\n\n/**\n * Base implementation for all JavaScript SDK clients.\n *\n * Call the constructor with the corresponding backend constructor and options\n * specific to the client subclass. To access these options later, use\n * {@link Client.getOptions}. Also, the Backend instance is available via\n * {@link Client.getBackend}.\n *\n * Subclasses must implement one abstract method: {@link getSdkInfo}. It must\n * return the unique name and the version of the SDK.\n *\n * If a DSN is specified in the options, it will be parsed and stored. Use\n * {@link Client.getDSN} to retrieve the DSN at any moment. In case the DSN is\n * invalid, the constructor will throw a {@link SentryException}. Note that\n * without a valid DSN, the SDK will not send any events to Sentry.\n *\n * Before sending an event via the backend, it is passed through\n * {@link BaseClient.prepareEvent} to add SDK information and scope data\n * (breadcrumbs and context). To add more custom information, override this\n * method and extend the resulting prepared event.\n *\n * To issue automatically created events (e.g. via instrumentation), use\n * {@link Client.captureEvent}. It will prepare the event and pass it through\n * the callback lifecycle. To issue auto-breadcrumbs, use\n * {@link Client.addBreadcrumb}.\n *\n * @example\n * class NodeClient extends BaseClient<NodeBackend, NodeOptions> {\n *   public constructor(options: NodeOptions) {\n *     super(NodeBackend, options);\n *   }\n *\n *   // ...\n * }\n */\nexport abstract class BaseClient<B extends Backend, O extends Options>\n  implements Client<O> {\n  /**\n   * The backend used to physically interact in the enviornment. Usually, this\n   * will correspond to the client. When composing SDKs, however, the Backend\n   * from the root SDK will be used.\n   */\n  private readonly backend: B;\n\n  /** Options passed to the SDK. */\n  private readonly options: O;\n\n  /**\n   * The client DSN, if specified in options. Without this DSN, the SDK will be\n   * disabled.\n   */\n  private readonly dsn?: DSN;\n\n  /**\n   * Stores whether installation has been performed and was successful. Before\n   * installing, this is undefined. Then it contains the success state.\n   */\n  private installed?: boolean;\n\n  /**\n   * Initializes this client instance.\n   *\n   * @param backendClass A constructor function to create the backend.\n   * @param options Options for the client.\n   */\n  protected constructor(backendClass: BackendClass<B, O>, options: O) {\n    this.backend = new backendClass(options);\n    this.options = options;\n\n    if (options.dsn) {\n      this.dsn = new DSN(options.dsn);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public install(): boolean {\n    if (!this.isEnabled()) {\n      return false;\n    }\n\n    if (this.installed === undefined) {\n      this.installed = this.getBackend().install();\n    }\n\n    return this.installed;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureException(exception: any, scope?: Scope): Promise<void> {\n    const event = await this.getBackend().eventFromException(exception);\n    await this.captureEvent(event, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureMessage(message: string, scope?: Scope): Promise<void> {\n    const event = await this.getBackend().eventFromMessage(message);\n    await this.captureEvent(event, scope);\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async captureEvent(event: SentryEvent, scope?: Scope): Promise<void> {\n    await this.processEvent(\n      event,\n      async finalEvent => this.getBackend().sendEvent(finalEvent),\n      scope,\n    );\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public async addBreadcrumb(\n    breadcrumb: Breadcrumb,\n    scope?: Scope,\n  ): Promise<void> {\n    const {\n      shouldAddBreadcrumb,\n      beforeBreadcrumb,\n      afterBreadcrumb,\n      maxBreadcrumbs = DEFAULT_BREADCRUMBS,\n    } = this.getOptions();\n\n    if (maxBreadcrumbs <= 0) {\n      return;\n    }\n\n    const timestamp = new Date().getTime() / 1000;\n    const mergedBreadcrumb = { timestamp, ...breadcrumb };\n    if (shouldAddBreadcrumb && !shouldAddBreadcrumb(mergedBreadcrumb)) {\n      return;\n    }\n\n    const finalBreadcrumb = beforeBreadcrumb\n      ? beforeBreadcrumb(mergedBreadcrumb)\n      : mergedBreadcrumb;\n\n    if ((await this.getBackend().storeBreadcrumb(finalBreadcrumb)) && scope) {\n      scope.addBreadcrumb(\n        finalBreadcrumb,\n        Math.min(maxBreadcrumbs, MAX_BREADCRUMBS),\n      );\n    }\n\n    if (afterBreadcrumb) {\n      afterBreadcrumb(finalBreadcrumb);\n    }\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getDSN(): DSN | undefined {\n    return this.dsn;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public getOptions(): O {\n    return this.options;\n  }\n\n  /**\n   * @inheritDoc\n   */\n  public createScope(parentScope?: Scope): Scope {\n    const newScope = new Scope();\n    newScope.setParentScope(parentScope);\n    newScope.setOnChange((scope: Scope) => {\n      this.getBackend().storeScope(scope);\n    });\n    return newScope;\n  }\n\n  /** Returns the current used SDK version and name. */\n  protected abstract getSdkInfo(): SdkInfo;\n\n  /** Returns the current backend. */\n  protected getBackend(): B {\n    return this.backend;\n  }\n\n  /** Determines whether this SDK is enabled and a valid DSN is present. */\n  protected isEnabled(): boolean {\n    return this.getOptions().enabled !== false && this.dsn !== undefined;\n  }\n\n  /**\n   * Adds common information to events.\n   *\n   * The information includes release and environment from `options`, SDK\n   * information returned by {@link BaseClient.getSdkInfo}, as well as\n   * breadcrumbs and context (extra, tags and user) from the scope.\n   *\n   * Information that is already present in the event is never overwritten. For\n   * nested objects, such as the context, keys are merged.\n   *\n   * @param event The original event.\n   * @param scope A scope containing event metadata.\n   * @returns A new event with more information.\n   */\n  protected async prepareEvent(\n    event: SentryEvent,\n    scope?: Scope,\n  ): Promise<SentryEvent> {\n    const {\n      environment,\n      maxBreadcrumbs = DEFAULT_BREADCRUMBS,\n      release,\n    } = this.getOptions();\n\n    const prepared = { sdk: this.getSdkInfo(), ...event };\n    if (prepared.environment === undefined && environment !== undefined) {\n      prepared.environment = environment;\n    }\n    if (prepared.release === undefined && release !== undefined) {\n      prepared.release = release;\n    }\n\n    if (scope) {\n      scope.applyToEvent(prepared, Math.min(maxBreadcrumbs, MAX_BREADCRUMBS));\n    }\n\n    return prepared;\n  }\n\n  /**\n   * Processes an event (either error or message) and sends it to Sentry.\n   *\n   * This also adds breadcrumbs and context information to the event. However,\n   * platform specific meta data (such as the User's IP address) must be added\n   * by the SDK implementor.\n   *\n   * The returned event status offers clues to whether the event was sent to\n   * Sentry and accepted there. If the {@link Options.shouldSend} hook returns\n   * `false`, the status will be {@link SendStatus.Skipped}. If the rate limit\n   * was exceeded, the status will be {@link SendStatus.RateLimit}.\n   *\n   * @param event The event to send to Sentry.\n   * @param send A function to actually send the event.\n   * @param scope A scope containing event metadata.\n   * @returns A Promise that resolves with the event status.\n   */\n  protected async processEvent(\n    event: SentryEvent,\n    send: (finalEvent: SentryEvent) => Promise<number>,\n    scope?: Scope,\n  ): Promise<SendStatus> {\n    if (!this.isEnabled()) {\n      return SendStatus.Skipped;\n    }\n\n    const prepared = await this.prepareEvent(event, scope);\n    const { shouldSend, beforeSend, afterSend } = this.getOptions();\n    if (shouldSend && !shouldSend(prepared)) {\n      return SendStatus.Skipped;\n    }\n\n    const finalEvent = beforeSend ? beforeSend(prepared) : prepared;\n    const code = await send(finalEvent);\n    const status = SendStatus.fromHttpCode(code);\n\n    if (status === SendStatus.RateLimit) {\n      // TODO: Handle rate limits and maintain a queue. For now, we require SDK\n      // implementors to override this method and handle it themselves.\n    }\n\n    if (afterSend) {\n      afterSend(finalEvent, status);\n    }\n\n    return status;\n  }\n}\n"]}