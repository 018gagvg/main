import {
  Adapter,
  Breadcrumb,
  Client,
  Context,
  Options,
  SentryEvent,
  User,
} from '@sentry/core';

import * as RavenJS from 'raven-js';

/** Internal override to raven */
interface RavenInternal {
  _globalOptions: {};
  captureBreadcrumb(breadcrumb: Breadcrumb): Promise<Breadcrumb>;
  captureException(exception: any): Promise<SentryEvent>;
  captureMessage(message: string): Promise<SentryEvent>;
  config(dsn: string, options: object): RavenInternal;
  getContext(): Promise<Context>;
  install(): void;
  setBreadcrumbCallback(cb: (b: Breadcrumb) => Breadcrumb | boolean): void;
  setExtraContext(data: object): void;
  setUserContext(user: User): void;
  setTagsContext(tags: { [key: string]: string }): void;
  wrap(options: object, fn: () => void): () => void;
  _sendProcessedPayload(event: SentryEvent, cb: (err: any) => void): void;
}

// Casting Raven to an internal type so we can access internal functions
const raven = (RavenJS as any) as RavenInternal;
// Storing the original send function, since we will patch it down below
// tslint:disable-next-line:no-unbound-method
const sendRavenEvent = raven._sendProcessedPayload;

/** TODO */
// tslint:disable-next-line:no-empty-interface
export interface BrowserOptions extends Options {}

/** TODO */
export class SentryBrowser implements Adapter {
  /** TODO */
  public readonly options: BrowserOptions;
  /** TODO */
  private readonly client: Client;
  /** TODO */
  private capturing: boolean;
  /** TODO */
  private captured: any;

  /** TODO */
  public constructor(client: Client, options: BrowserOptions = {}) {
    this.client = client;
    this.options = options;
    this.capturing = false;
    this.captured = undefined;
  }

  /** TODO */
  public async install(): Promise<boolean> {
    raven.config(this.client.dsn.toString(), this.options).install();

    // Hook into Raven's breadcrumb mechanism. This allows us to intercept
    // both breadcrumbs created internally by Raven and pass them to the
    // Client first, before actually capturing them.
    raven.setBreadcrumbCallback(b => this.interceptRavenBreadcrumb(b));

    // Hook into Raven's internal event sending mechanism. This allows us to
    // intercept events generated by Raven in the same way as events created
    // via `SentryBrowser.captureException`. In both cases, we call
    // `Client.send` with the intercepted event, so that the client can
    // override the sending mechanism.
    raven._sendProcessedPayload = e => {
      this.interceptRavenSend(e);
    };

    return true;
  }

  /**
   * TODO
   * @deprecated
   */
  public getRaven: any = () => RavenJS;

  /** TODO */
  public async captureException(exception: any): Promise<SentryEvent> {
    // We are being called by the Client. We must not send the exception here,
    // which is why we capture and return it. The Client will then call `send`.
    return this.capture(async () => raven.captureException(exception));
  }

  /** TODO */
  public async captureMessage(message: string): Promise<SentryEvent> {
    // We are being called by the Client. We must not send the message here,
    // which is why we capture and return it. The Client will then call `send`.
    return this.capture(async () => raven.captureMessage(message));
  }

  /** TODO */
  public async captureBreadcrumb(breadcrumb: Breadcrumb): Promise<Breadcrumb> {
    // We are being called by the Client. This means, the breadcrumb has been
    // processed already and we can pass it on to Raven.
    return this.capture(async () => raven.captureBreadcrumb(breadcrumb));
  }

  /** TODO */
  public send = async (event: SentryEvent) =>
    new Promise<void>((resolve, reject) => {
      sendRavenEvent(event, (error: any) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });

  /** TODO */
  public wrap = (fn: () => void, options: object) => raven.wrap(options, fn);

  /** TODO */
  public async setOptions(options: BrowserOptions): Promise<void> {
    Object.assign(this.options, options);
    Object.assign(raven._globalOptions, this.options);
  }

  /** TODO */
  public getContext = async () => raven.getContext();

  /** TODO */
  public setContext = async (context: Context) => {
    if (context.extra) {
      raven.setExtraContext(context.extra);
    }
    if (context.user) {
      raven.setUserContext(context.user);
    }
    if (context.tags) {
      raven.setTagsContext(context.tags);
    }
  };

  /** TODO */
  private interceptRavenSend(event: SentryEvent): void {
    if (this.capturing) {
      // This event was requested via `SentryBrowser.captureException` or
      // `SentryBrowser.captureMessage`. We capture it, which will return it to
      // the `Client`. The client will call its `send` method automatically.
      this.captured = event;
    } else {
      // This event was generated inside RavenJS in a wrapped function or
      // global exception hook. We have to manually pass it to `Client.send`.
      // The client will then run all callbacks and decide how to send this
      // event.
      this.client.send(event).catch(e => {
        this.client.log(e);
      });
    }
  }

  /** TODO */
  private interceptRavenBreadcrumb(crumb: Breadcrumb): Breadcrumb | boolean {
    if (this.capturing) {
      // This breadcrumb is being captured explicitly by the Client. We return
      // it so that Raven uses its internal mechanism to store it.
      this.captured = crumb;
      return crumb;
    }

    // The breadcrumb has been generated internally by Raven. We return `false`
    // to prevent Raven's default mechanism and pass it to the client instead.
    // The client can then run all callbacks and decide how to store the
    // breadcrumb. If SentryBrowser is in charge, the Client will call
    // `SentryBrowser.captureBreadcrumb` next, which will capture it (see
    // above).
    this.client.captureBreadcrumb(crumb).catch(e => {
      this.client.log(e);
    });

    return false;
  }

  /** TODO */
  private capture<R>(callback: () => void): R {
    this.captured = undefined;
    this.capturing = true;
    callback();

    const captured = this.captured;
    this.captured = undefined;
    this.capturing = false;

    if (captured === undefined) {
      throw new Error('Could not capture.');
    }

    return captured as R;
  }
}
