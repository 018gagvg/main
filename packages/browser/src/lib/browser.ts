import {
  Adapter,
  Breadcrumb,
  Client,
  Context,
  SentryEvent,
  Options,
  User,
} from '@sentry/core';

import * as RavenJS from 'raven-js';
const Raven = RavenJS as any;
const sendRavenEvent = Raven._sendProcessedPayload;

export interface BrowserOptions extends Options {}

export class SentryBrowser implements Adapter {
  private capturing: boolean = false;
  private captured: any;

  constructor(private client: Client, public options: BrowserOptions = {}) {}

  private interceptRavenSend(event: SentryEvent) {
    if (this.capturing) {
      // This event was requested via `SentryBrowser.captureException` or
      // `SentryBrowser.captureMessage`. We capture it, which will return it to
      // the `Client`. The client will call its `send` method automatically.
      this.captured = event;
    } else {
      // This event was generated inside RavenJS in a wrapped function or
      // global exception hook. We have to manually pass it to `Client.send`.
      // The client will then run all callbacks and decide how to send this
      // event.
      this.client.send(event);
    }
  }

  private interceptRavenBreadcrumb(crumb: Breadcrumb): Breadcrumb | boolean {
    if (this.capturing) {
      // This breadcrumb is being captured explicitly by the Client. We return
      // it so that Raven uses its internal mechanism to store it.
      this.captured = crumb;
      return crumb;
    }

    // The breadcrumb has been generated internally by Raven. We return `false`
    // to prevent Raven's default mechanism and pass it to the client instead.
    // The client can then run all callbacks and decide how to store the
    // breadcrumb. If SentryBrowser is in charge, the Client will call
    // `SentryBrowser.captureBreadcrumb` next, which will capture it (see
    // above).
    this.client.captureBreadcrumb(crumb);
    return false;
  }

  private capture<R>(callback: Function): R {
    this.captured = undefined;
    this.capturing = true;
    callback();

    const captured = this.captured;
    this.captured = undefined;
    this.capturing = false;

    if (captured === undefined) {
      throw new Error('Could not capture.');
    }

    return captured as R;
  }

  public install() {
    Raven.config(this.client.dsn.toString(), this.options).install();

    // Hook into Raven's breadcrumb mechanism. This allows us to intercept
    // both breadcrumbs created internally by Raven and pass them to the
    // Client first, before actually capturing them.
    Raven.setBreadcrumbCallback(this.interceptRavenBreadcrumb.bind(this));

    // Hook into Raven's internal event sending mechanism. This allows us to
    // intercept events generated by Raven in the same way as events created
    // via `SentryBrowser.captureException`. In both cases, we call
    // `Client.send` with the intercepted event, so that the client can
    // override the sending mechanism.
    Raven._sendProcessedPayload = this.interceptRavenSend.bind(this);

    return Promise.resolve(true);
  }

  public getRaven() {
    return Raven;
  }

  public async captureException(exception: any): Promise<SentryEvent> {
    // We are being called by the Client. We must not send the exception here,
    // which is why we capture and return it. The Client will then call `send`.
    return this.capture(() => Raven.captureException(exception));
  }

  public async captureMessage(message: string): Promise<SentryEvent> {
    // We are being called by the Client. We must not send the message here,
    // which is why we capture and return it. The Client will then call `send`.
    return this.capture(() => Raven.captureMessage(message));
  }

  public async captureBreadcrumb(breadcrumb: Breadcrumb): Promise<Breadcrumb> {
    // We are being called by the Client. This means, the breadcrumb has been
    // processed already and we can pass it on to Raven.
    return this.capture(() => Raven.captureBreadcrumb(breadcrumb));
  }

  public send(event: SentryEvent): Promise<void> {
    return new Promise<void>((resolve, reject) => {
      sendRavenEvent(event, (error: any) => {
        if (error) {
          reject(error);
        } else {
          resolve();
        }
      });
    });
  }

  public wrap(fn: Function, options: object): Function {
    return Raven.wrap(options, fn);
  }

  public setOptions(options: BrowserOptions): Promise<void> {
    Object.assign(this.options, options);
    Object.assign(Raven._globalOptions, this.options);
    return Promise.resolve();
  }

  public async getContext(): Promise<Context> {
    return Promise.resolve(Raven.getContext());
  }

  public setContext(context: Context): Promise<void> {
    if (context.extra) {
      Raven.setExtraContext(context.extra);
    }
    if (context.user) {
      Raven.setUserContext(context.user);
    }
    if (context.tags) {
      Raven.setTagsContext(context.tags);
    }
    return Promise.resolve();
  }
}
