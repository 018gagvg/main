diff --git a/node_modules/rrweb-snapshot/dist/rrweb-snapshot.js b/node_modules/rrweb-snapshot/dist/rrweb-snapshot.js
old mode 100644
new mode 100755
index 4ece2ab..86a9b7a
--- a/node_modules/rrweb-snapshot/dist/rrweb-snapshot.js
+++ b/node_modules/rrweb-snapshot/dist/rrweb-snapshot.js
@@ -20,10 +20,14 @@ var rrwebSnapshot = (function (exports) {
         return Boolean(host && host.shadowRoot && host.shadowRoot === n);
     }
     function maskInputValue(_a) {
-        var maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;
+        var input = _a.input, maskInputSelector = _a.maskInputSelector, unmaskInputSelector = _a.unmaskInputSelector, maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;
         var text = value || '';
+        if (unmaskInputSelector && input.matches(unmaskInputSelector)) {
+            return text;
+        }
         if (maskInputOptions[tagName.toLowerCase()] ||
-            maskInputOptions[type]) {
+            maskInputOptions[type] ||
+            (maskInputSelector && input.matches(maskInputSelector))) {
             if (maskInputFn) {
                 text = maskInputFn(text);
             }
@@ -250,7 +254,10 @@ var rrwebSnapshot = (function (exports) {
             return value;
         }
     }
-    function _isBlockedElement(element, blockClass, blockSelector) {
+    function _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {
+        if (unblockSelector && element.matches(unblockSelector)) {
+            return false;
+        }
         if (typeof blockClass === 'string') {
             if (element.classList.contains(blockClass)) {
                 return true;
@@ -269,11 +276,16 @@ var rrwebSnapshot = (function (exports) {
         }
         return false;
     }
-    function needMaskingText(node, maskTextClass, maskTextSelector) {
+    function needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextSelector) {
         if (!node) {
             return false;
         }
         if (node.nodeType === node.ELEMENT_NODE) {
+            if (unmaskTextSelector) {
+                if (node.matches(unmaskTextSelector) || node.closest(unmaskTextSelector)) {
+                    return false;
+                }
+            }
             if (typeof maskTextClass === 'string') {
                 if (node.classList.contains(maskTextClass)) {
                     return true;
@@ -292,12 +304,12 @@ var rrwebSnapshot = (function (exports) {
                     return true;
                 }
             }
-            return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+            return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
         }
         if (node.nodeType === node.TEXT_NODE) {
-            return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+            return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
         }
-        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
     }
     function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
         var win = iframeEl.contentWindow;
@@ -337,7 +349,7 @@ var rrwebSnapshot = (function (exports) {
     }
     function serializeNode(n, options) {
         var _a;
-        var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, inlineStylesheet = options.inlineStylesheet, _b = options.maskInputOptions, maskInputOptions = _b === void 0 ? {} : _b, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _c = options.dataURLOptions, dataURLOptions = _c === void 0 ? {} : _c, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;
+        var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, unblockSelector = options.unblockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, unmaskTextSelector = options.unmaskTextSelector, inlineStylesheet = options.inlineStylesheet, maskInputSelector = options.maskInputSelector, unmaskInputSelector = options.unmaskInputSelector, _b = options.maskInputOptions, maskInputOptions = _b === void 0 ? {} : _b, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _c = options.dataURLOptions, dataURLOptions = _c === void 0 ? {} : _c, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;
         var rootId;
         if (doc.__sn) {
             var docId = doc.__sn.id;
@@ -369,7 +381,7 @@ var rrwebSnapshot = (function (exports) {
                     rootId: rootId
                 };
             case n.ELEMENT_NODE:
-                var needBlock = _isBlockedElement(n, blockClass, blockSelector);
+                var needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);
                 var tagName = getValidTagName(n);
                 var attributes_1 = {};
                 for (var _i = 0, _d = Array.from(n.attributes); _i < _d.length; _i++) {
@@ -410,9 +422,12 @@ var rrwebSnapshot = (function (exports) {
                         attributes_1.type !== 'button' &&
                         value) {
                         attributes_1.value = maskInputValue({
+                            input: n,
                             type: attributes_1.type,
                             tagName: tagName,
                             value: value,
+                            maskInputSelector: maskInputSelector,
+                            unmaskInputSelector: unmaskInputSelector,
                             maskInputOptions: maskInputOptions,
                             maskInputFn: maskInputFn
                         });
@@ -531,7 +546,7 @@ var rrwebSnapshot = (function (exports) {
                 }
                 if (!isStyle &&
                     !isScript &&
-                    needMaskingText(n, maskTextClass, maskTextSelector) &&
+                    needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextSelector) &&
                     textContent) {
                     textContent = maskTextFn
                         ? maskTextFn(textContent)
@@ -639,15 +654,19 @@ var rrwebSnapshot = (function (exports) {
         return false;
     }
     function serializeNodeWithId(n, options) {
-        var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, _h = options.keepIframeSrcFn, keepIframeSrcFn = _h === void 0 ? function () { return false; } : _h;
+        var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, unblockSelector = options.unblockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, unmaskTextSelector = options.unmaskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, maskInputSelector = options.maskInputSelector, unmaskInputSelector = options.unmaskInputSelector, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, _h = options.keepIframeSrcFn, keepIframeSrcFn = _h === void 0 ? function () { return false; } : _h;
         var _j = options.preserveWhiteSpace, preserveWhiteSpace = _j === void 0 ? true : _j;
         var _serializedNode = serializeNode(n, {
             doc: doc,
             blockClass: blockClass,
             blockSelector: blockSelector,
+            unblockSelector: unblockSelector,
             maskTextClass: maskTextClass,
             maskTextSelector: maskTextSelector,
+            unmaskTextSelector: unmaskTextSelector,
             inlineStylesheet: inlineStylesheet,
+            maskInputSelector: maskInputSelector,
+            unmaskInputSelector: unmaskInputSelector,
             maskInputOptions: maskInputOptions,
             maskTextFn: maskTextFn,
             maskInputFn: maskInputFn,
@@ -703,10 +722,14 @@ var rrwebSnapshot = (function (exports) {
                 map: map,
                 blockClass: blockClass,
                 blockSelector: blockSelector,
+                unblockSelector: unblockSelector,
                 maskTextClass: maskTextClass,
                 maskTextSelector: maskTextSelector,
+                unmaskTextSelector: unmaskTextSelector,
                 skipChild: skipChild,
                 inlineStylesheet: inlineStylesheet,
+                maskInputSelector: maskInputSelector,
+                unmaskInputSelector: unmaskInputSelector,
                 maskInputOptions: maskInputOptions,
                 maskTextFn: maskTextFn,
                 maskInputFn: maskInputFn,
@@ -751,10 +774,14 @@ var rrwebSnapshot = (function (exports) {
                         map: map,
                         blockClass: blockClass,
                         blockSelector: blockSelector,
+                        unblockSelector: unblockSelector,
                         maskTextClass: maskTextClass,
                         maskTextSelector: maskTextSelector,
+                        unmaskTextSelector: unmaskTextSelector,
                         skipChild: false,
                         inlineStylesheet: inlineStylesheet,
+                        maskInputSelector: maskInputSelector,
+                        unmaskInputSelector: unmaskInputSelector,
                         maskInputOptions: maskInputOptions,
                         maskTextFn: maskTextFn,
                         maskInputFn: maskInputFn,
@@ -777,7 +804,7 @@ var rrwebSnapshot = (function (exports) {
         return serializedNode;
     }
     function snapshot(n, options) {
-        var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.maskTextClass, maskTextClass = _d === void 0 ? 'rr-mask' : _d, _e = _a.maskTextSelector, maskTextSelector = _e === void 0 ? null : _e, _f = _a.inlineStylesheet, inlineStylesheet = _f === void 0 ? true : _f, _g = _a.inlineImages, inlineImages = _g === void 0 ? false : _g, _h = _a.recordCanvas, recordCanvas = _h === void 0 ? false : _h, _j = _a.maskAllInputs, maskAllInputs = _j === void 0 ? false : _j, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _k = _a.slimDOM, slimDOM = _k === void 0 ? false : _k, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _l = _a.keepIframeSrcFn, keepIframeSrcFn = _l === void 0 ? function () { return false; } : _l;
+        var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.unblockSelector, unblockSelector = _d === void 0 ? null : _d, _e = _a.maskTextClass, maskTextClass = _e === void 0 ? 'rr-mask' : _e, _f = _a.maskTextSelector, maskTextSelector = _f === void 0 ? null : _f, _g = _a.unmaskTextSelector, unmaskTextSelector = _g === void 0 ? null : _g, _h = _a.inlineStylesheet, inlineStylesheet = _h === void 0 ? true : _h, _j = _a.inlineImages, inlineImages = _j === void 0 ? false : _j, _k = _a.recordCanvas, recordCanvas = _k === void 0 ? false : _k, _l = _a.maskInputSelector, maskInputSelector = _l === void 0 ? null : _l, _m = _a.unmaskInputSelector, unmaskInputSelector = _m === void 0 ? null : _m, _o = _a.maskAllInputs, maskAllInputs = _o === void 0 ? false : _o, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _p = _a.slimDOM, slimDOM = _p === void 0 ? false : _p, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _q = _a.keepIframeSrcFn, keepIframeSrcFn = _q === void 0 ? function () { return false; } : _q;
         var idNodeMap = {};
         var maskInputOptions = maskAllInputs === true
             ? {
@@ -826,10 +853,14 @@ var rrwebSnapshot = (function (exports) {
                 map: idNodeMap,
                 blockClass: blockClass,
                 blockSelector: blockSelector,
+                unblockSelector: unblockSelector,
                 maskTextClass: maskTextClass,
                 maskTextSelector: maskTextSelector,
+                unmaskTextSelector: unmaskTextSelector,
                 skipChild: false,
                 inlineStylesheet: inlineStylesheet,
+                maskInputSelector: maskInputSelector,
+                unmaskInputSelector: unmaskInputSelector,
                 maskInputOptions: maskInputOptions,
                 maskTextFn: maskTextFn,
                 maskInputFn: maskInputFn,
diff --git a/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js b/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js
old mode 100644
new mode 100755
index e1259cb..5bd5559
--- a/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js
+++ b/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js
@@ -1,2 +1,2 @@
-var rrwebSnapshot=function(e){"use strict";var t;function r(e){return e.nodeType===e.ELEMENT_NODE}function n(e){var t,r=null===(t=e)||void 0===t?void 0:t.host;return Boolean(r&&r.shadowRoot&&r.shadowRoot===e)}function a(e){var t=e.maskInputOptions,r=e.tagName,n=e.type,a=e.value,i=e.maskInputFn,o=a||"";return(t[r.toLowerCase()]||t[n])&&(o=i?i(o):"*".repeat(o.length)),o}e.NodeType=void 0,(t=e.NodeType||(e.NodeType={}))[t.Document=0]="Document",t[t.DocumentType=1]="DocumentType",t[t.Element=2]="Element",t[t.Text=3]="Text",t[t.CDATA=4]="CDATA",t[t.Comment=5]="Comment";var i="__rrweb_original__";function o(e){var t=e.getContext("2d");if(!t)return!0;for(var r=0;r<e.width;r+=50)for(var n=0;n<e.height;n+=50){var a=t.getImageData,o=i in a?a.__rrweb_original__:a;if(new Uint32Array(o.call(t,r,n,Math.min(50,e.width-r),Math.min(50,e.height-n)).data.buffer).some((function(e){return 0!==e})))return!1}return!0}var s,c,l=1,u=new RegExp("[^a-z0-9-_:]");function f(e){try{var t=e.rules||e.cssRules;return t?Array.from(t).map(d).join(""):null}catch(e){return null}}function d(e){var t=e.cssText;if(function(e){return"styleSheet"in e}(e))try{t=f(e.styleSheet)||t}catch(e){}return t}var p=/url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,m=/^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/,h=/^(data:)([^,]*),(.*)/i;function v(e,t){return(e||"").replace(p,(function(e,r,n,a,i,o){var s,c=n||i||o,l=r||a||"";if(!c)return e;if(!m.test(c))return"url("+l+c+l+")";if(h.test(c))return"url("+l+c+l+")";if("/"===c[0])return"url("+l+(((s=t).indexOf("//")>-1?s.split("/").slice(0,3).join("/"):s.split("/")[0]).split("?")[0]+c)+l+")";var u=t.split("/"),f=c.split("/");u.pop();for(var d=0,p=f;d<p.length;d++){var v=p[d];"."!==v&&(".."===v?u.pop():u.push(v))}return"url("+l+u.join("/")+l+")"}))}var y=/^[^ \t\n\r\u000c]+/,g=/^[, \t\n\r\u000c]+/;function T(e,t){if(!t||""===t.trim())return t;var r=e.createElement("a");return r.href=t,r.href}function b(){var e=document.createElement("a");return e.href="",e.href}function k(e,t,r,n){return"src"===r||"href"===r&&n||"xlink:href"===r&&n&&"#"!==n[0]?T(e,n):"background"!==r||!n||"table"!==t&&"td"!==t&&"th"!==t?"srcset"===r&&n?function(e,t){if(""===t.trim())return t;var r=0;function n(e){var n,a=e.exec(t.substring(r));return a?(n=a[0],r+=n.length,n):""}for(var a=[];n(g),!(r>=t.length);){var i=n(y);if(","===i.slice(-1))i=T(e,i.substring(0,i.length-1)),a.push(i);else{var o="";i=T(e,i);for(var s=!1;;){var c=t.charAt(r);if(""===c){a.push((i+o).trim());break}if(s)")"===c&&(s=!1);else{if(","===c){r+=1,a.push((i+o).trim());break}"("===c&&(s=!0)}o+=c,r+=1}}}return a.join(", ")}(e,n):"style"===r&&n?v(n,b()):"object"===t&&"data"===r&&n?T(e,n):n:T(e,n)}function C(e,t,r){if(!e)return!1;if(e.nodeType===e.ELEMENT_NODE){if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var n=0;n<e.classList.length;n++){var a=e.classList[n];if(t.test(a))return!0}return!(!r||!e.matches(r))||C(e.parentNode,t,r)}return e.nodeType,e.TEXT_NODE,C(e.parentNode,t,r)}function N(t,r){var n,i,l,d,p=r.doc,m=r.blockClass,h=r.blockSelector,y=r.maskTextClass,g=r.maskTextSelector,T=r.inlineStylesheet,N=r.maskInputOptions,w=void 0===N?{}:N,S=r.maskTextFn,x=r.maskInputFn,E=r.dataURLOptions,_=void 0===E?{}:E,I=r.inlineImages,D=r.recordCanvas,L=r.keepIframeSrcFn;if(p.__sn){var O=p.__sn.id;i=1===O?void 0:O}switch(t.nodeType){case t.DOCUMENT_NODE:return"CSS1Compat"!==t.compatMode?{type:e.NodeType.Document,childNodes:[],compatMode:t.compatMode,rootId:i}:{type:e.NodeType.Document,childNodes:[],rootId:i};case t.DOCUMENT_TYPE_NODE:return{type:e.NodeType.DocumentType,name:t.name,publicId:t.publicId,systemId:t.systemId,rootId:i};case t.ELEMENT_NODE:for(var A=function(e,t,r){if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var n=0;n<e.classList.length;n++){var a=e.classList[n];if(t.test(a))return!0}return!!r&&e.matches(r)}(t,m,h),R=function(e){if(e instanceof HTMLFormElement)return"form";var t=e.tagName.toLowerCase().trim();return u.test(t)?"div":t}(t),M={},F=0,U=Array.from(t.attributes);F<U.length;F++){var W=U[F],j=W.name,P=W.value;M[j]=k(p,R,j,P)}if("link"===R&&T){var B=Array.from(p.styleSheets).find((function(e){return e.href===t.href})),H=null;B&&(H=f(B)),H&&(delete M.rel,delete M.href,M._cssText=v(H,B.href))}if("style"===R&&t.sheet&&!(t.innerText||t.textContent||"").trim().length)(H=f(t.sheet))&&(M._cssText=v(H,b()));if("input"===R||"textarea"===R||"select"===R){P=t.value;"radio"!==M.type&&"checkbox"!==M.type&&"submit"!==M.type&&"button"!==M.type&&P?M.value=a({type:M.type,tagName:R,value:P,maskInputOptions:w,maskInputFn:x}):t.checked&&(M.checked=t.checked)}if("option"===R&&(t.selected&&!w.select?M.selected=!0:delete M.selected),"canvas"===R&&D)if("2d"===t.__context)o(t)||(M.rr_dataURL=t.toDataURL(_.type,_.quality));else if(!("__context"in t)){var G=t.toDataURL(_.type,_.quality),z=document.createElement("canvas");z.width=t.width,z.height=t.height,G!==z.toDataURL(_.type,_.quality)&&(M.rr_dataURL=G)}if("img"===R&&I){s||(s=p.createElement("canvas"),c=s.getContext("2d"));var q=t,V=q.crossOrigin;q.crossOrigin="anonymous";var $=function(){try{s.width=q.naturalWidth,s.height=q.naturalHeight,c.drawImage(q,0,0),M.rr_dataURL=s.toDataURL(_.type,_.quality)}catch(e){console.warn("Cannot inline img src="+q.currentSrc+"! Error: "+e)}V?M.crossOrigin=V:delete M.crossOrigin};q.complete&&0!==q.naturalWidth?$():q.onload=$}if("audio"!==R&&"video"!==R||(M.rr_mediaState=t.paused?"paused":"played",M.rr_mediaCurrentTime=t.currentTime),t.scrollLeft&&(M.rr_scrollLeft=t.scrollLeft),t.scrollTop&&(M.rr_scrollTop=t.scrollTop),A){var X=t.getBoundingClientRect(),Y=X.width,K=X.height;M={class:M.class,rr_width:Y+"px",rr_height:K+"px"}}return"iframe"!==R||L(M.src)||(t.contentDocument||(M.rr_src=M.src),delete M.src),{type:e.NodeType.Element,tagName:R,attributes:M,childNodes:[],isSVG:(d=t,Boolean("svg"===d.tagName||d.ownerSVGElement)||void 0),needBlock:A,rootId:i};case t.TEXT_NODE:var Z=t.parentNode&&t.parentNode.tagName,J=t.textContent,Q="STYLE"===Z||void 0,ee="SCRIPT"===Z||void 0;if(Q&&J){try{t.nextSibling||t.previousSibling||(null===(n=t.parentNode.sheet)||void 0===n?void 0:n.cssRules)&&(J=(l=t.parentNode.sheet).cssRules?Array.from(l.cssRules).map((function(e){return e.cssText||""})).join(""):"")}catch(e){console.warn("Cannot get CSS styles from text's parentNode. Error: "+e,t)}J=v(J,b())}return ee&&(J="SCRIPT_PLACEHOLDER"),!Q&&!ee&&C(t,y,g)&&J&&(J=S?S(J):J.replace(/[\S]/g,"*")),{type:e.NodeType.Text,textContent:J||"",isStyle:Q,rootId:i};case t.CDATA_SECTION_NODE:return{type:e.NodeType.CDATA,textContent:"",rootId:i};case t.COMMENT_NODE:return{type:e.NodeType.Comment,textContent:t.textContent||"",rootId:i};default:return!1}}function w(e){return void 0===e?"":e.toLowerCase()}function S(t,a){var i,o=a.doc,s=a.map,c=a.blockClass,u=a.blockSelector,f=a.maskTextClass,d=a.maskTextSelector,p=a.skipChild,m=void 0!==p&&p,h=a.inlineStylesheet,v=void 0===h||h,y=a.maskInputOptions,g=void 0===y?{}:y,T=a.maskTextFn,b=a.maskInputFn,k=a.slimDOMOptions,C=a.dataURLOptions,x=void 0===C?{}:C,E=a.inlineImages,_=void 0!==E&&E,I=a.recordCanvas,D=void 0!==I&&I,L=a.onSerialize,O=a.onIframeLoad,A=a.iframeLoadTimeout,R=void 0===A?5e3:A,M=a.keepIframeSrcFn,F=void 0===M?function(){return!1}:M,U=a.preserveWhiteSpace,W=void 0===U||U,j=N(t,{doc:o,blockClass:c,blockSelector:u,maskTextClass:f,maskTextSelector:d,inlineStylesheet:v,maskInputOptions:g,maskTextFn:T,maskInputFn:b,dataURLOptions:x,inlineImages:_,recordCanvas:D,keepIframeSrcFn:F});if(!j)return console.warn(t,"not serialized"),null;i="__sn"in t?t.__sn.id:!function(t,r){if(r.comment&&t.type===e.NodeType.Comment)return!0;if(t.type===e.NodeType.Element){if(r.script&&("script"===t.tagName||"link"===t.tagName&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===t.tagName&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")))return!0;if(r.headFavicon&&("link"===t.tagName&&"shortcut icon"===t.attributes.rel||"meta"===t.tagName&&(w(t.attributes.name).match(/^msapplication-tile(image|color)$/)||"application-name"===w(t.attributes.name)||"icon"===w(t.attributes.rel)||"apple-touch-icon"===w(t.attributes.rel)||"shortcut icon"===w(t.attributes.rel))))return!0;if("meta"===t.tagName){if(r.headMetaDescKeywords&&w(t.attributes.name).match(/^description|keywords$/))return!0;if(r.headMetaSocial&&(w(t.attributes.property).match(/^(og|twitter|fb):/)||w(t.attributes.name).match(/^(og|twitter):/)||"pinterest"===w(t.attributes.name)))return!0;if(r.headMetaRobots&&("robots"===w(t.attributes.name)||"googlebot"===w(t.attributes.name)||"bingbot"===w(t.attributes.name)))return!0;if(r.headMetaHttpEquiv&&void 0!==t.attributes["http-equiv"])return!0;if(r.headMetaAuthorship&&("author"===w(t.attributes.name)||"generator"===w(t.attributes.name)||"framework"===w(t.attributes.name)||"publisher"===w(t.attributes.name)||"progid"===w(t.attributes.name)||w(t.attributes.property).match(/^article:/)||w(t.attributes.property).match(/^product:/)))return!0;if(r.headMetaVerification&&("google-site-verification"===w(t.attributes.name)||"yandex-verification"===w(t.attributes.name)||"csrf-token"===w(t.attributes.name)||"p:domain_verify"===w(t.attributes.name)||"verify-v1"===w(t.attributes.name)||"verification"===w(t.attributes.name)||"shopify-checkout-api-token"===w(t.attributes.name)))return!0}}return!1}(j,k)&&(W||j.type!==e.NodeType.Text||j.isStyle||j.textContent.replace(/^\s+|\s+$/gm,"").length)?l++:-2;var P=Object.assign(j,{id:i});if(t.__sn=P,-2===i)return null;s[i]=t,L&&L(t);var B=!m;if(P.type===e.NodeType.Element&&(B=B&&!P.needBlock,delete P.needBlock,t.shadowRoot&&(P.isShadowHost=!0)),(P.type===e.NodeType.Document||P.type===e.NodeType.Element)&&B){k.headWhitespace&&j.type===e.NodeType.Element&&"head"===j.tagName&&(W=!1);for(var H={doc:o,map:s,blockClass:c,blockSelector:u,maskTextClass:f,maskTextSelector:d,skipChild:m,inlineStylesheet:v,maskInputOptions:g,maskTextFn:T,maskInputFn:b,slimDOMOptions:k,dataURLOptions:x,inlineImages:_,recordCanvas:D,preserveWhiteSpace:W,onSerialize:L,onIframeLoad:O,iframeLoadTimeout:R,keepIframeSrcFn:F},G=0,z=Array.from(t.childNodes);G<z.length;G++){($=S(z[G],H))&&P.childNodes.push($)}if(r(t)&&t.shadowRoot)for(var q=0,V=Array.from(t.shadowRoot.childNodes);q<V.length;q++){var $;($=S(V[q],H))&&($.isShadow=!0,P.childNodes.push($))}}return t.parentNode&&n(t.parentNode)&&(P.isShadow=!0),P.type===e.NodeType.Element&&"iframe"===P.tagName&&function(e,t,r){var n=e.contentWindow;if(n){var a,i=!1;try{a=n.document.readyState}catch(e){return}if("complete"===a){var o="about:blank";n.location.href===o&&e.src!==o&&""!==e.src?e.addEventListener("load",t):setTimeout(t,0)}else{var s=setTimeout((function(){i||(t(),i=!0)}),r);e.addEventListener("load",(function(){clearTimeout(s),i=!0,t()}))}}}(t,(function(){var e=t.contentDocument;if(e&&O){var r=S(e,{doc:e,map:s,blockClass:c,blockSelector:u,maskTextClass:f,maskTextSelector:d,skipChild:!1,inlineStylesheet:v,maskInputOptions:g,maskTextFn:T,maskInputFn:b,slimDOMOptions:k,dataURLOptions:x,inlineImages:_,recordCanvas:D,preserveWhiteSpace:W,onSerialize:L,onIframeLoad:O,iframeLoadTimeout:R,keepIframeSrcFn:F});r&&O(t,r)}}),R),P}var x=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;function E(e,t){void 0===t&&(t={});var r=1,n=1;function a(e){var t=e.match(/\n/g);t&&(r+=t.length);var a=e.lastIndexOf("\n");n=-1===a?n+e.length:e.length-a}function i(){var e={line:r,column:n};return function(t){return t.position=new o(e),p(),t}}var o=function(e){this.start=e,this.end={line:r,column:n},this.source=t.source};o.prototype.content=e;var s=[];function c(a){var i=new Error(t.source+":"+r+":"+n+": "+a);if(i.reason=a,i.filename=t.source,i.line=r,i.column=n,i.source=e,!t.silent)throw i;s.push(i)}function l(){return d(/^{\s*/)}function u(){return d(/^}/)}function f(){var t,r=[];for(p(),m(r);e.length&&"}"!==e.charAt(0)&&(t=S()||E());)!1!==t&&(r.push(t),m(r));return r}function d(t){var r=t.exec(e);if(r){var n=r[0];return a(n),e=e.slice(n.length),r}}function p(){d(/^\s*/)}function m(e){var t;for(void 0===e&&(e=[]);t=h();)!1!==t&&e.push(t),t=h();return e}function h(){var t=i();if("/"===e.charAt(0)&&"*"===e.charAt(1)){for(var r=2;""!==e.charAt(r)&&("*"!==e.charAt(r)||"/"!==e.charAt(r+1));)++r;if(r+=2,""===e.charAt(r-1))return c("End of comment missing");var o=e.slice(2,r-2);return n+=2,a(o),e=e.slice(r),n+=2,t({type:"comment",comment:o})}}function v(){var e=d(/^([^{]+)/);if(e)return _(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g,"").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g,(function(e){return e.replace(/,/g,"‌")})).split(/\s*(?![^(]*\)),\s*/).map((function(e){return e.replace(/\u200C/g,",")}))}function y(){var e=i(),t=d(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);if(t){var r=_(t[0]);if(!d(/^:\s*/))return c("property missing ':'");var n=d(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/),a=e({type:"declaration",property:r.replace(x,""),value:n?_(n[0]).replace(x,""):""});return d(/^[;\s]*/),a}}function g(){var e,t=[];if(!l())return c("missing '{'");for(m(t);e=y();)!1!==e&&(t.push(e),m(t)),e=y();return u()?t:c("missing '}'")}function T(){for(var e,t=[],r=i();e=d(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/);)t.push(e[1]),d(/^,\s*/);if(t.length)return r({type:"keyframe",values:t,declarations:g()})}var b,k=w("import"),C=w("charset"),N=w("namespace");function w(e){var t=new RegExp("^@"+e+"\\s*([^;]+);");return function(){var r=i(),n=d(t);if(n){var a={type:e};return a[e]=n[1].trim(),r(a)}}}function S(){if("@"===e[0])return function(){var e=i(),t=d(/^@([-\w]+)?keyframes\s*/);if(t){var r=t[1];if(!(t=d(/^([-\w]+)\s*/)))return c("@keyframes missing name");var n,a=t[1];if(!l())return c("@keyframes missing '{'");for(var o=m();n=T();)o.push(n),o=o.concat(m());return u()?e({type:"keyframes",name:a,vendor:r,keyframes:o}):c("@keyframes missing '}'")}}()||function(){var e=i(),t=d(/^@media *([^{]+)/);if(t){var r=_(t[1]);if(!l())return c("@media missing '{'");var n=m().concat(f());return u()?e({type:"media",media:r,rules:n}):c("@media missing '}'")}}()||function(){var e=i(),t=d(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);if(t)return e({type:"custom-media",name:_(t[1]),media:_(t[2])})}()||function(){var e=i(),t=d(/^@supports *([^{]+)/);if(t){var r=_(t[1]);if(!l())return c("@supports missing '{'");var n=m().concat(f());return u()?e({type:"supports",supports:r,rules:n}):c("@supports missing '}'")}}()||k()||C()||N()||function(){var e=i(),t=d(/^@([-\w]+)?document *([^{]+)/);if(t){var r=_(t[1]),n=_(t[2]);if(!l())return c("@document missing '{'");var a=m().concat(f());return u()?e({type:"document",document:n,vendor:r,rules:a}):c("@document missing '}'")}}()||function(){var e=i();if(d(/^@page */)){var t=v()||[];if(!l())return c("@page missing '{'");for(var r,n=m();r=y();)n.push(r),n=n.concat(m());return u()?e({type:"page",selectors:t,declarations:n}):c("@page missing '}'")}}()||function(){var e=i();if(d(/^@host\s*/)){if(!l())return c("@host missing '{'");var t=m().concat(f());return u()?e({type:"host",rules:t}):c("@host missing '}'")}}()||function(){var e=i();if(d(/^@font-face\s*/)){if(!l())return c("@font-face missing '{'");for(var t,r=m();t=y();)r.push(t),r=r.concat(m());return u()?e({type:"font-face",declarations:r}):c("@font-face missing '}'")}}()}function E(){var e=i(),t=v();return t?(m(),e({type:"rule",selectors:t,declarations:g()})):c("selector missing")}return I((b=f(),{type:"stylesheet",stylesheet:{source:t.source,rules:b,parsingErrors:s}}))}function _(e){return e?e.replace(/^\s+|\s+$/g,""):""}function I(e,t){for(var r=e&&"string"==typeof e.type,n=r?e:t,a=0,i=Object.keys(e);a<i.length;a++){var o=e[i[a]];Array.isArray(o)?o.forEach((function(e){I(e,n)})):o&&"object"==typeof o&&I(o,n)}return r&&Object.defineProperty(e,"parent",{configurable:!0,writable:!0,enumerable:!1,value:t||null}),e}var D={script:"noscript",altglyph:"altGlyph",altglyphdef:"altGlyphDef",altglyphitem:"altGlyphItem",animatecolor:"animateColor",animatemotion:"animateMotion",animatetransform:"animateTransform",clippath:"clipPath",feblend:"feBlend",fecolormatrix:"feColorMatrix",fecomponenttransfer:"feComponentTransfer",fecomposite:"feComposite",feconvolvematrix:"feConvolveMatrix",fediffuselighting:"feDiffuseLighting",fedisplacementmap:"feDisplacementMap",fedistantlight:"feDistantLight",fedropshadow:"feDropShadow",feflood:"feFlood",fefunca:"feFuncA",fefuncb:"feFuncB",fefuncg:"feFuncG",fefuncr:"feFuncR",fegaussianblur:"feGaussianBlur",feimage:"feImage",femerge:"feMerge",femergenode:"feMergeNode",femorphology:"feMorphology",feoffset:"feOffset",fepointlight:"fePointLight",fespecularlighting:"feSpecularLighting",fespotlight:"feSpotLight",fetile:"feTile",feturbulence:"feTurbulence",foreignobject:"foreignObject",glyphref:"glyphRef",lineargradient:"linearGradient",radialgradient:"radialGradient"};var L=/([^\\]):hover/,O=new RegExp(L.source,"g");function A(e,t){var r=null==t?void 0:t.stylesWithHoverClass.get(e);if(r)return r;var n=E(e,{silent:!0});if(!n.stylesheet)return e;var a=[];if(n.stylesheet.rules.forEach((function(e){"selectors"in e&&(e.selectors||[]).forEach((function(e){L.test(e)&&a.push(e)}))})),0===a.length)return e;var i=new RegExp(a.filter((function(e,t){return a.indexOf(e)===t})).sort((function(e,t){return t.length-e.length})).map((function(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")})).join("|"),"g"),o=e.replace(i,(function(e){var t=e.replace(O,"$1.\\:hover");return e+", "+t}));return null==t||t.stylesWithHoverClass.set(e,o),o}function R(t,r){var n=r.doc,a=r.hackCss,i=r.cache;switch(t.type){case e.NodeType.Document:return n.implementation.createDocument(null,"",null);case e.NodeType.DocumentType:return n.implementation.createDocumentType(t.name||"html",t.publicId,t.systemId);case e.NodeType.Element:var o,s=function(e){var t=D[e.tagName]?D[e.tagName]:e.tagName;return"link"===t&&e.attributes._cssText&&(t="style"),t}(t);o=t.isSVG?n.createElementNS("http://www.w3.org/2000/svg",s):n.createElement(s);var c=function(e){if(!t.attributes.hasOwnProperty(e))return"continue";var r=t.attributes[e];if("option"===s&&"selected"===e&&!1===r)return"continue";if(r="boolean"==typeof r||"number"==typeof r?"":r,e.startsWith("rr_")){if("canvas"===s&&"rr_dataURL"===e){var c=document.createElement("img");c.src=r,c.onload=function(){var e=o.getContext("2d");e&&e.drawImage(c,0,0,c.width,c.height)}}else if("img"===s&&"rr_dataURL"===e){var l=o;l.currentSrc.startsWith("data:")||(l.setAttribute("rrweb-original-src",t.attributes.src),l.src=r)}if("rr_width"===e)o.style.width=r;else if("rr_height"===e)o.style.height=r;else if("rr_mediaCurrentTime"===e)o.currentTime=t.attributes.rr_mediaCurrentTime;else if("rr_mediaState"===e)switch(r){case"played":o.play().catch((function(e){return console.warn("media playback error",e)}));break;case"paused":o.pause()}}else{var u="textarea"===s&&"value"===e,f="style"===s&&"_cssText"===e;if(f&&a&&(r=A(r,i)),u||f){for(var d=n.createTextNode(r),p=0,m=Array.from(o.childNodes);p<m.length;p++){var h=m[p];h.nodeType===o.TEXT_NODE&&o.removeChild(h)}return o.appendChild(d),"continue"}try{if(t.isSVG&&"xlink:href"===e)o.setAttributeNS("http://www.w3.org/1999/xlink",e,r);else if("onload"===e||"onclick"===e||"onmouse"===e.substring(0,7))o.setAttribute("_"+e,r);else{if("meta"===s&&"Content-Security-Policy"===t.attributes["http-equiv"]&&"content"===e)return o.setAttribute("csp-content",r),"continue";"link"===s&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===s&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")||("img"===s&&t.attributes.srcset&&t.attributes.rr_dataURL?o.setAttribute("rrweb-original-srcset",t.attributes.srcset):o.setAttribute(e,r))}}catch(e){}}};for(var l in t.attributes)c(l);if(t.isShadowHost)if(o.shadowRoot)for(;o.shadowRoot.firstChild;)o.shadowRoot.removeChild(o.shadowRoot.firstChild);else o.attachShadow({mode:"open"});return o;case e.NodeType.Text:return n.createTextNode(t.isStyle&&a?A(t.textContent,i):t.textContent);case e.NodeType.CDATA:return n.createCDATASection(t.textContent);case e.NodeType.Comment:return n.createComment(t.textContent);default:return null}}function M(t,n){var a=n.doc,i=n.map,o=n.skipChild,s=void 0!==o&&o,c=n.hackCss,l=void 0===c||c,u=n.afterAppend,f=n.cache,d=R(t,{doc:a,hackCss:l,cache:f});if(!d)return null;if(t.rootId&&console.assert(i[t.rootId]===a,"Target document should has the same root id."),t.type===e.NodeType.Document&&(a.close(),a.open(),"BackCompat"===t.compatMode&&t.childNodes&&t.childNodes[0].type!==e.NodeType.DocumentType&&(t.childNodes[0].type===e.NodeType.Element&&"xmlns"in t.childNodes[0].attributes&&"http://www.w3.org/1999/xhtml"===t.childNodes[0].attributes.xmlns?a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "">'):a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "">')),d=a),d.__sn=t,i[t.id]=d,(t.type===e.NodeType.Document||t.type===e.NodeType.Element)&&!s)for(var p=0,m=t.childNodes;p<m.length;p++){var h=m[p],v=M(h,{doc:a,map:i,skipChild:!1,hackCss:l,afterAppend:u,cache:f});v?(h.isShadow&&r(d)&&d.shadowRoot?d.shadowRoot.appendChild(v):d.appendChild(v),u&&u(v)):console.warn("Failed to rebuild",h)}return d}return e.IGNORED_NODE=-2,e.addHoverClass=A,e.buildNodeWithSN=M,e.cleanupSnapshot=function(){l=1},e.createCache=function(){return{stylesWithHoverClass:new Map}},e.is2DCanvasBlank=o,e.isElement=r,e.isShadowRoot=n,e.maskInputValue=a,e.needMaskingText=C,e.rebuild=function(t,r){var n=r.doc,a=r.onVisit,i=r.hackCss,o={},s=M(t,{doc:n,map:o,skipChild:!1,hackCss:void 0===i||i,afterAppend:r.afterAppend,cache:r.cache});return function(e,t){for(var r in e)e[r]&&(n=e[r],t(n));var n}(o,(function(t){a&&a(t),function(t){var r=t.__sn;if(r.type===e.NodeType.Element){var n=t;for(var a in r.attributes)if(r.attributes.hasOwnProperty(a)&&a.startsWith("rr_")){var i=r.attributes[a];"rr_scrollLeft"===a&&(n.scrollLeft=i),"rr_scrollTop"===a&&(n.scrollTop=i)}}}(t)})),[s,o]},e.serializeNodeWithId=S,e.snapshot=function(e,t){var r=t||{},n=r.blockClass,a=void 0===n?"rr-block":n,i=r.blockSelector,o=void 0===i?null:i,s=r.maskTextClass,c=void 0===s?"rr-mask":s,l=r.maskTextSelector,u=void 0===l?null:l,f=r.inlineStylesheet,d=void 0===f||f,p=r.inlineImages,m=void 0!==p&&p,h=r.recordCanvas,v=void 0!==h&&h,y=r.maskAllInputs,g=void 0!==y&&y,T=r.maskTextFn,b=r.maskInputFn,k=r.slimDOM,C=void 0!==k&&k,N=r.dataURLOptions,w=r.preserveWhiteSpace,x=r.onSerialize,E=r.onIframeLoad,_=r.iframeLoadTimeout,I=r.keepIframeSrcFn,D={};return[S(e,{doc:e,map:D,blockClass:a,blockSelector:o,maskTextClass:c,maskTextSelector:u,skipChild:!1,inlineStylesheet:d,maskInputOptions:!0===g?{color:!0,date:!0,"datetime-local":!0,email:!0,month:!0,number:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0,textarea:!0,select:!0,password:!0}:!1===g?{password:!0}:g,maskTextFn:T,maskInputFn:b,slimDOMOptions:!0===C||"all"===C?{script:!0,comment:!0,headFavicon:!0,headWhitespace:!0,headMetaDescKeywords:"all"===C,headMetaSocial:!0,headMetaRobots:!0,headMetaHttpEquiv:!0,headMetaAuthorship:!0,headMetaVerification:!0}:!1===C?{}:C,dataURLOptions:N,inlineImages:m,recordCanvas:v,preserveWhiteSpace:w,onSerialize:x,onIframeLoad:E,iframeLoadTimeout:_,keepIframeSrcFn:void 0===I?function(){return!1}:I}),D]},e.transformAttribute=k,e.visitSnapshot=function(t,r){!function t(n){r(n),n.type!==e.NodeType.Document&&n.type!==e.NodeType.Element||n.childNodes.forEach(t)}(t)},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
+var rrwebSnapshot=function(e){"use strict";var t;function r(e){return e.nodeType===e.ELEMENT_NODE}function n(e){var t,r=null===(t=e)||void 0===t?void 0:t.host;return Boolean(r&&r.shadowRoot&&r.shadowRoot===e)}function a(e){var t=e.input,r=e.maskInputSelector,n=e.unmaskInputSelector,a=e.maskInputOptions,o=e.tagName,i=e.type,s=e.value,c=e.maskInputFn,l=s||"";return n&&t.matches(n)||(a[o.toLowerCase()]||a[i]||r&&t.matches(r))&&(l=c?c(l):"*".repeat(l.length)),l}e.NodeType=void 0,(t=e.NodeType||(e.NodeType={}))[t.Document=0]="Document",t[t.DocumentType=1]="DocumentType",t[t.Element=2]="Element",t[t.Text=3]="Text",t[t.CDATA=4]="CDATA",t[t.Comment=5]="Comment";var o="__rrweb_original__";function i(e){var t=e.getContext("2d");if(!t)return!0;for(var r=0;r<e.width;r+=50)for(var n=0;n<e.height;n+=50){var a=t.getImageData,i=o in a?a.__rrweb_original__:a;if(new Uint32Array(i.call(t,r,n,Math.min(50,e.width-r),Math.min(50,e.height-n)).data.buffer).some((function(e){return 0!==e})))return!1}return!0}var s,c,l=1,u=new RegExp("[^a-z0-9-_:]");function p(e){try{var t=e.rules||e.cssRules;return t?Array.from(t).map(f).join(""):null}catch(e){return null}}function f(e){var t=e.cssText;if(function(e){return"styleSheet"in e}(e))try{t=p(e.styleSheet)||t}catch(e){}return t}var m=/url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,d=/^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/,h=/^(data:)([^,]*),(.*)/i;function v(e,t){return(e||"").replace(m,(function(e,r,n,a,o,i){var s,c=n||o||i,l=r||a||"";if(!c)return e;if(!d.test(c))return"url("+l+c+l+")";if(h.test(c))return"url("+l+c+l+")";if("/"===c[0])return"url("+l+(((s=t).indexOf("//")>-1?s.split("/").slice(0,3).join("/"):s.split("/")[0]).split("?")[0]+c)+l+")";var u=t.split("/"),p=c.split("/");u.pop();for(var f=0,m=p;f<m.length;f++){var v=m[f];"."!==v&&(".."===v?u.pop():u.push(v))}return"url("+l+u.join("/")+l+")"}))}var y=/^[^ \t\n\r\u000c]+/,g=/^[, \t\n\r\u000c]+/;function k(e,t){if(!t||""===t.trim())return t;var r=e.createElement("a");return r.href=t,r.href}function T(){var e=document.createElement("a");return e.href="",e.href}function b(e,t,r,n){return"src"===r||"href"===r&&n||"xlink:href"===r&&n&&"#"!==n[0]?k(e,n):"background"!==r||!n||"table"!==t&&"td"!==t&&"th"!==t?"srcset"===r&&n?function(e,t){if(""===t.trim())return t;var r=0;function n(e){var n,a=e.exec(t.substring(r));return a?(n=a[0],r+=n.length,n):""}for(var a=[];n(g),!(r>=t.length);){var o=n(y);if(","===o.slice(-1))o=k(e,o.substring(0,o.length-1)),a.push(o);else{var i="";o=k(e,o);for(var s=!1;;){var c=t.charAt(r);if(""===c){a.push((o+i).trim());break}if(s)")"===c&&(s=!1);else{if(","===c){r+=1,a.push((o+i).trim());break}"("===c&&(s=!0)}i+=c,r+=1}}}return a.join(", ")}(e,n):"style"===r&&n?v(n,T()):"object"===t&&"data"===r&&n?k(e,n):n:k(e,n)}function S(e,t,r,n){if(!e)return!1;if(e.nodeType===e.ELEMENT_NODE){if(n&&(e.matches(n)||e.closest(n)))return!1;if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var a=0;a<e.classList.length;a++){var o=e.classList[a];if(t.test(o))return!0}return!(!r||!e.matches(r))||S(e.parentNode,t,r,n)}return e.nodeType,e.TEXT_NODE,S(e.parentNode,t,r,n)}function C(t,r){var n,o,l,f,m=r.doc,d=r.blockClass,h=r.blockSelector,y=r.unblockSelector,g=r.maskTextClass,k=r.maskTextSelector,C=r.unmaskTextSelector,N=r.inlineStylesheet,w=r.maskInputSelector,x=r.unmaskInputSelector,I=r.maskInputOptions,E=void 0===I?{}:I,_=r.maskTextFn,D=r.maskInputFn,L=r.dataURLOptions,O=void 0===L?{}:L,A=r.inlineImages,R=r.recordCanvas,M=r.keepIframeSrcFn;if(m.__sn){var F=m.__sn.id;o=1===F?void 0:F}switch(t.nodeType){case t.DOCUMENT_NODE:return"CSS1Compat"!==t.compatMode?{type:e.NodeType.Document,childNodes:[],compatMode:t.compatMode,rootId:o}:{type:e.NodeType.Document,childNodes:[],rootId:o};case t.DOCUMENT_TYPE_NODE:return{type:e.NodeType.DocumentType,name:t.name,publicId:t.publicId,systemId:t.systemId,rootId:o};case t.ELEMENT_NODE:for(var U=function(e,t,r,n){if(n&&e.matches(n))return!1;if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var a=0;a<e.classList.length;a++){var o=e.classList[a];if(t.test(o))return!0}return!!r&&e.matches(r)}(t,d,h,y),W=function(e){if(e instanceof HTMLFormElement)return"form";var t=e.tagName.toLowerCase().trim();return u.test(t)?"div":t}(t),j={},P=0,B=Array.from(t.attributes);P<B.length;P++){var H=B[P],G=H.name,z=H.value;j[G]=b(m,W,G,z)}if("link"===W&&N){var q=Array.from(m.styleSheets).find((function(e){return e.href===t.href})),V=null;q&&(V=p(q)),V&&(delete j.rel,delete j.href,j._cssText=v(V,q.href))}if("style"===W&&t.sheet&&!(t.innerText||t.textContent||"").trim().length)(V=p(t.sheet))&&(j._cssText=v(V,T()));if("input"===W||"textarea"===W||"select"===W){z=t.value;"radio"!==j.type&&"checkbox"!==j.type&&"submit"!==j.type&&"button"!==j.type&&z?j.value=a({input:t,type:j.type,tagName:W,value:z,maskInputSelector:w,unmaskInputSelector:x,maskInputOptions:E,maskInputFn:D}):t.checked&&(j.checked=t.checked)}if("option"===W&&(t.selected&&!E.select?j.selected=!0:delete j.selected),"canvas"===W&&R)if("2d"===t.__context)i(t)||(j.rr_dataURL=t.toDataURL(O.type,O.quality));else if(!("__context"in t)){var $=t.toDataURL(O.type,O.quality),X=document.createElement("canvas");X.width=t.width,X.height=t.height,$!==X.toDataURL(O.type,O.quality)&&(j.rr_dataURL=$)}if("img"===W&&A){s||(s=m.createElement("canvas"),c=s.getContext("2d"));var Y=t,K=Y.crossOrigin;Y.crossOrigin="anonymous";var Z=function(){try{s.width=Y.naturalWidth,s.height=Y.naturalHeight,c.drawImage(Y,0,0),j.rr_dataURL=s.toDataURL(O.type,O.quality)}catch(e){console.warn("Cannot inline img src="+Y.currentSrc+"! Error: "+e)}K?j.crossOrigin=K:delete j.crossOrigin};Y.complete&&0!==Y.naturalWidth?Z():Y.onload=Z}if("audio"!==W&&"video"!==W||(j.rr_mediaState=t.paused?"paused":"played",j.rr_mediaCurrentTime=t.currentTime),t.scrollLeft&&(j.rr_scrollLeft=t.scrollLeft),t.scrollTop&&(j.rr_scrollTop=t.scrollTop),U){var J=t.getBoundingClientRect(),Q=J.width,ee=J.height;j={class:j.class,rr_width:Q+"px",rr_height:ee+"px"}}return"iframe"!==W||M(j.src)||(t.contentDocument||(j.rr_src=j.src),delete j.src),{type:e.NodeType.Element,tagName:W,attributes:j,childNodes:[],isSVG:(f=t,Boolean("svg"===f.tagName||f.ownerSVGElement)||void 0),needBlock:U,rootId:o};case t.TEXT_NODE:var te=t.parentNode&&t.parentNode.tagName,re=t.textContent,ne="STYLE"===te||void 0,ae="SCRIPT"===te||void 0;if(ne&&re){try{t.nextSibling||t.previousSibling||(null===(n=t.parentNode.sheet)||void 0===n?void 0:n.cssRules)&&(re=(l=t.parentNode.sheet).cssRules?Array.from(l.cssRules).map((function(e){return e.cssText||""})).join(""):"")}catch(e){console.warn("Cannot get CSS styles from text's parentNode. Error: "+e,t)}re=v(re,T())}return ae&&(re="SCRIPT_PLACEHOLDER"),!ne&&!ae&&S(t,g,k,C)&&re&&(re=_?_(re):re.replace(/[\S]/g,"*")),{type:e.NodeType.Text,textContent:re||"",isStyle:ne,rootId:o};case t.CDATA_SECTION_NODE:return{type:e.NodeType.CDATA,textContent:"",rootId:o};case t.COMMENT_NODE:return{type:e.NodeType.Comment,textContent:t.textContent||"",rootId:o};default:return!1}}function N(e){return void 0===e?"":e.toLowerCase()}function w(t,a){var o,i=a.doc,s=a.map,c=a.blockClass,u=a.blockSelector,p=a.unblockSelector,f=a.maskTextClass,m=a.maskTextSelector,d=a.unmaskTextSelector,h=a.skipChild,v=void 0!==h&&h,y=a.inlineStylesheet,g=void 0===y||y,k=a.maskInputSelector,T=a.unmaskInputSelector,b=a.maskInputOptions,S=void 0===b?{}:b,x=a.maskTextFn,I=a.maskInputFn,E=a.slimDOMOptions,_=a.dataURLOptions,D=void 0===_?{}:_,L=a.inlineImages,O=void 0!==L&&L,A=a.recordCanvas,R=void 0!==A&&A,M=a.onSerialize,F=a.onIframeLoad,U=a.iframeLoadTimeout,W=void 0===U?5e3:U,j=a.keepIframeSrcFn,P=void 0===j?function(){return!1}:j,B=a.preserveWhiteSpace,H=void 0===B||B,G=C(t,{doc:i,blockClass:c,blockSelector:u,unblockSelector:p,maskTextClass:f,maskTextSelector:m,unmaskTextSelector:d,inlineStylesheet:g,maskInputSelector:k,unmaskInputSelector:T,maskInputOptions:S,maskTextFn:x,maskInputFn:I,dataURLOptions:D,inlineImages:O,recordCanvas:R,keepIframeSrcFn:P});if(!G)return console.warn(t,"not serialized"),null;o="__sn"in t?t.__sn.id:!function(t,r){if(r.comment&&t.type===e.NodeType.Comment)return!0;if(t.type===e.NodeType.Element){if(r.script&&("script"===t.tagName||"link"===t.tagName&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===t.tagName&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")))return!0;if(r.headFavicon&&("link"===t.tagName&&"shortcut icon"===t.attributes.rel||"meta"===t.tagName&&(N(t.attributes.name).match(/^msapplication-tile(image|color)$/)||"application-name"===N(t.attributes.name)||"icon"===N(t.attributes.rel)||"apple-touch-icon"===N(t.attributes.rel)||"shortcut icon"===N(t.attributes.rel))))return!0;if("meta"===t.tagName){if(r.headMetaDescKeywords&&N(t.attributes.name).match(/^description|keywords$/))return!0;if(r.headMetaSocial&&(N(t.attributes.property).match(/^(og|twitter|fb):/)||N(t.attributes.name).match(/^(og|twitter):/)||"pinterest"===N(t.attributes.name)))return!0;if(r.headMetaRobots&&("robots"===N(t.attributes.name)||"googlebot"===N(t.attributes.name)||"bingbot"===N(t.attributes.name)))return!0;if(r.headMetaHttpEquiv&&void 0!==t.attributes["http-equiv"])return!0;if(r.headMetaAuthorship&&("author"===N(t.attributes.name)||"generator"===N(t.attributes.name)||"framework"===N(t.attributes.name)||"publisher"===N(t.attributes.name)||"progid"===N(t.attributes.name)||N(t.attributes.property).match(/^article:/)||N(t.attributes.property).match(/^product:/)))return!0;if(r.headMetaVerification&&("google-site-verification"===N(t.attributes.name)||"yandex-verification"===N(t.attributes.name)||"csrf-token"===N(t.attributes.name)||"p:domain_verify"===N(t.attributes.name)||"verify-v1"===N(t.attributes.name)||"verification"===N(t.attributes.name)||"shopify-checkout-api-token"===N(t.attributes.name)))return!0}}return!1}(G,E)&&(H||G.type!==e.NodeType.Text||G.isStyle||G.textContent.replace(/^\s+|\s+$/gm,"").length)?l++:-2;var z=Object.assign(G,{id:o});if(t.__sn=z,-2===o)return null;s[o]=t,M&&M(t);var q=!v;if(z.type===e.NodeType.Element&&(q=q&&!z.needBlock,delete z.needBlock,t.shadowRoot&&(z.isShadowHost=!0)),(z.type===e.NodeType.Document||z.type===e.NodeType.Element)&&q){E.headWhitespace&&G.type===e.NodeType.Element&&"head"===G.tagName&&(H=!1);for(var V={doc:i,map:s,blockClass:c,blockSelector:u,unblockSelector:p,maskTextClass:f,maskTextSelector:m,unmaskTextSelector:d,skipChild:v,inlineStylesheet:g,maskInputSelector:k,unmaskInputSelector:T,maskInputOptions:S,maskTextFn:x,maskInputFn:I,slimDOMOptions:E,dataURLOptions:D,inlineImages:O,recordCanvas:R,preserveWhiteSpace:H,onSerialize:M,onIframeLoad:F,iframeLoadTimeout:W,keepIframeSrcFn:P},$=0,X=Array.from(t.childNodes);$<X.length;$++){(Z=w(X[$],V))&&z.childNodes.push(Z)}if(r(t)&&t.shadowRoot)for(var Y=0,K=Array.from(t.shadowRoot.childNodes);Y<K.length;Y++){var Z;(Z=w(K[Y],V))&&(Z.isShadow=!0,z.childNodes.push(Z))}}return t.parentNode&&n(t.parentNode)&&(z.isShadow=!0),z.type===e.NodeType.Element&&"iframe"===z.tagName&&function(e,t,r){var n=e.contentWindow;if(n){var a,o=!1;try{a=n.document.readyState}catch(e){return}if("complete"===a){var i="about:blank";n.location.href===i&&e.src!==i&&""!==e.src?e.addEventListener("load",t):setTimeout(t,0)}else{var s=setTimeout((function(){o||(t(),o=!0)}),r);e.addEventListener("load",(function(){clearTimeout(s),o=!0,t()}))}}}(t,(function(){var e=t.contentDocument;if(e&&F){var r=w(e,{doc:e,map:s,blockClass:c,blockSelector:u,unblockSelector:p,maskTextClass:f,maskTextSelector:m,unmaskTextSelector:d,skipChild:!1,inlineStylesheet:g,maskInputSelector:k,unmaskInputSelector:T,maskInputOptions:S,maskTextFn:x,maskInputFn:I,slimDOMOptions:E,dataURLOptions:D,inlineImages:O,recordCanvas:R,preserveWhiteSpace:H,onSerialize:M,onIframeLoad:F,iframeLoadTimeout:W,keepIframeSrcFn:P});r&&F(t,r)}}),W),z}var x=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;function I(e,t){void 0===t&&(t={});var r=1,n=1;function a(e){var t=e.match(/\n/g);t&&(r+=t.length);var a=e.lastIndexOf("\n");n=-1===a?n+e.length:e.length-a}function o(){var e={line:r,column:n};return function(t){return t.position=new i(e),m(),t}}var i=function(e){this.start=e,this.end={line:r,column:n},this.source=t.source};i.prototype.content=e;var s=[];function c(a){var o=new Error(t.source+":"+r+":"+n+": "+a);if(o.reason=a,o.filename=t.source,o.line=r,o.column=n,o.source=e,!t.silent)throw o;s.push(o)}function l(){return f(/^{\s*/)}function u(){return f(/^}/)}function p(){var t,r=[];for(m(),d(r);e.length&&"}"!==e.charAt(0)&&(t=w()||I());)!1!==t&&(r.push(t),d(r));return r}function f(t){var r=t.exec(e);if(r){var n=r[0];return a(n),e=e.slice(n.length),r}}function m(){f(/^\s*/)}function d(e){var t;for(void 0===e&&(e=[]);t=h();)!1!==t&&e.push(t),t=h();return e}function h(){var t=o();if("/"===e.charAt(0)&&"*"===e.charAt(1)){for(var r=2;""!==e.charAt(r)&&("*"!==e.charAt(r)||"/"!==e.charAt(r+1));)++r;if(r+=2,""===e.charAt(r-1))return c("End of comment missing");var i=e.slice(2,r-2);return n+=2,a(i),e=e.slice(r),n+=2,t({type:"comment",comment:i})}}function v(){var e=f(/^([^{]+)/);if(e)return E(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g,"").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g,(function(e){return e.replace(/,/g,"‌")})).split(/\s*(?![^(]*\)),\s*/).map((function(e){return e.replace(/\u200C/g,",")}))}function y(){var e=o(),t=f(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);if(t){var r=E(t[0]);if(!f(/^:\s*/))return c("property missing ':'");var n=f(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/),a=e({type:"declaration",property:r.replace(x,""),value:n?E(n[0]).replace(x,""):""});return f(/^[;\s]*/),a}}function g(){var e,t=[];if(!l())return c("missing '{'");for(d(t);e=y();)!1!==e&&(t.push(e),d(t)),e=y();return u()?t:c("missing '}'")}function k(){for(var e,t=[],r=o();e=f(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/);)t.push(e[1]),f(/^,\s*/);if(t.length)return r({type:"keyframe",values:t,declarations:g()})}var T,b=N("import"),S=N("charset"),C=N("namespace");function N(e){var t=new RegExp("^@"+e+"\\s*([^;]+);");return function(){var r=o(),n=f(t);if(n){var a={type:e};return a[e]=n[1].trim(),r(a)}}}function w(){if("@"===e[0])return function(){var e=o(),t=f(/^@([-\w]+)?keyframes\s*/);if(t){var r=t[1];if(!(t=f(/^([-\w]+)\s*/)))return c("@keyframes missing name");var n,a=t[1];if(!l())return c("@keyframes missing '{'");for(var i=d();n=k();)i.push(n),i=i.concat(d());return u()?e({type:"keyframes",name:a,vendor:r,keyframes:i}):c("@keyframes missing '}'")}}()||function(){var e=o(),t=f(/^@media *([^{]+)/);if(t){var r=E(t[1]);if(!l())return c("@media missing '{'");var n=d().concat(p());return u()?e({type:"media",media:r,rules:n}):c("@media missing '}'")}}()||function(){var e=o(),t=f(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);if(t)return e({type:"custom-media",name:E(t[1]),media:E(t[2])})}()||function(){var e=o(),t=f(/^@supports *([^{]+)/);if(t){var r=E(t[1]);if(!l())return c("@supports missing '{'");var n=d().concat(p());return u()?e({type:"supports",supports:r,rules:n}):c("@supports missing '}'")}}()||b()||S()||C()||function(){var e=o(),t=f(/^@([-\w]+)?document *([^{]+)/);if(t){var r=E(t[1]),n=E(t[2]);if(!l())return c("@document missing '{'");var a=d().concat(p());return u()?e({type:"document",document:n,vendor:r,rules:a}):c("@document missing '}'")}}()||function(){var e=o();if(f(/^@page */)){var t=v()||[];if(!l())return c("@page missing '{'");for(var r,n=d();r=y();)n.push(r),n=n.concat(d());return u()?e({type:"page",selectors:t,declarations:n}):c("@page missing '}'")}}()||function(){var e=o();if(f(/^@host\s*/)){if(!l())return c("@host missing '{'");var t=d().concat(p());return u()?e({type:"host",rules:t}):c("@host missing '}'")}}()||function(){var e=o();if(f(/^@font-face\s*/)){if(!l())return c("@font-face missing '{'");for(var t,r=d();t=y();)r.push(t),r=r.concat(d());return u()?e({type:"font-face",declarations:r}):c("@font-face missing '}'")}}()}function I(){var e=o(),t=v();return t?(d(),e({type:"rule",selectors:t,declarations:g()})):c("selector missing")}return _((T=p(),{type:"stylesheet",stylesheet:{source:t.source,rules:T,parsingErrors:s}}))}function E(e){return e?e.replace(/^\s+|\s+$/g,""):""}function _(e,t){for(var r=e&&"string"==typeof e.type,n=r?e:t,a=0,o=Object.keys(e);a<o.length;a++){var i=e[o[a]];Array.isArray(i)?i.forEach((function(e){_(e,n)})):i&&"object"==typeof i&&_(i,n)}return r&&Object.defineProperty(e,"parent",{configurable:!0,writable:!0,enumerable:!1,value:t||null}),e}var D={script:"noscript",altglyph:"altGlyph",altglyphdef:"altGlyphDef",altglyphitem:"altGlyphItem",animatecolor:"animateColor",animatemotion:"animateMotion",animatetransform:"animateTransform",clippath:"clipPath",feblend:"feBlend",fecolormatrix:"feColorMatrix",fecomponenttransfer:"feComponentTransfer",fecomposite:"feComposite",feconvolvematrix:"feConvolveMatrix",fediffuselighting:"feDiffuseLighting",fedisplacementmap:"feDisplacementMap",fedistantlight:"feDistantLight",fedropshadow:"feDropShadow",feflood:"feFlood",fefunca:"feFuncA",fefuncb:"feFuncB",fefuncg:"feFuncG",fefuncr:"feFuncR",fegaussianblur:"feGaussianBlur",feimage:"feImage",femerge:"feMerge",femergenode:"feMergeNode",femorphology:"feMorphology",feoffset:"feOffset",fepointlight:"fePointLight",fespecularlighting:"feSpecularLighting",fespotlight:"feSpotLight",fetile:"feTile",feturbulence:"feTurbulence",foreignobject:"foreignObject",glyphref:"glyphRef",lineargradient:"linearGradient",radialgradient:"radialGradient"};var L=/([^\\]):hover/,O=new RegExp(L.source,"g");function A(e,t){var r=null==t?void 0:t.stylesWithHoverClass.get(e);if(r)return r;var n=I(e,{silent:!0});if(!n.stylesheet)return e;var a=[];if(n.stylesheet.rules.forEach((function(e){"selectors"in e&&(e.selectors||[]).forEach((function(e){L.test(e)&&a.push(e)}))})),0===a.length)return e;var o=new RegExp(a.filter((function(e,t){return a.indexOf(e)===t})).sort((function(e,t){return t.length-e.length})).map((function(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")})).join("|"),"g"),i=e.replace(o,(function(e){var t=e.replace(O,"$1.\\:hover");return e+", "+t}));return null==t||t.stylesWithHoverClass.set(e,i),i}function R(t,r){var n=r.doc,a=r.hackCss,o=r.cache;switch(t.type){case e.NodeType.Document:return n.implementation.createDocument(null,"",null);case e.NodeType.DocumentType:return n.implementation.createDocumentType(t.name||"html",t.publicId,t.systemId);case e.NodeType.Element:var i,s=function(e){var t=D[e.tagName]?D[e.tagName]:e.tagName;return"link"===t&&e.attributes._cssText&&(t="style"),t}(t);i=t.isSVG?n.createElementNS("http://www.w3.org/2000/svg",s):n.createElement(s);var c=function(e){if(!t.attributes.hasOwnProperty(e))return"continue";var r=t.attributes[e];if("option"===s&&"selected"===e&&!1===r)return"continue";if(r="boolean"==typeof r||"number"==typeof r?"":r,e.startsWith("rr_")){if("canvas"===s&&"rr_dataURL"===e){var c=document.createElement("img");c.src=r,c.onload=function(){var e=i.getContext("2d");e&&e.drawImage(c,0,0,c.width,c.height)}}else if("img"===s&&"rr_dataURL"===e){var l=i;l.currentSrc.startsWith("data:")||(l.setAttribute("rrweb-original-src",t.attributes.src),l.src=r)}if("rr_width"===e)i.style.width=r;else if("rr_height"===e)i.style.height=r;else if("rr_mediaCurrentTime"===e)i.currentTime=t.attributes.rr_mediaCurrentTime;else if("rr_mediaState"===e)switch(r){case"played":i.play().catch((function(e){return console.warn("media playback error",e)}));break;case"paused":i.pause()}}else{var u="textarea"===s&&"value"===e,p="style"===s&&"_cssText"===e;if(p&&a&&(r=A(r,o)),u||p){for(var f=n.createTextNode(r),m=0,d=Array.from(i.childNodes);m<d.length;m++){var h=d[m];h.nodeType===i.TEXT_NODE&&i.removeChild(h)}return i.appendChild(f),"continue"}try{if(t.isSVG&&"xlink:href"===e)i.setAttributeNS("http://www.w3.org/1999/xlink",e,r);else if("onload"===e||"onclick"===e||"onmouse"===e.substring(0,7))i.setAttribute("_"+e,r);else{if("meta"===s&&"Content-Security-Policy"===t.attributes["http-equiv"]&&"content"===e)return i.setAttribute("csp-content",r),"continue";"link"===s&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===s&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")||("img"===s&&t.attributes.srcset&&t.attributes.rr_dataURL?i.setAttribute("rrweb-original-srcset",t.attributes.srcset):i.setAttribute(e,r))}}catch(e){}}};for(var l in t.attributes)c(l);if(t.isShadowHost)if(i.shadowRoot)for(;i.shadowRoot.firstChild;)i.shadowRoot.removeChild(i.shadowRoot.firstChild);else i.attachShadow({mode:"open"});return i;case e.NodeType.Text:return n.createTextNode(t.isStyle&&a?A(t.textContent,o):t.textContent);case e.NodeType.CDATA:return n.createCDATASection(t.textContent);case e.NodeType.Comment:return n.createComment(t.textContent);default:return null}}function M(t,n){var a=n.doc,o=n.map,i=n.skipChild,s=void 0!==i&&i,c=n.hackCss,l=void 0===c||c,u=n.afterAppend,p=n.cache,f=R(t,{doc:a,hackCss:l,cache:p});if(!f)return null;if(t.rootId&&console.assert(o[t.rootId]===a,"Target document should has the same root id."),t.type===e.NodeType.Document&&(a.close(),a.open(),"BackCompat"===t.compatMode&&t.childNodes&&t.childNodes[0].type!==e.NodeType.DocumentType&&(t.childNodes[0].type===e.NodeType.Element&&"xmlns"in t.childNodes[0].attributes&&"http://www.w3.org/1999/xhtml"===t.childNodes[0].attributes.xmlns?a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "">'):a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "">')),f=a),f.__sn=t,o[t.id]=f,(t.type===e.NodeType.Document||t.type===e.NodeType.Element)&&!s)for(var m=0,d=t.childNodes;m<d.length;m++){var h=d[m],v=M(h,{doc:a,map:o,skipChild:!1,hackCss:l,afterAppend:u,cache:p});v?(h.isShadow&&r(f)&&f.shadowRoot?f.shadowRoot.appendChild(v):f.appendChild(v),u&&u(v)):console.warn("Failed to rebuild",h)}return f}return e.IGNORED_NODE=-2,e.addHoverClass=A,e.buildNodeWithSN=M,e.cleanupSnapshot=function(){l=1},e.createCache=function(){return{stylesWithHoverClass:new Map}},e.is2DCanvasBlank=i,e.isElement=r,e.isShadowRoot=n,e.maskInputValue=a,e.needMaskingText=S,e.rebuild=function(t,r){var n=r.doc,a=r.onVisit,o=r.hackCss,i={},s=M(t,{doc:n,map:i,skipChild:!1,hackCss:void 0===o||o,afterAppend:r.afterAppend,cache:r.cache});return function(e,t){for(var r in e)e[r]&&(n=e[r],t(n));var n}(i,(function(t){a&&a(t),function(t){var r=t.__sn;if(r.type===e.NodeType.Element){var n=t;for(var a in r.attributes)if(r.attributes.hasOwnProperty(a)&&a.startsWith("rr_")){var o=r.attributes[a];"rr_scrollLeft"===a&&(n.scrollLeft=o),"rr_scrollTop"===a&&(n.scrollTop=o)}}}(t)})),[s,i]},e.serializeNodeWithId=w,e.snapshot=function(e,t){var r=t||{},n=r.blockClass,a=void 0===n?"rr-block":n,o=r.blockSelector,i=void 0===o?null:o,s=r.unblockSelector,c=void 0===s?null:s,l=r.maskTextClass,u=void 0===l?"rr-mask":l,p=r.maskTextSelector,f=void 0===p?null:p,m=r.unmaskTextSelector,d=void 0===m?null:m,h=r.inlineStylesheet,v=void 0===h||h,y=r.inlineImages,g=void 0!==y&&y,k=r.recordCanvas,T=void 0!==k&&k,b=r.maskInputSelector,S=void 0===b?null:b,C=r.unmaskInputSelector,N=void 0===C?null:C,x=r.maskAllInputs,I=void 0!==x&&x,E=r.maskTextFn,_=r.maskInputFn,D=r.slimDOM,L=void 0!==D&&D,O=r.dataURLOptions,A=r.preserveWhiteSpace,R=r.onSerialize,M=r.onIframeLoad,F=r.iframeLoadTimeout,U=r.keepIframeSrcFn,W={};return[w(e,{doc:e,map:W,blockClass:a,blockSelector:i,unblockSelector:c,maskTextClass:u,maskTextSelector:f,unmaskTextSelector:d,skipChild:!1,inlineStylesheet:v,maskInputSelector:S,unmaskInputSelector:N,maskInputOptions:!0===I?{color:!0,date:!0,"datetime-local":!0,email:!0,month:!0,number:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0,textarea:!0,select:!0,password:!0}:!1===I?{password:!0}:I,maskTextFn:E,maskInputFn:_,slimDOMOptions:!0===L||"all"===L?{script:!0,comment:!0,headFavicon:!0,headWhitespace:!0,headMetaDescKeywords:"all"===L,headMetaSocial:!0,headMetaRobots:!0,headMetaHttpEquiv:!0,headMetaAuthorship:!0,headMetaVerification:!0}:!1===L?{}:L,dataURLOptions:O,inlineImages:g,recordCanvas:T,preserveWhiteSpace:A,onSerialize:R,onIframeLoad:M,iframeLoadTimeout:F,keepIframeSrcFn:void 0===U?function(){return!1}:U}),W]},e.transformAttribute=b,e.visitSnapshot=function(t,r){!function t(n){r(n),n.type!==e.NodeType.Document&&n.type!==e.NodeType.Element||n.childNodes.forEach(t)}(t)},Object.defineProperty(e,"__esModule",{value:!0}),e}({});
 //# sourceMappingURL=rrweb-snapshot.min.js.map
diff --git a/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js.map b/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js.map
old mode 100644
new mode 100755
index 6ba05f3..62e117d
--- a/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js.map
+++ b/node_modules/rrweb-snapshot/dist/rrweb-snapshot.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/utils.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n  compatMode?: string;\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport interface ICanvas extends HTMLCanvasElement {\n  __context: string;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type DataURLOptions = Partial<{\n  type: string;\n  quality: number;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\nexport type MaskInputFn = (text: string) => string;\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\nexport type BuildCache = {\n  stylesWithHoverClass: Map<string, string>;\n};\n","import { INode, MaskInputFn, MaskInputOptions } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n\nexport function maskInputValue({\n  maskInputOptions,\n  tagName,\n  type,\n  value,\n  maskInputFn,\n}: {\n  maskInputOptions: MaskInputOptions;\n  tagName: string;\n  type: string | number | boolean | null;\n  value: string | null;\n  maskInputFn?: MaskInputFn;\n}): string {\n  let text = value || '';\n  if (\n    maskInputOptions[tagName.toLowerCase() as keyof MaskInputOptions] ||\n    maskInputOptions[type as keyof MaskInputOptions]\n  ) {\n    if (maskInputFn) {\n      text = maskInputFn(text);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n  return text;\n}\n\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\ntype PatchedGetImageData = {\n  [ORIGINAL_ATTRIBUTE_NAME]: CanvasImageData['getImageData'];\n} & CanvasImageData['getImageData'];\n\nexport function is2DCanvasBlank(canvas: HTMLCanvasElement): boolean {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n\n  const chunkSize = 50;\n\n  // get chunks of the canvas and check if it is blank\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData as PatchedGetImageData;\n      const originalGetImageData =\n        ORIGINAL_ATTRIBUTE_NAME in getImageData\n          ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\n          : getImageData;\n      // by getting the canvas in chunks we avoid an expensive\n      // `getImageData` call that retrieves everything\n      // even if we can already tell from the first chunk(s) that\n      // the canvas isn't blank\n      const pixelBuffer = new Uint32Array(\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y),\n        ).data.buffer,\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  DataURLOptions,\n  MaskTextFn,\n  MaskInputFn,\n  KeepIframeSrcFn,\n  ICanvas,\n} from './types';\nimport {\n  is2DCanvasBlank,\n  isElement,\n  isShadowRoot,\n  maskInputValue,\n} from './utils';\n\nlet _id = 1;\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  let cssStringified = rule.cssText;\n  if (isCSSImportRule(rule)) {\n    try {\n      cssStringified = getCssRulesString(rule.styleSheet) || cssStringified;\n    } catch {\n      // ignore\n    }\n  }\n  return cssStringified;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction stringifyStyleSheet(sheet: CSSStyleSheet): string {\n  return sheet.cssRules\n    ? Array.from(sheet.cssRules)\n        .map((rule) => rule.cssText || '')\n        .join('')\n    : '';\n}\n\nfunction extractOrigin(url: string): string {\n  let origin = '';\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nlet canvasService: HTMLCanvasElement | null;\nlet canvasCtx: CanvasRenderingContext2D | null;\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    let chars: string;\n    let match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return Boolean(el.tagName === 'svg' || (el as SVGElement).ownerSVGElement);\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || (name === 'href' && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value && value[0] !== '#') {\n    // xlink:href starts with # is an id pointer\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else if (tagName === 'object' && name === 'data' && value) {\n    return absoluteToDoc(doc, value);\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      // tslint:disable-next-line: prefer-for-of\n      for (\n        let eIndex = 0;\n        eIndex < (node as HTMLElement).classList.length;\n        eIndex++\n      ) {\n        const className = (node as HTMLElement).classList[eIndex];\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    // iframe was already loaded, make sure we wait to trigger the listener\n    // till _after_ the mutation that found this iframe has had time to process\n    setTimeout(listener, 0);\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if ((n as HTMLDocument).compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: (n as HTMLDocument).compatMode, // probably \"BackCompat\"\n          rootId,\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          rootId,\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        let cssText: string | null = null;\n        if (stylesheet) {\n          cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        }\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value = maskInputValue({\n            type: attributes.type,\n            tagName,\n            value,\n            maskInputOptions,\n            maskInputFn,\n          });\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        if ((n as HTMLOptionElement).selected && !maskInputOptions['select']) {\n          attributes.selected = true;\n        } else {\n          // ignore the html attribute (which corresponds to DOM (n as HTMLOptionElement).defaultSelected)\n          // if it's already been changed\n          delete attributes.selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        if ((n as ICanvas).__context === '2d') {\n          // only record this on 2d canvas\n          if (!is2DCanvasBlank(n as HTMLCanvasElement)) {\n            attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          }\n        } else if (!('__context' in n)) {\n          // context is unknown, better not call getContext to trigger it\n          const canvasDataURL = (n as HTMLCanvasElement).toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // create blank canvas of same dimensions\n          const blankCanvas = document.createElement('canvas');\n          blankCanvas.width = (n as HTMLCanvasElement).width;\n          blankCanvas.height = (n as HTMLCanvasElement).height;\n          const blankCanvasDataURL = blankCanvas.toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // no need to save dataURL if it's the same as blank canvas\n          if (canvasDataURL !== blankCanvasDataURL) {\n            attributes.rr_dataURL = canvasDataURL;\n          }\n        }\n      }\n      // save image offline\n      if (tagName === 'img' && inlineImages) {\n        if (!canvasService) {\n          canvasService = doc.createElement('canvas');\n          canvasCtx = canvasService.getContext('2d');\n        }\n        const image = n as HTMLImageElement;\n        const oldValue = image.crossOrigin;\n        image.crossOrigin = 'anonymous';\n        const recordInlineImage = () => {\n          try {\n            canvasService!.width = image.naturalWidth;\n            canvasService!.height = image.naturalHeight;\n            canvasCtx!.drawImage(image, 0, 0);\n            attributes.rr_dataURL = canvasService!.toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          } catch (err) {\n            console.warn(\n              `Cannot inline img src=${image.currentSrc}! Error: ${err}`,\n            );\n          }\n          oldValue\n            ? (attributes.crossOrigin = oldValue)\n            : delete attributes.crossOrigin;\n        };\n        // The image content may not have finished loading yet.\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.onload = recordInlineImage;\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n        attributes.rr_mediaCurrentTime = (n as HTMLMediaElement).currentTime;\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src as string)) {\n        if (!(n as HTMLIFrameElement).contentDocument) {\n          // we can't record it directly as we can't see into it\n          // preserve the src attribute so a decision can be taken at replay time\n          attributes.rr_src = attributes.src;\n        }\n        delete attributes.src; // prevent auto loading\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        try {\n          // try to read style sheet\n          if (n.nextSibling || n.previousSibling) {\n            // This is not the only child of the stylesheet.\n            // We can't read all of the sheet's .cssRules and expect them\n            // to _only_ include the current rule(s) added by the text node.\n            // So we'll be conservative and keep textContent as-is.\n          } else if ((n.parentNode as HTMLStyleElement).sheet?.cssRules) {\n            textContent = stringifyStyleSheet(\n              (n.parentNode as HTMLStyleElement).sheet!,\n            );\n          }\n        } catch (err) {\n          console.warn(\n            `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n            n,\n          );\n        }\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      // script tag\n      (sn.tagName === 'script' ||\n        // preload link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script') ||\n        // prefetch link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'prefetch' &&\n          typeof sn.attributes.href === 'string' &&\n          sn.attributes.href.endsWith('.js')))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n    if ((n as HTMLElement).shadowRoot) serializedNode.isShadowHost = true;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    maskInputFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    keepIframeSrcFn = () => false,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n\n/* tslint:disable no-conditional-assignment interface-name no-shadowed-variable */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends Node {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport interface Host extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each “selector” is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends Node {\n  /** The part following @media. */\n  media?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends Node {\n  /** The part following @supports. */\n  supports?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules {\n  source?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}) {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    let i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.prototype.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    return trim(m[0])\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      })\n      .split(/\\s*(?![^(]*\\)),\\s*/)\n      .map((s) => {\n        return s.replace(/\\u200C/g, ',');\n      });\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    let propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet) {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent((value as unknown) as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { parse } from './css';\nimport {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n  BuildCache,\n} from './types';\nimport { isElement } from './utils';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nfunction escapeRegExp(str: string) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\nexport function addHoverClass(cssText: string, cache: BuildCache): string {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n\n  const ast = parse(cssText, {\n    silent: true,\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  const selectors: string[] = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n\n  if (selectors.length === 0) {\n    return cssText;\n  }\n\n  const selectorMatcher = new RegExp(\n    selectors\n      .filter((selector, index) => selectors.indexOf(selector) === index)\n      .sort((a, b) => b.length - a.length)\n      .map((selector) => {\n        return escapeRegExp(selector);\n      })\n      .join('|'),\n    'g',\n  );\n\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nexport function createCache(): BuildCache {\n  const stylesWithHoverClass: Map<string, string> = new Map();\n  return {\n    stylesWithHoverClass,\n  };\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n    cache: BuildCache;\n  },\n): Node | null {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        if (!n.attributes.hasOwnProperty(name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (tagName === 'option' && name === 'selected' && value === false) {\n          // legacy fix (TODO: if `value === false` can be generated for other attrs, should we also omit those other attrs from build?)\n          continue;\n        }\n        value =\n          typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (!name.startsWith('rr_')) {\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss && hackCss) {\n            value = addHoverClass(value, cache);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            // https://github.com/rrweb-io/rrweb/issues/112\n            for (const c of Array.from(node.childNodes)) {\n              if (c.nodeType === node.TEXT_NODE) {\n                node.removeChild(c);\n              }\n            }\n            node.appendChild(child);\n            continue;\n          }\n\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else if (\n              name === 'onload' ||\n              name === 'onclick' ||\n              name.substring(0, 7) === 'onmouse'\n            ) {\n              // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n              // as setting them triggers a console.error (which shows up despite the try/catch)\n              // Assumption: these attributes are not used to css\n              node.setAttribute('_' + name, value);\n            } else if (\n              tagName === 'meta' &&\n              n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n              name === 'content'\n            ) {\n              // If CSP contains style-src and inline-style is disabled, there will be an error \"Refused to apply inline style because it violates the following Content Security Policy directive: style-src '*'\".\n              // And the function insertStyleRules in rrweb replayer will throw an error \"Uncaught TypeError: Cannot read property 'insertRule' of null\".\n              node.setAttribute('csp-content', value);\n              continue;\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'preload' &&\n              n.attributes.as === 'script'\n            ) {\n              // ignore\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'prefetch' &&\n              typeof n.attributes.href === 'string' &&\n              n.attributes.href.endsWith('.js')\n            ) {\n              // ignore\n            } else if (\n              tagName === 'img' &&\n              n.attributes.srcset &&\n              n.attributes.rr_dataURL\n            ) {\n              // backup original img srcset\n              node.setAttribute('rrweb-original-srcset', n.attributes.srcset as string);\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (tagName === 'canvas' && name === 'rr_dataURL') {\n            const image = document.createElement('img');\n            image.src = value;\n            image.onload = () => {\n              const ctx = (node as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n          } else if (tagName === 'img' && name === 'rr_dataURL') {\n            const image = node as HTMLImageElement;\n            if (!image.currentSrc.startsWith('data:')) {\n              // Backup original img src. It may not have been set yet.\n              image.setAttribute(\n                'rrweb-original-src',\n                n.attributes.src as string,\n              );\n              image.src = value;\n            }\n          }\n\n          if (name === 'rr_width') {\n            (node as HTMLElement).style.width = value;\n          } else if (name === 'rr_height') {\n            (node as HTMLElement).style.height = value;\n          } else if (name === 'rr_mediaCurrentTime') {\n            (node as HTMLMediaElement).currentTime = n.attributes\n              .rr_mediaCurrentTime as number;\n          } else if (name === 'rr_mediaState') {\n            switch (value) {\n              case 'played':\n                (node as HTMLMediaElement)\n                  .play()\n                  .catch((e) => console.warn('media playback error', e));\n                break;\n              case 'paused':\n                (node as HTMLMediaElement).pause();\n                break;\n              default:\n            }\n          }\n        }\n      }\n\n      if (n.isShadowHost) {\n        /**\n         * Since node is newly rebuilt, it should be a normal element\n         * without shadowRoot.\n         * But if there are some weird situations that has defined\n         * custom element in the scope before we rebuild node, it may\n         * register the shadowRoot earlier.\n         * The logic in the 'else' block is just a try-my-best solution\n         * for the corner case, please let we know if it is wrong and\n         * we can remove it.\n         */\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: 'open' });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss\n          ? addHoverClass(n.textContent, cache)\n          : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    skipChild?: boolean;\n    hackCss: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): INode | null {\n  const {\n    doc,\n    map,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache,\n  } = options;\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n.rootId) {\n    console.assert(\n      ((map[n.rootId] as unknown) as Document) === doc,\n      'Target document should has the same root id.',\n    );\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    if (\n      n.compatMode === 'BackCompat' &&\n      n.childNodes &&\n      n.childNodes[0].type !== NodeType.DocumentType // there isn't one already defined\n    ) {\n      // Trigger compatMode in the iframe\n      // this is needed as document.createElement('iframe') otherwise inherits a CSS1Compat mode from the parent replayer environment\n      if (\n        n.childNodes[0].type === NodeType.Element &&\n        'xmlns' in n.childNodes[0].attributes &&\n        n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml'\n      ) {\n        // might as well use an xhtml doctype if we've got an xhtml namespace\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">',\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">',\n        );\n      }\n    }\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        map,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode);\n      }\n    }\n  }\n\n  return node as INode;\n}\n\nfunction visit(idNodeMap: idNodeMap, onVisit: (node: INode) => void) {\n  function walk(node: INode) {\n    onVisit(node);\n  }\n\n  for (const key in idNodeMap) {\n    if (idNodeMap[key]) {\n      walk(idNodeMap[key]);\n    }\n  }\n}\n\nfunction handleScroll(node: INode) {\n  const n = node.__sn;\n  if (n.type !== NodeType.Element) {\n    return;\n  }\n  const el = (node as Node) as HTMLElement;\n  for (const name in n.attributes) {\n    if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: INode) => unknown;\n    hackCss?: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): [Node | null, idNodeMap] {\n  const { doc, onVisit, hackCss = true, afterAppend, cache } = options;\n  const idNodeMap: idNodeMap = {};\n  const node = buildNodeWithSN(n, {\n    doc,\n    map: idNodeMap,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache,\n  });\n  visit(idNodeMap, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode);\n  });\n  return [node, idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","isElement","n","nodeType","ELEMENT_NODE","isShadowRoot","host","Boolean","shadowRoot","maskInputValue","_a","maskInputOptions","tagName","type","value","maskInputFn","text","toLowerCase","repeat","length","ORIGINAL_ATTRIBUTE_NAME","is2DCanvasBlank","canvas","ctx","getContext","x","width","y","height","getImageData","originalGetImageData","Uint32Array","call","Math","min","data","buffer","some","pixel","canvasService","canvasCtx","_id","tagNameRegex","RegExp","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","cssStringified","cssText","isCSSImportRule","styleSheet","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","slice","stack","parts","pop","parts_1","_i","part","push","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","document","transformAttribute","name","pos","collectCharacters","regEx","chars","match","exec","substring","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","classList","contains","eIndex","className","matches","parentNode","TEXT_NODE","serializeNode","options","rootId","sheet","el","blockClass","blockSelector","inlineStylesheet","_b","maskTextFn","_c","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","__sn","docId","id","undefined","DOCUMENT_NODE","compatMode","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes_1","_d","attributes","_e","name_1","stylesheet","styleSheets","find","rel","_cssText","innerText","textContent","checked","selected","__context","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","image_1","oldValue_1","crossOrigin","recordInlineImage","naturalWidth","naturalHeight","drawImage","err","console","warn","currentSrc","complete","onload","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_f","getBoundingClientRect","class","rr_width","rr_height","src","contentDocument","rr_src","Element","isSVG","ownerSVGElement","parentTagName","isStyle","isScript","nextSibling","previousSibling","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","serializeNodeWithId","skipChild","slimDOMOptions","onSerialize","onIframeLoad","_g","iframeLoadTimeout","_h","_j","preserveWhiteSpace","_serializedNode","sn","comment","script","as","endsWith","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","isShadowHost","headWhitespace","bypassOptions","_k","serializedChildNode","_m","_l","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","setTimeout","timer_1","clearTimeout","onceIframeLoaded","iframeDoc","serializedIframeNode","commentre","parse","css","lineno","column","updatePosition","str","lines","i","lastIndexOf","position","start","line","Position","whitespace","this","end","source","prototype","content","errorsList","msg","Error","reason","filename","silent","open","close","comments","atrule","re","m","selector","declaration","propMatch","prop","val","ret","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","vendor","frame","frames","concat","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","atdocument","sel","selectors","atpage","athost","atfontface","addParent","parsingErrors","obj","parent","isNode","childParent","keys","isArray","forEach","v","defineProperty","configurable","writable","enumerable","tagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","HOVER_SELECTOR","HOVER_SELECTOR_GLOBAL","addHoverClass","cache","cachedStyle","stylesWithHoverClass","get","ast","selectorMatcher","filter","index","sort","b","result","newSelector","set","buildNode","hackCss","implementation","createDocument","createDocumentType","node_1","getTagName","createElementNS","hasOwnProperty","startsWith","image","setAttribute","play","e","pause","isTextarea","isRemoteOrDynamicCss","child","createTextNode","removeChild","appendChild","setAttributeNS","srcset","firstChild","attachShadow","mode","createCDATASection","createComment","buildNodeWithSN","afterAppend","assert","xmlns","write","childN","childNode","Map","onVisit","idNodeMap","key","visit","visitedNode","name_2","handleScroll","maskAllInputs","slimDOM","color","date","email","month","number","range","search","tel","time","week","textarea","select","password","walk","current"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/utils.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n  compatMode?: string;\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport interface ICanvas extends HTMLCanvasElement {\n  __context: string;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type DataURLOptions = Partial<{\n  type: string;\n  quality: number;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\nexport type MaskInputFn = (text: string) => string;\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\nexport type BuildCache = {\n  stylesWithHoverClass: Map<string, string>;\n};\n","import { INode, MaskInputFn, MaskInputOptions } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n\nexport function maskInputValue({\n  input,\n  maskInputSelector,\n  unmaskInputSelector,\n  maskInputOptions,\n  tagName,\n  type,\n  value,\n  maskInputFn,\n}: {\n  input: HTMLElement;\n  maskInputSelector: string|null;\n  unmaskInputSelector: string|null;\n  maskInputOptions: MaskInputOptions;\n  tagName: string;\n  type: string | number | boolean | null;\n  value: string | null;\n  maskInputFn?: MaskInputFn;\n}): string {\n  let text = value || '';\n\n  if (unmaskInputSelector && input.matches(unmaskInputSelector)) {\n    return text;\n  }\n\n  if (\n    maskInputOptions[tagName.toLowerCase() as keyof MaskInputOptions] ||\n    maskInputOptions[type as keyof MaskInputOptions] ||\n    (maskInputSelector && input.matches(maskInputSelector))\n  ) {\n    if (maskInputFn) {\n      text = maskInputFn(text);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n  return text;\n}\n\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\ntype PatchedGetImageData = {\n  [ORIGINAL_ATTRIBUTE_NAME]: CanvasImageData['getImageData'];\n} & CanvasImageData['getImageData'];\n\nexport function is2DCanvasBlank(canvas: HTMLCanvasElement): boolean {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n\n  const chunkSize = 50;\n\n  // get chunks of the canvas and check if it is blank\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData as PatchedGetImageData;\n      const originalGetImageData =\n        ORIGINAL_ATTRIBUTE_NAME in getImageData\n          ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\n          : getImageData;\n      // by getting the canvas in chunks we avoid an expensive\n      // `getImageData` call that retrieves everything\n      // even if we can already tell from the first chunk(s) that\n      // the canvas isn't blank\n      const pixelBuffer = new Uint32Array(\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y),\n        ).data.buffer,\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  DataURLOptions,\n  MaskTextFn,\n  MaskInputFn,\n  KeepIframeSrcFn,\n  ICanvas,\n} from './types';\nimport {\n  is2DCanvasBlank,\n  isElement,\n  isShadowRoot,\n  maskInputValue,\n} from './utils';\n\nlet _id = 1;\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  let cssStringified = rule.cssText;\n  if (isCSSImportRule(rule)) {\n    try {\n      cssStringified = getCssRulesString(rule.styleSheet) || cssStringified;\n    } catch {\n      // ignore\n    }\n  }\n  return cssStringified;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction stringifyStyleSheet(sheet: CSSStyleSheet): string {\n  return sheet.cssRules\n    ? Array.from(sheet.cssRules)\n        .map((rule) => rule.cssText || '')\n        .join('')\n    : '';\n}\n\nfunction extractOrigin(url: string): string {\n  let origin = '';\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nlet canvasService: HTMLCanvasElement | null;\nlet canvasCtx: CanvasRenderingContext2D | null;\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    let chars: string;\n    let match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return Boolean(el.tagName === 'svg' || (el as SVGElement).ownerSVGElement);\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || (name === 'href' && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value && value[0] !== '#') {\n    // xlink:href starts with # is an id pointer\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else if (tagName === 'object' && name === 'data' && value) {\n    return absoluteToDoc(doc, value);\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n  unblockSelector: string | null,\n): boolean {\n  if (unblockSelector && element.matches(unblockSelector)) {\n    return false;\n  }\n\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n  unmaskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (unmaskTextSelector) {\n      if ((node as HTMLElement).matches(unmaskTextSelector) || (node as HTMLElement).closest(unmaskTextSelector)) {\n        return false;\n      }\n    }\n\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      // tslint:disable-next-line: prefer-for-of\n      for (\n        let eIndex = 0;\n        eIndex < (node as HTMLElement).classList.length;\n        eIndex++\n      ) {\n        const className = (node as HTMLElement).classList[eIndex];\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);\n  }\n\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    // iframe was already loaded, make sure we wait to trigger the listener\n    // till _after_ the mutation that found this iframe has had time to process\n    setTimeout(listener, 0);\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    unblockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    unmaskTextSelector: string | null;\n    maskInputSelector: string | null;\n    unmaskInputSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputSelector,\n    unmaskInputSelector,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if ((n as HTMLDocument).compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: (n as HTMLDocument).compatMode, // probably \"BackCompat\"\n          rootId,\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          rootId,\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n        unblockSelector\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        let cssText: string | null = null;\n        if (stylesheet) {\n          cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        }\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value = maskInputValue({\n            input: n as HTMLElement,\n            type: attributes.type,\n            tagName,\n            value,\n            maskInputSelector,\n            unmaskInputSelector,\n            maskInputOptions,\n            maskInputFn,\n          });\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        if ((n as HTMLOptionElement).selected && !maskInputOptions['select']) {\n          attributes.selected = true;\n        } else {\n          // ignore the html attribute (which corresponds to DOM (n as HTMLOptionElement).defaultSelected)\n          // if it's already been changed\n          delete attributes.selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        if ((n as ICanvas).__context === '2d') {\n          // only record this on 2d canvas\n          if (!is2DCanvasBlank(n as HTMLCanvasElement)) {\n            attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          }\n        } else if (!('__context' in n)) {\n          // context is unknown, better not call getContext to trigger it\n          const canvasDataURL = (n as HTMLCanvasElement).toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // create blank canvas of same dimensions\n          const blankCanvas = document.createElement('canvas');\n          blankCanvas.width = (n as HTMLCanvasElement).width;\n          blankCanvas.height = (n as HTMLCanvasElement).height;\n          const blankCanvasDataURL = blankCanvas.toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // no need to save dataURL if it's the same as blank canvas\n          if (canvasDataURL !== blankCanvasDataURL) {\n            attributes.rr_dataURL = canvasDataURL;\n          }\n        }\n      }\n      // save image offline\n      if (tagName === 'img' && inlineImages) {\n        if (!canvasService) {\n          canvasService = doc.createElement('canvas');\n          canvasCtx = canvasService.getContext('2d');\n        }\n        const image = n as HTMLImageElement;\n        const oldValue = image.crossOrigin;\n        image.crossOrigin = 'anonymous';\n        const recordInlineImage = () => {\n          try {\n            canvasService!.width = image.naturalWidth;\n            canvasService!.height = image.naturalHeight;\n            canvasCtx!.drawImage(image, 0, 0);\n            attributes.rr_dataURL = canvasService!.toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          } catch (err) {\n            console.warn(\n              `Cannot inline img src=${image.currentSrc}! Error: ${err}`,\n            );\n          }\n          oldValue\n            ? (attributes.crossOrigin = oldValue)\n            : delete attributes.crossOrigin;\n        };\n        // The image content may not have finished loading yet.\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.onload = recordInlineImage;\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n        attributes.rr_mediaCurrentTime = (n as HTMLMediaElement).currentTime;\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src as string)) {\n        if (!(n as HTMLIFrameElement).contentDocument) {\n          // we can't record it directly as we can't see into it\n          // preserve the src attribute so a decision can be taken at replay time\n          attributes.rr_src = attributes.src;\n        }\n        delete attributes.src; // prevent auto loading\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        try {\n          // try to read style sheet\n          if (n.nextSibling || n.previousSibling) {\n            // This is not the only child of the stylesheet.\n            // We can't read all of the sheet's .cssRules and expect them\n            // to _only_ include the current rule(s) added by the text node.\n            // So we'll be conservative and keep textContent as-is.\n          } else if ((n.parentNode as HTMLStyleElement).sheet?.cssRules) {\n            textContent = stringifyStyleSheet(\n              (n.parentNode as HTMLStyleElement).sheet!,\n            );\n          }\n        } catch (err) {\n          console.warn(\n            `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n            n,\n          );\n        }\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      // script tag\n      (sn.tagName === 'script' ||\n        // preload link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script') ||\n        // prefetch link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'prefetch' &&\n          typeof sn.attributes.href === 'string' &&\n          sn.attributes.href.endsWith('.js')))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    unblockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    unmaskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputSelector: string | null;\n    unmaskInputSelector: string | null;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputSelector,\n    unmaskInputSelector,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputSelector,\n    unmaskInputSelector,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n    if ((n as HTMLElement).shadowRoot) serializedNode.isShadowHost = true;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputSelector,\n      unmaskInputSelector,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputSelector,\n            unmaskInputSelector,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    unblockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    unmaskTextSelector?: string | null;\n    maskInputSelector?: string | null;\n    unmaskInputSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    maskInputFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    unblockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskInputSelector = null,\n    unmaskInputSelector = null,\n    maskAllInputs = false,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    keepIframeSrcFn = () => false,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputSelector,\n      unmaskInputSelector,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n\n/* tslint:disable no-conditional-assignment interface-name no-shadowed-variable */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends Node {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport interface Host extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each “selector” is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends Node {\n  /** The part following @media. */\n  media?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends Node {\n  /** The part following @supports. */\n  supports?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules {\n  source?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}) {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    let i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.prototype.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    return trim(m[0])\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      })\n      .split(/\\s*(?![^(]*\\)),\\s*/)\n      .map((s) => {\n        return s.replace(/\\u200C/g, ',');\n      });\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    let propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet) {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent((value as unknown) as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { parse } from './css';\nimport {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n  BuildCache,\n} from './types';\nimport { isElement } from './utils';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nfunction escapeRegExp(str: string) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\nexport function addHoverClass(cssText: string, cache: BuildCache): string {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n\n  const ast = parse(cssText, {\n    silent: true,\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  const selectors: string[] = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n\n  if (selectors.length === 0) {\n    return cssText;\n  }\n\n  const selectorMatcher = new RegExp(\n    selectors\n      .filter((selector, index) => selectors.indexOf(selector) === index)\n      .sort((a, b) => b.length - a.length)\n      .map((selector) => {\n        return escapeRegExp(selector);\n      })\n      .join('|'),\n    'g',\n  );\n\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nexport function createCache(): BuildCache {\n  const stylesWithHoverClass: Map<string, string> = new Map();\n  return {\n    stylesWithHoverClass,\n  };\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n    cache: BuildCache;\n  },\n): Node | null {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        if (!n.attributes.hasOwnProperty(name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (tagName === 'option' && name === 'selected' && value === false) {\n          // legacy fix (TODO: if `value === false` can be generated for other attrs, should we also omit those other attrs from build?)\n          continue;\n        }\n        value =\n          typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (!name.startsWith('rr_')) {\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss && hackCss) {\n            value = addHoverClass(value, cache);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            // https://github.com/rrweb-io/rrweb/issues/112\n            for (const c of Array.from(node.childNodes)) {\n              if (c.nodeType === node.TEXT_NODE) {\n                node.removeChild(c);\n              }\n            }\n            node.appendChild(child);\n            continue;\n          }\n\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else if (\n              name === 'onload' ||\n              name === 'onclick' ||\n              name.substring(0, 7) === 'onmouse'\n            ) {\n              // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n              // as setting them triggers a console.error (which shows up despite the try/catch)\n              // Assumption: these attributes are not used to css\n              node.setAttribute('_' + name, value);\n            } else if (\n              tagName === 'meta' &&\n              n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n              name === 'content'\n            ) {\n              // If CSP contains style-src and inline-style is disabled, there will be an error \"Refused to apply inline style because it violates the following Content Security Policy directive: style-src '*'\".\n              // And the function insertStyleRules in rrweb replayer will throw an error \"Uncaught TypeError: Cannot read property 'insertRule' of null\".\n              node.setAttribute('csp-content', value);\n              continue;\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'preload' &&\n              n.attributes.as === 'script'\n            ) {\n              // ignore\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'prefetch' &&\n              typeof n.attributes.href === 'string' &&\n              n.attributes.href.endsWith('.js')\n            ) {\n              // ignore\n            } else if (\n              tagName === 'img' &&\n              n.attributes.srcset &&\n              n.attributes.rr_dataURL\n            ) {\n              // backup original img srcset\n              node.setAttribute('rrweb-original-srcset', n.attributes.srcset as string);\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (tagName === 'canvas' && name === 'rr_dataURL') {\n            const image = document.createElement('img');\n            image.src = value;\n            image.onload = () => {\n              const ctx = (node as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n          } else if (tagName === 'img' && name === 'rr_dataURL') {\n            const image = node as HTMLImageElement;\n            if (!image.currentSrc.startsWith('data:')) {\n              // Backup original img src. It may not have been set yet.\n              image.setAttribute(\n                'rrweb-original-src',\n                n.attributes.src as string,\n              );\n              image.src = value;\n            }\n          }\n\n          if (name === 'rr_width') {\n            (node as HTMLElement).style.width = value;\n          } else if (name === 'rr_height') {\n            (node as HTMLElement).style.height = value;\n          } else if (name === 'rr_mediaCurrentTime') {\n            (node as HTMLMediaElement).currentTime = n.attributes\n              .rr_mediaCurrentTime as number;\n          } else if (name === 'rr_mediaState') {\n            switch (value) {\n              case 'played':\n                (node as HTMLMediaElement)\n                  .play()\n                  .catch((e) => console.warn('media playback error', e));\n                break;\n              case 'paused':\n                (node as HTMLMediaElement).pause();\n                break;\n              default:\n            }\n          }\n        }\n      }\n\n      if (n.isShadowHost) {\n        /**\n         * Since node is newly rebuilt, it should be a normal element\n         * without shadowRoot.\n         * But if there are some weird situations that has defined\n         * custom element in the scope before we rebuild node, it may\n         * register the shadowRoot earlier.\n         * The logic in the 'else' block is just a try-my-best solution\n         * for the corner case, please let we know if it is wrong and\n         * we can remove it.\n         */\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: 'open' });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss\n          ? addHoverClass(n.textContent, cache)\n          : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    skipChild?: boolean;\n    hackCss: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): INode | null {\n  const {\n    doc,\n    map,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache,\n  } = options;\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n.rootId) {\n    console.assert(\n      ((map[n.rootId] as unknown) as Document) === doc,\n      'Target document should has the same root id.',\n    );\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    if (\n      n.compatMode === 'BackCompat' &&\n      n.childNodes &&\n      n.childNodes[0].type !== NodeType.DocumentType // there isn't one already defined\n    ) {\n      // Trigger compatMode in the iframe\n      // this is needed as document.createElement('iframe') otherwise inherits a CSS1Compat mode from the parent replayer environment\n      if (\n        n.childNodes[0].type === NodeType.Element &&\n        'xmlns' in n.childNodes[0].attributes &&\n        n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml'\n      ) {\n        // might as well use an xhtml doctype if we've got an xhtml namespace\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">',\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">',\n        );\n      }\n    }\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        map,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode);\n      }\n    }\n  }\n\n  return node as INode;\n}\n\nfunction visit(idNodeMap: idNodeMap, onVisit: (node: INode) => void) {\n  function walk(node: INode) {\n    onVisit(node);\n  }\n\n  for (const key in idNodeMap) {\n    if (idNodeMap[key]) {\n      walk(idNodeMap[key]);\n    }\n  }\n}\n\nfunction handleScroll(node: INode) {\n  const n = node.__sn;\n  if (n.type !== NodeType.Element) {\n    return;\n  }\n  const el = (node as Node) as HTMLElement;\n  for (const name in n.attributes) {\n    if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: INode) => unknown;\n    hackCss?: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): [Node | null, idNodeMap] {\n  const { doc, onVisit, hackCss = true, afterAppend, cache } = options;\n  const idNodeMap: idNodeMap = {};\n  const node = buildNodeWithSN(n, {\n    doc,\n    map: idNodeMap,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache,\n  });\n  visit(idNodeMap, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode);\n  });\n  return [node, idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","isElement","n","nodeType","ELEMENT_NODE","isShadowRoot","host","Boolean","shadowRoot","maskInputValue","_a","input","maskInputSelector","unmaskInputSelector","maskInputOptions","tagName","type","value","maskInputFn","text","matches","toLowerCase","repeat","length","ORIGINAL_ATTRIBUTE_NAME","is2DCanvasBlank","canvas","ctx","getContext","x","width","y","height","getImageData","originalGetImageData","Uint32Array","call","Math","min","data","buffer","some","pixel","canvasService","canvasCtx","_id","tagNameRegex","RegExp","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","cssStringified","cssText","isCSSImportRule","styleSheet","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","slice","stack","parts","pop","parts_1","_i","part","push","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","document","transformAttribute","name","pos","collectCharacters","regEx","chars","match","exec","substring","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","unmaskTextSelector","closest","classList","contains","eIndex","className","parentNode","TEXT_NODE","serializeNode","options","rootId","sheet","el","blockClass","blockSelector","unblockSelector","inlineStylesheet","_b","maskTextFn","_c","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","__sn","docId","id","undefined","DOCUMENT_NODE","compatMode","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes_1","_d","attributes","_e","name_1","stylesheet","styleSheets","find","rel","_cssText","innerText","textContent","checked","selected","__context","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","image_1","oldValue_1","crossOrigin","recordInlineImage","naturalWidth","naturalHeight","drawImage","err","console","warn","currentSrc","complete","onload","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_f","getBoundingClientRect","class","rr_width","rr_height","src","contentDocument","rr_src","Element","isSVG","ownerSVGElement","parentTagName","isStyle","isScript","nextSibling","previousSibling","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","serializeNodeWithId","skipChild","slimDOMOptions","onSerialize","onIframeLoad","_g","iframeLoadTimeout","_h","_j","preserveWhiteSpace","_serializedNode","sn","comment","script","as","endsWith","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","isShadowHost","headWhitespace","bypassOptions","_k","serializedChildNode","_m","_l","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","setTimeout","timer_1","clearTimeout","onceIframeLoaded","iframeDoc","serializedIframeNode","commentre","parse","css","lineno","column","updatePosition","str","lines","i","lastIndexOf","position","start","line","Position","whitespace","this","end","source","prototype","content","errorsList","msg","Error","reason","filename","silent","open","close","comments","atrule","re","m","selector","declaration","propMatch","prop","val","ret","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","vendor","frame","frames","concat","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","atdocument","sel","selectors","atpage","athost","atfontface","addParent","parsingErrors","obj","parent","isNode","childParent","keys","isArray","forEach","v","defineProperty","configurable","writable","enumerable","tagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","HOVER_SELECTOR","HOVER_SELECTOR_GLOBAL","addHoverClass","cache","cachedStyle","stylesWithHoverClass","get","ast","selectorMatcher","filter","index","sort","b","result","newSelector","set","buildNode","hackCss","implementation","createDocument","createDocumentType","node_1","getTagName","createElementNS","hasOwnProperty","startsWith","image","setAttribute","play","e","pause","isTextarea","isRemoteOrDynamicCss","child","createTextNode","removeChild","appendChild","setAttributeNS","srcset","firstChild","attachShadow","mode","createCDATASection","createComment","buildNodeWithSN","afterAppend","assert","xmlns","write","childN","childNode","Map","onVisit","idNodeMap","key","visit","visitedNode","name_2","handleScroll","_o","maskAllInputs","_p","slimDOM","_q","color","date","email","month","number","range","search","tel","time","week","textarea","select","password","walk","current"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/rrweb-snapshot/es/rrweb-snapshot.js b/node_modules/rrweb-snapshot/es/rrweb-snapshot.js
old mode 100644
new mode 100755
index f0c4ce2..831c6c8
--- a/node_modules/rrweb-snapshot/es/rrweb-snapshot.js
+++ b/node_modules/rrweb-snapshot/es/rrweb-snapshot.js
@@ -17,10 +17,14 @@ function isShadowRoot(n) {
     return Boolean(host && host.shadowRoot && host.shadowRoot === n);
 }
 function maskInputValue(_a) {
-    var maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;
+    var input = _a.input, maskInputSelector = _a.maskInputSelector, unmaskInputSelector = _a.unmaskInputSelector, maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;
     var text = value || '';
+    if (unmaskInputSelector && input.matches(unmaskInputSelector)) {
+        return text;
+    }
     if (maskInputOptions[tagName.toLowerCase()] ||
-        maskInputOptions[type]) {
+        maskInputOptions[type] ||
+        (maskInputSelector && input.matches(maskInputSelector))) {
         if (maskInputFn) {
             text = maskInputFn(text);
         }
@@ -247,7 +251,10 @@ function transformAttribute(doc, tagName, name, value) {
         return value;
     }
 }
-function _isBlockedElement(element, blockClass, blockSelector) {
+function _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {
+    if (unblockSelector && element.matches(unblockSelector)) {
+        return false;
+    }
     if (typeof blockClass === 'string') {
         if (element.classList.contains(blockClass)) {
             return true;
@@ -266,11 +273,16 @@ function _isBlockedElement(element, blockClass, blockSelector) {
     }
     return false;
 }
-function needMaskingText(node, maskTextClass, maskTextSelector) {
+function needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextSelector) {
     if (!node) {
         return false;
     }
     if (node.nodeType === node.ELEMENT_NODE) {
+        if (unmaskTextSelector) {
+            if (node.matches(unmaskTextSelector) || node.closest(unmaskTextSelector)) {
+                return false;
+            }
+        }
         if (typeof maskTextClass === 'string') {
             if (node.classList.contains(maskTextClass)) {
                 return true;
@@ -289,12 +301,12 @@ function needMaskingText(node, maskTextClass, maskTextSelector) {
                 return true;
             }
         }
-        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
     }
     if (node.nodeType === node.TEXT_NODE) {
-        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
     }
-    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
 }
 function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
     var win = iframeEl.contentWindow;
@@ -334,7 +346,7 @@ function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
 }
 function serializeNode(n, options) {
     var _a;
-    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, inlineStylesheet = options.inlineStylesheet, _b = options.maskInputOptions, maskInputOptions = _b === void 0 ? {} : _b, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _c = options.dataURLOptions, dataURLOptions = _c === void 0 ? {} : _c, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;
+    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, unblockSelector = options.unblockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, unmaskTextSelector = options.unmaskTextSelector, inlineStylesheet = options.inlineStylesheet, maskInputSelector = options.maskInputSelector, unmaskInputSelector = options.unmaskInputSelector, _b = options.maskInputOptions, maskInputOptions = _b === void 0 ? {} : _b, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _c = options.dataURLOptions, dataURLOptions = _c === void 0 ? {} : _c, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;
     var rootId;
     if (doc.__sn) {
         var docId = doc.__sn.id;
@@ -366,7 +378,7 @@ function serializeNode(n, options) {
                 rootId: rootId
             };
         case n.ELEMENT_NODE:
-            var needBlock = _isBlockedElement(n, blockClass, blockSelector);
+            var needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);
             var tagName = getValidTagName(n);
             var attributes_1 = {};
             for (var _i = 0, _d = Array.from(n.attributes); _i < _d.length; _i++) {
@@ -407,9 +419,12 @@ function serializeNode(n, options) {
                     attributes_1.type !== 'button' &&
                     value) {
                     attributes_1.value = maskInputValue({
+                        input: n,
                         type: attributes_1.type,
                         tagName: tagName,
                         value: value,
+                        maskInputSelector: maskInputSelector,
+                        unmaskInputSelector: unmaskInputSelector,
                         maskInputOptions: maskInputOptions,
                         maskInputFn: maskInputFn
                     });
@@ -528,7 +543,7 @@ function serializeNode(n, options) {
             }
             if (!isStyle &&
                 !isScript &&
-                needMaskingText(n, maskTextClass, maskTextSelector) &&
+                needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextSelector) &&
                 textContent) {
                 textContent = maskTextFn
                     ? maskTextFn(textContent)
@@ -636,15 +651,19 @@ function slimDOMExcluded(sn, slimDOMOptions) {
     return false;
 }
 function serializeNodeWithId(n, options) {
-    var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, _h = options.keepIframeSrcFn, keepIframeSrcFn = _h === void 0 ? function () { return false; } : _h;
+    var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, unblockSelector = options.unblockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, unmaskTextSelector = options.unmaskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, maskInputSelector = options.maskInputSelector, unmaskInputSelector = options.unmaskInputSelector, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, _h = options.keepIframeSrcFn, keepIframeSrcFn = _h === void 0 ? function () { return false; } : _h;
     var _j = options.preserveWhiteSpace, preserveWhiteSpace = _j === void 0 ? true : _j;
     var _serializedNode = serializeNode(n, {
         doc: doc,
         blockClass: blockClass,
         blockSelector: blockSelector,
+        unblockSelector: unblockSelector,
         maskTextClass: maskTextClass,
         maskTextSelector: maskTextSelector,
+        unmaskTextSelector: unmaskTextSelector,
         inlineStylesheet: inlineStylesheet,
+        maskInputSelector: maskInputSelector,
+        unmaskInputSelector: unmaskInputSelector,
         maskInputOptions: maskInputOptions,
         maskTextFn: maskTextFn,
         maskInputFn: maskInputFn,
@@ -700,10 +719,14 @@ function serializeNodeWithId(n, options) {
             map: map,
             blockClass: blockClass,
             blockSelector: blockSelector,
+            unblockSelector: unblockSelector,
             maskTextClass: maskTextClass,
             maskTextSelector: maskTextSelector,
+            unmaskTextSelector: unmaskTextSelector,
             skipChild: skipChild,
             inlineStylesheet: inlineStylesheet,
+            maskInputSelector: maskInputSelector,
+            unmaskInputSelector: unmaskInputSelector,
             maskInputOptions: maskInputOptions,
             maskTextFn: maskTextFn,
             maskInputFn: maskInputFn,
@@ -748,10 +771,14 @@ function serializeNodeWithId(n, options) {
                     map: map,
                     blockClass: blockClass,
                     blockSelector: blockSelector,
+                    unblockSelector: unblockSelector,
                     maskTextClass: maskTextClass,
                     maskTextSelector: maskTextSelector,
+                    unmaskTextSelector: unmaskTextSelector,
                     skipChild: false,
                     inlineStylesheet: inlineStylesheet,
+                    maskInputSelector: maskInputSelector,
+                    unmaskInputSelector: unmaskInputSelector,
                     maskInputOptions: maskInputOptions,
                     maskTextFn: maskTextFn,
                     maskInputFn: maskInputFn,
@@ -774,7 +801,7 @@ function serializeNodeWithId(n, options) {
     return serializedNode;
 }
 function snapshot(n, options) {
-    var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.maskTextClass, maskTextClass = _d === void 0 ? 'rr-mask' : _d, _e = _a.maskTextSelector, maskTextSelector = _e === void 0 ? null : _e, _f = _a.inlineStylesheet, inlineStylesheet = _f === void 0 ? true : _f, _g = _a.inlineImages, inlineImages = _g === void 0 ? false : _g, _h = _a.recordCanvas, recordCanvas = _h === void 0 ? false : _h, _j = _a.maskAllInputs, maskAllInputs = _j === void 0 ? false : _j, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _k = _a.slimDOM, slimDOM = _k === void 0 ? false : _k, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _l = _a.keepIframeSrcFn, keepIframeSrcFn = _l === void 0 ? function () { return false; } : _l;
+    var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.unblockSelector, unblockSelector = _d === void 0 ? null : _d, _e = _a.maskTextClass, maskTextClass = _e === void 0 ? 'rr-mask' : _e, _f = _a.maskTextSelector, maskTextSelector = _f === void 0 ? null : _f, _g = _a.unmaskTextSelector, unmaskTextSelector = _g === void 0 ? null : _g, _h = _a.inlineStylesheet, inlineStylesheet = _h === void 0 ? true : _h, _j = _a.inlineImages, inlineImages = _j === void 0 ? false : _j, _k = _a.recordCanvas, recordCanvas = _k === void 0 ? false : _k, _l = _a.maskInputSelector, maskInputSelector = _l === void 0 ? null : _l, _m = _a.unmaskInputSelector, unmaskInputSelector = _m === void 0 ? null : _m, _o = _a.maskAllInputs, maskAllInputs = _o === void 0 ? false : _o, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _p = _a.slimDOM, slimDOM = _p === void 0 ? false : _p, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _q = _a.keepIframeSrcFn, keepIframeSrcFn = _q === void 0 ? function () { return false; } : _q;
     var idNodeMap = {};
     var maskInputOptions = maskAllInputs === true
         ? {
@@ -823,10 +850,14 @@ function snapshot(n, options) {
             map: idNodeMap,
             blockClass: blockClass,
             blockSelector: blockSelector,
+            unblockSelector: unblockSelector,
             maskTextClass: maskTextClass,
             maskTextSelector: maskTextSelector,
+            unmaskTextSelector: unmaskTextSelector,
             skipChild: false,
             inlineStylesheet: inlineStylesheet,
+            maskInputSelector: maskInputSelector,
+            unmaskInputSelector: unmaskInputSelector,
             maskInputOptions: maskInputOptions,
             maskTextFn: maskTextFn,
             maskInputFn: maskInputFn,
diff --git a/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js b/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js
old mode 100644
new mode 100755
index 432f88d..90fdb88
--- a/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js
+++ b/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js
@@ -1,2 +1,2 @@
-var e;function t(e){return e.nodeType===e.ELEMENT_NODE}function r(e){var t,r=null===(t=e)||void 0===t?void 0:t.host;return Boolean(r&&r.shadowRoot&&r.shadowRoot===e)}function n(e){var t=e.maskInputOptions,r=e.tagName,n=e.type,a=e.value,i=e.maskInputFn,o=a||"";return(t[r.toLowerCase()]||t[n])&&(o=i?i(o):"*".repeat(o.length)),o}!function(e){e[e.Document=0]="Document",e[e.DocumentType=1]="DocumentType",e[e.Element=2]="Element",e[e.Text=3]="Text",e[e.CDATA=4]="CDATA",e[e.Comment=5]="Comment"}(e||(e={}));function a(e){var t=e.getContext("2d");if(!t)return!0;for(var r=0;r<e.width;r+=50)for(var n=0;n<e.height;n+=50){var a=t.getImageData,i="__rrweb_original__"in a?a.__rrweb_original__:a;if(new Uint32Array(i.call(t,r,n,Math.min(50,e.width-r),Math.min(50,e.height-n)).data.buffer).some((function(e){return 0!==e})))return!1}return!0}var i,o,s=1,c=new RegExp("[^a-z0-9-_:]"),l=-2;function u(e){try{var t=e.rules||e.cssRules;return t?Array.from(t).map(f).join(""):null}catch(e){return null}}function f(e){var t=e.cssText;if(function(e){return"styleSheet"in e}(e))try{t=u(e.styleSheet)||t}catch(e){}return t}var m=/url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,d=/^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/,p=/^(data:)([^,]*),(.*)/i;function h(e,t){return(e||"").replace(m,(function(e,r,n,a,i,o){var s,c=n||i||o,l=r||a||"";if(!c)return e;if(!d.test(c))return"url("+l+c+l+")";if(p.test(c))return"url("+l+c+l+")";if("/"===c[0])return"url("+l+(((s=t).indexOf("//")>-1?s.split("/").slice(0,3).join("/"):s.split("/")[0]).split("?")[0]+c)+l+")";var u=t.split("/"),f=c.split("/");u.pop();for(var m=0,h=f;m<h.length;m++){var v=h[m];"."!==v&&(".."===v?u.pop():u.push(v))}return"url("+l+u.join("/")+l+")"}))}var v=/^[^ \t\n\r\u000c]+/,g=/^[, \t\n\r\u000c]+/;function y(e,t){if(!t||""===t.trim())return t;var r=e.createElement("a");return r.href=t,r.href}function b(){var e=document.createElement("a");return e.href="",e.href}function k(e,t,r,n){return"src"===r||"href"===r&&n||"xlink:href"===r&&n&&"#"!==n[0]?y(e,n):"background"!==r||!n||"table"!==t&&"td"!==t&&"th"!==t?"srcset"===r&&n?function(e,t){if(""===t.trim())return t;var r=0;function n(e){var n,a=e.exec(t.substring(r));return a?(n=a[0],r+=n.length,n):""}for(var a=[];n(g),!(r>=t.length);){var i=n(v);if(","===i.slice(-1))i=y(e,i.substring(0,i.length-1)),a.push(i);else{var o="";i=y(e,i);for(var s=!1;;){var c=t.charAt(r);if(""===c){a.push((i+o).trim());break}if(s)")"===c&&(s=!1);else{if(","===c){r+=1,a.push((i+o).trim());break}"("===c&&(s=!0)}o+=c,r+=1}}}return a.join(", ")}(e,n):"style"===r&&n?h(n,b()):"object"===t&&"data"===r&&n?y(e,n):n:y(e,n)}function C(e,t,r){if(!e)return!1;if(e.nodeType===e.ELEMENT_NODE){if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var n=0;n<e.classList.length;n++){var a=e.classList[n];if(t.test(a))return!0}return!(!r||!e.matches(r))||C(e.parentNode,t,r)}return e.nodeType,e.TEXT_NODE,C(e.parentNode,t,r)}function T(t,r){var s,l,f,m,d=r.doc,p=r.blockClass,v=r.blockSelector,g=r.maskTextClass,y=r.maskTextSelector,T=r.inlineStylesheet,w=r.maskInputOptions,x=void 0===w?{}:w,S=r.maskTextFn,E=r.maskInputFn,_=r.dataURLOptions,N=void 0===_?{}:_,I=r.inlineImages,D=r.recordCanvas,L=r.keepIframeSrcFn;if(d.__sn){var O=d.__sn.id;l=1===O?void 0:O}switch(t.nodeType){case t.DOCUMENT_NODE:return"CSS1Compat"!==t.compatMode?{type:e.Document,childNodes:[],compatMode:t.compatMode,rootId:l}:{type:e.Document,childNodes:[],rootId:l};case t.DOCUMENT_TYPE_NODE:return{type:e.DocumentType,name:t.name,publicId:t.publicId,systemId:t.systemId,rootId:l};case t.ELEMENT_NODE:for(var A=function(e,t,r){if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var n=0;n<e.classList.length;n++){var a=e.classList[n];if(t.test(a))return!0}return!!r&&e.matches(r)}(t,p,v),R=function(e){if(e instanceof HTMLFormElement)return"form";var t=e.tagName.toLowerCase().trim();return c.test(t)?"div":t}(t),M={},F=0,U=Array.from(t.attributes);F<U.length;F++){var W=U[F],j=W.name,P=W.value;M[j]=k(d,R,j,P)}if("link"===R&&T){var B=Array.from(d.styleSheets).find((function(e){return e.href===t.href})),H=null;B&&(H=u(B)),H&&(delete M.rel,delete M.href,M._cssText=h(H,B.href))}if("style"===R&&t.sheet&&!(t.innerText||t.textContent||"").trim().length)(H=u(t.sheet))&&(M._cssText=h(H,b()));if("input"===R||"textarea"===R||"select"===R){P=t.value;"radio"!==M.type&&"checkbox"!==M.type&&"submit"!==M.type&&"button"!==M.type&&P?M.value=n({type:M.type,tagName:R,value:P,maskInputOptions:x,maskInputFn:E}):t.checked&&(M.checked=t.checked)}if("option"===R&&(t.selected&&!x.select?M.selected=!0:delete M.selected),"canvas"===R&&D)if("2d"===t.__context)a(t)||(M.rr_dataURL=t.toDataURL(N.type,N.quality));else if(!("__context"in t)){var G=t.toDataURL(N.type,N.quality),z=document.createElement("canvas");z.width=t.width,z.height=t.height,G!==z.toDataURL(N.type,N.quality)&&(M.rr_dataURL=G)}if("img"===R&&I){i||(i=d.createElement("canvas"),o=i.getContext("2d"));var q=t,V=q.crossOrigin;q.crossOrigin="anonymous";var $=function(){try{i.width=q.naturalWidth,i.height=q.naturalHeight,o.drawImage(q,0,0),M.rr_dataURL=i.toDataURL(N.type,N.quality)}catch(e){console.warn("Cannot inline img src="+q.currentSrc+"! Error: "+e)}V?M.crossOrigin=V:delete M.crossOrigin};q.complete&&0!==q.naturalWidth?$():q.onload=$}if("audio"!==R&&"video"!==R||(M.rr_mediaState=t.paused?"paused":"played",M.rr_mediaCurrentTime=t.currentTime),t.scrollLeft&&(M.rr_scrollLeft=t.scrollLeft),t.scrollTop&&(M.rr_scrollTop=t.scrollTop),A){var X=t.getBoundingClientRect(),Y=X.width,K=X.height;M={class:M.class,rr_width:Y+"px",rr_height:K+"px"}}return"iframe"!==R||L(M.src)||(t.contentDocument||(M.rr_src=M.src),delete M.src),{type:e.Element,tagName:R,attributes:M,childNodes:[],isSVG:(m=t,Boolean("svg"===m.tagName||m.ownerSVGElement)||void 0),needBlock:A,rootId:l};case t.TEXT_NODE:var Z=t.parentNode&&t.parentNode.tagName,J=t.textContent,Q="STYLE"===Z||void 0,ee="SCRIPT"===Z||void 0;if(Q&&J){try{t.nextSibling||t.previousSibling||(null===(s=t.parentNode.sheet)||void 0===s?void 0:s.cssRules)&&(J=(f=t.parentNode.sheet).cssRules?Array.from(f.cssRules).map((function(e){return e.cssText||""})).join(""):"")}catch(e){console.warn("Cannot get CSS styles from text's parentNode. Error: "+e,t)}J=h(J,b())}return ee&&(J="SCRIPT_PLACEHOLDER"),!Q&&!ee&&C(t,g,y)&&J&&(J=S?S(J):J.replace(/[\S]/g,"*")),{type:e.Text,textContent:J||"",isStyle:Q,rootId:l};case t.CDATA_SECTION_NODE:return{type:e.CDATA,textContent:"",rootId:l};case t.COMMENT_NODE:return{type:e.Comment,textContent:t.textContent||"",rootId:l};default:return!1}}function w(e){return void 0===e?"":e.toLowerCase()}function x(n,a){var i,o=a.doc,c=a.map,l=a.blockClass,u=a.blockSelector,f=a.maskTextClass,m=a.maskTextSelector,d=a.skipChild,p=void 0!==d&&d,h=a.inlineStylesheet,v=void 0===h||h,g=a.maskInputOptions,y=void 0===g?{}:g,b=a.maskTextFn,k=a.maskInputFn,C=a.slimDOMOptions,S=a.dataURLOptions,E=void 0===S?{}:S,_=a.inlineImages,N=void 0!==_&&_,I=a.recordCanvas,D=void 0!==I&&I,L=a.onSerialize,O=a.onIframeLoad,A=a.iframeLoadTimeout,R=void 0===A?5e3:A,M=a.keepIframeSrcFn,F=void 0===M?function(){return!1}:M,U=a.preserveWhiteSpace,W=void 0===U||U,j=T(n,{doc:o,blockClass:l,blockSelector:u,maskTextClass:f,maskTextSelector:m,inlineStylesheet:v,maskInputOptions:y,maskTextFn:b,maskInputFn:k,dataURLOptions:E,inlineImages:N,recordCanvas:D,keepIframeSrcFn:F});if(!j)return console.warn(n,"not serialized"),null;i="__sn"in n?n.__sn.id:!function(t,r){if(r.comment&&t.type===e.Comment)return!0;if(t.type===e.Element){if(r.script&&("script"===t.tagName||"link"===t.tagName&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===t.tagName&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")))return!0;if(r.headFavicon&&("link"===t.tagName&&"shortcut icon"===t.attributes.rel||"meta"===t.tagName&&(w(t.attributes.name).match(/^msapplication-tile(image|color)$/)||"application-name"===w(t.attributes.name)||"icon"===w(t.attributes.rel)||"apple-touch-icon"===w(t.attributes.rel)||"shortcut icon"===w(t.attributes.rel))))return!0;if("meta"===t.tagName){if(r.headMetaDescKeywords&&w(t.attributes.name).match(/^description|keywords$/))return!0;if(r.headMetaSocial&&(w(t.attributes.property).match(/^(og|twitter|fb):/)||w(t.attributes.name).match(/^(og|twitter):/)||"pinterest"===w(t.attributes.name)))return!0;if(r.headMetaRobots&&("robots"===w(t.attributes.name)||"googlebot"===w(t.attributes.name)||"bingbot"===w(t.attributes.name)))return!0;if(r.headMetaHttpEquiv&&void 0!==t.attributes["http-equiv"])return!0;if(r.headMetaAuthorship&&("author"===w(t.attributes.name)||"generator"===w(t.attributes.name)||"framework"===w(t.attributes.name)||"publisher"===w(t.attributes.name)||"progid"===w(t.attributes.name)||w(t.attributes.property).match(/^article:/)||w(t.attributes.property).match(/^product:/)))return!0;if(r.headMetaVerification&&("google-site-verification"===w(t.attributes.name)||"yandex-verification"===w(t.attributes.name)||"csrf-token"===w(t.attributes.name)||"p:domain_verify"===w(t.attributes.name)||"verify-v1"===w(t.attributes.name)||"verification"===w(t.attributes.name)||"shopify-checkout-api-token"===w(t.attributes.name)))return!0}}return!1}(j,C)&&(W||j.type!==e.Text||j.isStyle||j.textContent.replace(/^\s+|\s+$/gm,"").length)?s++:-2;var P=Object.assign(j,{id:i});if(n.__sn=P,-2===i)return null;c[i]=n,L&&L(n);var B=!p;if(P.type===e.Element&&(B=B&&!P.needBlock,delete P.needBlock,n.shadowRoot&&(P.isShadowHost=!0)),(P.type===e.Document||P.type===e.Element)&&B){C.headWhitespace&&j.type===e.Element&&"head"===j.tagName&&(W=!1);for(var H={doc:o,map:c,blockClass:l,blockSelector:u,maskTextClass:f,maskTextSelector:m,skipChild:p,inlineStylesheet:v,maskInputOptions:y,maskTextFn:b,maskInputFn:k,slimDOMOptions:C,dataURLOptions:E,inlineImages:N,recordCanvas:D,preserveWhiteSpace:W,onSerialize:L,onIframeLoad:O,iframeLoadTimeout:R,keepIframeSrcFn:F},G=0,z=Array.from(n.childNodes);G<z.length;G++){($=x(z[G],H))&&P.childNodes.push($)}if(t(n)&&n.shadowRoot)for(var q=0,V=Array.from(n.shadowRoot.childNodes);q<V.length;q++){var $;($=x(V[q],H))&&($.isShadow=!0,P.childNodes.push($))}}return n.parentNode&&r(n.parentNode)&&(P.isShadow=!0),P.type===e.Element&&"iframe"===P.tagName&&function(e,t,r){var n=e.contentWindow;if(n){var a,i=!1;try{a=n.document.readyState}catch(e){return}if("complete"===a){var o="about:blank";n.location.href===o&&e.src!==o&&""!==e.src?e.addEventListener("load",t):setTimeout(t,0)}else{var s=setTimeout((function(){i||(t(),i=!0)}),r);e.addEventListener("load",(function(){clearTimeout(s),i=!0,t()}))}}}(n,(function(){var e=n.contentDocument;if(e&&O){var t=x(e,{doc:e,map:c,blockClass:l,blockSelector:u,maskTextClass:f,maskTextSelector:m,skipChild:!1,inlineStylesheet:v,maskInputOptions:y,maskTextFn:b,maskInputFn:k,slimDOMOptions:C,dataURLOptions:E,inlineImages:N,recordCanvas:D,preserveWhiteSpace:W,onSerialize:L,onIframeLoad:O,iframeLoadTimeout:R,keepIframeSrcFn:F});t&&O(n,t)}}),R),P}function S(e,t){var r=t||{},n=r.blockClass,a=void 0===n?"rr-block":n,i=r.blockSelector,o=void 0===i?null:i,s=r.maskTextClass,c=void 0===s?"rr-mask":s,l=r.maskTextSelector,u=void 0===l?null:l,f=r.inlineStylesheet,m=void 0===f||f,d=r.inlineImages,p=void 0!==d&&d,h=r.recordCanvas,v=void 0!==h&&h,g=r.maskAllInputs,y=void 0!==g&&g,b=r.maskTextFn,k=r.maskInputFn,C=r.slimDOM,T=void 0!==C&&C,w=r.dataURLOptions,S=r.preserveWhiteSpace,E=r.onSerialize,_=r.onIframeLoad,N=r.iframeLoadTimeout,I=r.keepIframeSrcFn,D={};return[x(e,{doc:e,map:D,blockClass:a,blockSelector:o,maskTextClass:c,maskTextSelector:u,skipChild:!1,inlineStylesheet:m,maskInputOptions:!0===y?{color:!0,date:!0,"datetime-local":!0,email:!0,month:!0,number:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0,textarea:!0,select:!0,password:!0}:!1===y?{password:!0}:y,maskTextFn:b,maskInputFn:k,slimDOMOptions:!0===T||"all"===T?{script:!0,comment:!0,headFavicon:!0,headWhitespace:!0,headMetaDescKeywords:"all"===T,headMetaSocial:!0,headMetaRobots:!0,headMetaHttpEquiv:!0,headMetaAuthorship:!0,headMetaVerification:!0}:!1===T?{}:T,dataURLOptions:w,inlineImages:p,recordCanvas:v,preserveWhiteSpace:S,onSerialize:E,onIframeLoad:_,iframeLoadTimeout:N,keepIframeSrcFn:void 0===I?function(){return!1}:I}),D]}function E(t,r){!function t(n){r(n),n.type!==e.Document&&n.type!==e.Element||n.childNodes.forEach(t)}(t)}function _(){s=1}var N=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;function I(e,t){void 0===t&&(t={});var r=1,n=1;function a(e){var t=e.match(/\n/g);t&&(r+=t.length);var a=e.lastIndexOf("\n");n=-1===a?n+e.length:e.length-a}function i(){var e={line:r,column:n};return function(t){return t.position=new o(e),d(),t}}var o=function(e){this.start=e,this.end={line:r,column:n},this.source=t.source};o.prototype.content=e;var s=[];function c(a){var i=new Error(t.source+":"+r+":"+n+": "+a);if(i.reason=a,i.filename=t.source,i.line=r,i.column=n,i.source=e,!t.silent)throw i;s.push(i)}function l(){return m(/^{\s*/)}function u(){return m(/^}/)}function f(){var t,r=[];for(d(),p(r);e.length&&"}"!==e.charAt(0)&&(t=S()||E());)!1!==t&&(r.push(t),p(r));return r}function m(t){var r=t.exec(e);if(r){var n=r[0];return a(n),e=e.slice(n.length),r}}function d(){m(/^\s*/)}function p(e){var t;for(void 0===e&&(e=[]);t=h();)!1!==t&&e.push(t),t=h();return e}function h(){var t=i();if("/"===e.charAt(0)&&"*"===e.charAt(1)){for(var r=2;""!==e.charAt(r)&&("*"!==e.charAt(r)||"/"!==e.charAt(r+1));)++r;if(r+=2,""===e.charAt(r-1))return c("End of comment missing");var o=e.slice(2,r-2);return n+=2,a(o),e=e.slice(r),n+=2,t({type:"comment",comment:o})}}function v(){var e=m(/^([^{]+)/);if(e)return D(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g,"").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g,(function(e){return e.replace(/,/g,"‌")})).split(/\s*(?![^(]*\)),\s*/).map((function(e){return e.replace(/\u200C/g,",")}))}function g(){var e=i(),t=m(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);if(t){var r=D(t[0]);if(!m(/^:\s*/))return c("property missing ':'");var n=m(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/),a=e({type:"declaration",property:r.replace(N,""),value:n?D(n[0]).replace(N,""):""});return m(/^[;\s]*/),a}}function y(){var e,t=[];if(!l())return c("missing '{'");for(p(t);e=g();)!1!==e&&(t.push(e),p(t)),e=g();return u()?t:c("missing '}'")}function b(){for(var e,t=[],r=i();e=m(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/);)t.push(e[1]),m(/^,\s*/);if(t.length)return r({type:"keyframe",values:t,declarations:y()})}var k,C=x("import"),T=x("charset"),w=x("namespace");function x(e){var t=new RegExp("^@"+e+"\\s*([^;]+);");return function(){var r=i(),n=m(t);if(n){var a={type:e};return a[e]=n[1].trim(),r(a)}}}function S(){if("@"===e[0])return function(){var e=i(),t=m(/^@([-\w]+)?keyframes\s*/);if(t){var r=t[1];if(!(t=m(/^([-\w]+)\s*/)))return c("@keyframes missing name");var n,a=t[1];if(!l())return c("@keyframes missing '{'");for(var o=p();n=b();)o.push(n),o=o.concat(p());return u()?e({type:"keyframes",name:a,vendor:r,keyframes:o}):c("@keyframes missing '}'")}}()||function(){var e=i(),t=m(/^@media *([^{]+)/);if(t){var r=D(t[1]);if(!l())return c("@media missing '{'");var n=p().concat(f());return u()?e({type:"media",media:r,rules:n}):c("@media missing '}'")}}()||function(){var e=i(),t=m(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);if(t)return e({type:"custom-media",name:D(t[1]),media:D(t[2])})}()||function(){var e=i(),t=m(/^@supports *([^{]+)/);if(t){var r=D(t[1]);if(!l())return c("@supports missing '{'");var n=p().concat(f());return u()?e({type:"supports",supports:r,rules:n}):c("@supports missing '}'")}}()||C()||T()||w()||function(){var e=i(),t=m(/^@([-\w]+)?document *([^{]+)/);if(t){var r=D(t[1]),n=D(t[2]);if(!l())return c("@document missing '{'");var a=p().concat(f());return u()?e({type:"document",document:n,vendor:r,rules:a}):c("@document missing '}'")}}()||function(){var e=i();if(m(/^@page */)){var t=v()||[];if(!l())return c("@page missing '{'");for(var r,n=p();r=g();)n.push(r),n=n.concat(p());return u()?e({type:"page",selectors:t,declarations:n}):c("@page missing '}'")}}()||function(){var e=i();if(m(/^@host\s*/)){if(!l())return c("@host missing '{'");var t=p().concat(f());return u()?e({type:"host",rules:t}):c("@host missing '}'")}}()||function(){var e=i();if(m(/^@font-face\s*/)){if(!l())return c("@font-face missing '{'");for(var t,r=p();t=g();)r.push(t),r=r.concat(p());return u()?e({type:"font-face",declarations:r}):c("@font-face missing '}'")}}()}function E(){var e=i(),t=v();return t?(p(),e({type:"rule",selectors:t,declarations:y()})):c("selector missing")}return L((k=f(),{type:"stylesheet",stylesheet:{source:t.source,rules:k,parsingErrors:s}}))}function D(e){return e?e.replace(/^\s+|\s+$/g,""):""}function L(e,t){for(var r=e&&"string"==typeof e.type,n=r?e:t,a=0,i=Object.keys(e);a<i.length;a++){var o=e[i[a]];Array.isArray(o)?o.forEach((function(e){L(e,n)})):o&&"object"==typeof o&&L(o,n)}return r&&Object.defineProperty(e,"parent",{configurable:!0,writable:!0,enumerable:!1,value:t||null}),e}var O={script:"noscript",altglyph:"altGlyph",altglyphdef:"altGlyphDef",altglyphitem:"altGlyphItem",animatecolor:"animateColor",animatemotion:"animateMotion",animatetransform:"animateTransform",clippath:"clipPath",feblend:"feBlend",fecolormatrix:"feColorMatrix",fecomponenttransfer:"feComponentTransfer",fecomposite:"feComposite",feconvolvematrix:"feConvolveMatrix",fediffuselighting:"feDiffuseLighting",fedisplacementmap:"feDisplacementMap",fedistantlight:"feDistantLight",fedropshadow:"feDropShadow",feflood:"feFlood",fefunca:"feFuncA",fefuncb:"feFuncB",fefuncg:"feFuncG",fefuncr:"feFuncR",fegaussianblur:"feGaussianBlur",feimage:"feImage",femerge:"feMerge",femergenode:"feMergeNode",femorphology:"feMorphology",feoffset:"feOffset",fepointlight:"fePointLight",fespecularlighting:"feSpecularLighting",fespotlight:"feSpotLight",fetile:"feTile",feturbulence:"feTurbulence",foreignobject:"foreignObject",glyphref:"glyphRef",lineargradient:"linearGradient",radialgradient:"radialGradient"};var A=/([^\\]):hover/,R=new RegExp(A.source,"g");function M(e,t){var r=null==t?void 0:t.stylesWithHoverClass.get(e);if(r)return r;var n=I(e,{silent:!0});if(!n.stylesheet)return e;var a=[];if(n.stylesheet.rules.forEach((function(e){"selectors"in e&&(e.selectors||[]).forEach((function(e){A.test(e)&&a.push(e)}))})),0===a.length)return e;var i=new RegExp(a.filter((function(e,t){return a.indexOf(e)===t})).sort((function(e,t){return t.length-e.length})).map((function(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")})).join("|"),"g"),o=e.replace(i,(function(e){var t=e.replace(R,"$1.\\:hover");return e+", "+t}));return null==t||t.stylesWithHoverClass.set(e,o),o}function F(){return{stylesWithHoverClass:new Map}}function U(t,r){var n=r.doc,a=r.hackCss,i=r.cache;switch(t.type){case e.Document:return n.implementation.createDocument(null,"",null);case e.DocumentType:return n.implementation.createDocumentType(t.name||"html",t.publicId,t.systemId);case e.Element:var o,s=function(e){var t=O[e.tagName]?O[e.tagName]:e.tagName;return"link"===t&&e.attributes._cssText&&(t="style"),t}(t);o=t.isSVG?n.createElementNS("http://www.w3.org/2000/svg",s):n.createElement(s);var c=function(e){if(!t.attributes.hasOwnProperty(e))return"continue";var r=t.attributes[e];if("option"===s&&"selected"===e&&!1===r)return"continue";if(r="boolean"==typeof r||"number"==typeof r?"":r,e.startsWith("rr_")){if("canvas"===s&&"rr_dataURL"===e){var c=document.createElement("img");c.src=r,c.onload=function(){var e=o.getContext("2d");e&&e.drawImage(c,0,0,c.width,c.height)}}else if("img"===s&&"rr_dataURL"===e){var l=o;l.currentSrc.startsWith("data:")||(l.setAttribute("rrweb-original-src",t.attributes.src),l.src=r)}if("rr_width"===e)o.style.width=r;else if("rr_height"===e)o.style.height=r;else if("rr_mediaCurrentTime"===e)o.currentTime=t.attributes.rr_mediaCurrentTime;else if("rr_mediaState"===e)switch(r){case"played":o.play().catch((function(e){return console.warn("media playback error",e)}));break;case"paused":o.pause()}}else{var u="textarea"===s&&"value"===e,f="style"===s&&"_cssText"===e;if(f&&a&&(r=M(r,i)),u||f){for(var m=n.createTextNode(r),d=0,p=Array.from(o.childNodes);d<p.length;d++){var h=p[d];h.nodeType===o.TEXT_NODE&&o.removeChild(h)}return o.appendChild(m),"continue"}try{if(t.isSVG&&"xlink:href"===e)o.setAttributeNS("http://www.w3.org/1999/xlink",e,r);else if("onload"===e||"onclick"===e||"onmouse"===e.substring(0,7))o.setAttribute("_"+e,r);else{if("meta"===s&&"Content-Security-Policy"===t.attributes["http-equiv"]&&"content"===e)return o.setAttribute("csp-content",r),"continue";"link"===s&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===s&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")||("img"===s&&t.attributes.srcset&&t.attributes.rr_dataURL?o.setAttribute("rrweb-original-srcset",t.attributes.srcset):o.setAttribute(e,r))}}catch(e){}}};for(var l in t.attributes)c(l);if(t.isShadowHost)if(o.shadowRoot)for(;o.shadowRoot.firstChild;)o.shadowRoot.removeChild(o.shadowRoot.firstChild);else o.attachShadow({mode:"open"});return o;case e.Text:return n.createTextNode(t.isStyle&&a?M(t.textContent,i):t.textContent);case e.CDATA:return n.createCDATASection(t.textContent);case e.Comment:return n.createComment(t.textContent);default:return null}}function W(r,n){var a=n.doc,i=n.map,o=n.skipChild,s=void 0!==o&&o,c=n.hackCss,l=void 0===c||c,u=n.afterAppend,f=n.cache,m=U(r,{doc:a,hackCss:l,cache:f});if(!m)return null;if(r.rootId&&console.assert(i[r.rootId]===a,"Target document should has the same root id."),r.type===e.Document&&(a.close(),a.open(),"BackCompat"===r.compatMode&&r.childNodes&&r.childNodes[0].type!==e.DocumentType&&(r.childNodes[0].type===e.Element&&"xmlns"in r.childNodes[0].attributes&&"http://www.w3.org/1999/xhtml"===r.childNodes[0].attributes.xmlns?a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "">'):a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "">')),m=a),m.__sn=r,i[r.id]=m,(r.type===e.Document||r.type===e.Element)&&!s)for(var d=0,p=r.childNodes;d<p.length;d++){var h=p[d],v=W(h,{doc:a,map:i,skipChild:!1,hackCss:l,afterAppend:u,cache:f});v?(h.isShadow&&t(m)&&m.shadowRoot?m.shadowRoot.appendChild(v):m.appendChild(v),u&&u(v)):console.warn("Failed to rebuild",h)}return m}function j(t,r){var n=r.doc,a=r.onVisit,i=r.hackCss,o={},s=W(t,{doc:n,map:o,skipChild:!1,hackCss:void 0===i||i,afterAppend:r.afterAppend,cache:r.cache});return function(e,t){for(var r in e)e[r]&&(n=e[r],t(n));var n}(o,(function(t){a&&a(t),function(t){var r=t.__sn;if(r.type===e.Element){var n=t;for(var a in r.attributes)if(r.attributes.hasOwnProperty(a)&&a.startsWith("rr_")){var i=r.attributes[a];"rr_scrollLeft"===a&&(n.scrollLeft=i),"rr_scrollTop"===a&&(n.scrollTop=i)}}}(t)})),[s,o]}export{l as IGNORED_NODE,e as NodeType,M as addHoverClass,W as buildNodeWithSN,_ as cleanupSnapshot,F as createCache,a as is2DCanvasBlank,t as isElement,r as isShadowRoot,n as maskInputValue,C as needMaskingText,j as rebuild,x as serializeNodeWithId,S as snapshot,k as transformAttribute,E as visitSnapshot};
+var e;function t(e){return e.nodeType===e.ELEMENT_NODE}function r(e){var t,r=null===(t=e)||void 0===t?void 0:t.host;return Boolean(r&&r.shadowRoot&&r.shadowRoot===e)}function n(e){var t=e.input,r=e.maskInputSelector,n=e.unmaskInputSelector,a=e.maskInputOptions,i=e.tagName,o=e.type,s=e.value,c=e.maskInputFn,l=s||"";return n&&t.matches(n)||(a[i.toLowerCase()]||a[o]||r&&t.matches(r))&&(l=c?c(l):"*".repeat(l.length)),l}!function(e){e[e.Document=0]="Document",e[e.DocumentType=1]="DocumentType",e[e.Element=2]="Element",e[e.Text=3]="Text",e[e.CDATA=4]="CDATA",e[e.Comment=5]="Comment"}(e||(e={}));function a(e){var t=e.getContext("2d");if(!t)return!0;for(var r=0;r<e.width;r+=50)for(var n=0;n<e.height;n+=50){var a=t.getImageData,i="__rrweb_original__"in a?a.__rrweb_original__:a;if(new Uint32Array(i.call(t,r,n,Math.min(50,e.width-r),Math.min(50,e.height-n)).data.buffer).some((function(e){return 0!==e})))return!1}return!0}var i,o,s=1,c=new RegExp("[^a-z0-9-_:]"),l=-2;function u(e){try{var t=e.rules||e.cssRules;return t?Array.from(t).map(f).join(""):null}catch(e){return null}}function f(e){var t=e.cssText;if(function(e){return"styleSheet"in e}(e))try{t=u(e.styleSheet)||t}catch(e){}return t}var m=/url\((?:(')([^']*)'|(")(.*?)"|([^)]*))\)/gm,p=/^(?!www\.|(?:http|ftp)s?:\/\/|[A-Za-z]:\\|\/\/|#).*/,d=/^(data:)([^,]*),(.*)/i;function h(e,t){return(e||"").replace(m,(function(e,r,n,a,i,o){var s,c=n||i||o,l=r||a||"";if(!c)return e;if(!p.test(c))return"url("+l+c+l+")";if(d.test(c))return"url("+l+c+l+")";if("/"===c[0])return"url("+l+(((s=t).indexOf("//")>-1?s.split("/").slice(0,3).join("/"):s.split("/")[0]).split("?")[0]+c)+l+")";var u=t.split("/"),f=c.split("/");u.pop();for(var m=0,h=f;m<h.length;m++){var v=h[m];"."!==v&&(".."===v?u.pop():u.push(v))}return"url("+l+u.join("/")+l+")"}))}var v=/^[^ \t\n\r\u000c]+/,g=/^[, \t\n\r\u000c]+/;function y(e,t){if(!t||""===t.trim())return t;var r=e.createElement("a");return r.href=t,r.href}function k(){var e=document.createElement("a");return e.href="",e.href}function b(e,t,r,n){return"src"===r||"href"===r&&n||"xlink:href"===r&&n&&"#"!==n[0]?y(e,n):"background"!==r||!n||"table"!==t&&"td"!==t&&"th"!==t?"srcset"===r&&n?function(e,t){if(""===t.trim())return t;var r=0;function n(e){var n,a=e.exec(t.substring(r));return a?(n=a[0],r+=n.length,n):""}for(var a=[];n(g),!(r>=t.length);){var i=n(v);if(","===i.slice(-1))i=y(e,i.substring(0,i.length-1)),a.push(i);else{var o="";i=y(e,i);for(var s=!1;;){var c=t.charAt(r);if(""===c){a.push((i+o).trim());break}if(s)")"===c&&(s=!1);else{if(","===c){r+=1,a.push((i+o).trim());break}"("===c&&(s=!0)}o+=c,r+=1}}}return a.join(", ")}(e,n):"style"===r&&n?h(n,k()):"object"===t&&"data"===r&&n?y(e,n):n:y(e,n)}function S(e,t,r,n){if(!e)return!1;if(e.nodeType===e.ELEMENT_NODE){if(n&&(e.matches(n)||e.closest(n)))return!1;if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var a=0;a<e.classList.length;a++){var i=e.classList[a];if(t.test(i))return!0}return!(!r||!e.matches(r))||S(e.parentNode,t,r,n)}return e.nodeType,e.TEXT_NODE,S(e.parentNode,t,r,n)}function T(t,r){var s,l,f,m,p=r.doc,d=r.blockClass,v=r.blockSelector,g=r.unblockSelector,y=r.maskTextClass,T=r.maskTextSelector,C=r.unmaskTextSelector,w=r.inlineStylesheet,x=r.maskInputSelector,I=r.unmaskInputSelector,E=r.maskInputOptions,_=void 0===E?{}:E,N=r.maskTextFn,D=r.maskInputFn,L=r.dataURLOptions,O=void 0===L?{}:L,A=r.inlineImages,R=r.recordCanvas,M=r.keepIframeSrcFn;if(p.__sn){var F=p.__sn.id;l=1===F?void 0:F}switch(t.nodeType){case t.DOCUMENT_NODE:return"CSS1Compat"!==t.compatMode?{type:e.Document,childNodes:[],compatMode:t.compatMode,rootId:l}:{type:e.Document,childNodes:[],rootId:l};case t.DOCUMENT_TYPE_NODE:return{type:e.DocumentType,name:t.name,publicId:t.publicId,systemId:t.systemId,rootId:l};case t.ELEMENT_NODE:for(var U=function(e,t,r,n){if(n&&e.matches(n))return!1;if("string"==typeof t){if(e.classList.contains(t))return!0}else for(var a=0;a<e.classList.length;a++){var i=e.classList[a];if(t.test(i))return!0}return!!r&&e.matches(r)}(t,d,v,g),W=function(e){if(e instanceof HTMLFormElement)return"form";var t=e.tagName.toLowerCase().trim();return c.test(t)?"div":t}(t),j={},P=0,B=Array.from(t.attributes);P<B.length;P++){var H=B[P],G=H.name,z=H.value;j[G]=b(p,W,G,z)}if("link"===W&&w){var q=Array.from(p.styleSheets).find((function(e){return e.href===t.href})),V=null;q&&(V=u(q)),V&&(delete j.rel,delete j.href,j._cssText=h(V,q.href))}if("style"===W&&t.sheet&&!(t.innerText||t.textContent||"").trim().length)(V=u(t.sheet))&&(j._cssText=h(V,k()));if("input"===W||"textarea"===W||"select"===W){z=t.value;"radio"!==j.type&&"checkbox"!==j.type&&"submit"!==j.type&&"button"!==j.type&&z?j.value=n({input:t,type:j.type,tagName:W,value:z,maskInputSelector:x,unmaskInputSelector:I,maskInputOptions:_,maskInputFn:D}):t.checked&&(j.checked=t.checked)}if("option"===W&&(t.selected&&!_.select?j.selected=!0:delete j.selected),"canvas"===W&&R)if("2d"===t.__context)a(t)||(j.rr_dataURL=t.toDataURL(O.type,O.quality));else if(!("__context"in t)){var $=t.toDataURL(O.type,O.quality),X=document.createElement("canvas");X.width=t.width,X.height=t.height,$!==X.toDataURL(O.type,O.quality)&&(j.rr_dataURL=$)}if("img"===W&&A){i||(i=p.createElement("canvas"),o=i.getContext("2d"));var Y=t,K=Y.crossOrigin;Y.crossOrigin="anonymous";var Z=function(){try{i.width=Y.naturalWidth,i.height=Y.naturalHeight,o.drawImage(Y,0,0),j.rr_dataURL=i.toDataURL(O.type,O.quality)}catch(e){console.warn("Cannot inline img src="+Y.currentSrc+"! Error: "+e)}K?j.crossOrigin=K:delete j.crossOrigin};Y.complete&&0!==Y.naturalWidth?Z():Y.onload=Z}if("audio"!==W&&"video"!==W||(j.rr_mediaState=t.paused?"paused":"played",j.rr_mediaCurrentTime=t.currentTime),t.scrollLeft&&(j.rr_scrollLeft=t.scrollLeft),t.scrollTop&&(j.rr_scrollTop=t.scrollTop),U){var J=t.getBoundingClientRect(),Q=J.width,ee=J.height;j={class:j.class,rr_width:Q+"px",rr_height:ee+"px"}}return"iframe"!==W||M(j.src)||(t.contentDocument||(j.rr_src=j.src),delete j.src),{type:e.Element,tagName:W,attributes:j,childNodes:[],isSVG:(m=t,Boolean("svg"===m.tagName||m.ownerSVGElement)||void 0),needBlock:U,rootId:l};case t.TEXT_NODE:var te=t.parentNode&&t.parentNode.tagName,re=t.textContent,ne="STYLE"===te||void 0,ae="SCRIPT"===te||void 0;if(ne&&re){try{t.nextSibling||t.previousSibling||(null===(s=t.parentNode.sheet)||void 0===s?void 0:s.cssRules)&&(re=(f=t.parentNode.sheet).cssRules?Array.from(f.cssRules).map((function(e){return e.cssText||""})).join(""):"")}catch(e){console.warn("Cannot get CSS styles from text's parentNode. Error: "+e,t)}re=h(re,k())}return ae&&(re="SCRIPT_PLACEHOLDER"),!ne&&!ae&&S(t,y,T,C)&&re&&(re=N?N(re):re.replace(/[\S]/g,"*")),{type:e.Text,textContent:re||"",isStyle:ne,rootId:l};case t.CDATA_SECTION_NODE:return{type:e.CDATA,textContent:"",rootId:l};case t.COMMENT_NODE:return{type:e.Comment,textContent:t.textContent||"",rootId:l};default:return!1}}function C(e){return void 0===e?"":e.toLowerCase()}function w(n,a){var i,o=a.doc,c=a.map,l=a.blockClass,u=a.blockSelector,f=a.unblockSelector,m=a.maskTextClass,p=a.maskTextSelector,d=a.unmaskTextSelector,h=a.skipChild,v=void 0!==h&&h,g=a.inlineStylesheet,y=void 0===g||g,k=a.maskInputSelector,b=a.unmaskInputSelector,S=a.maskInputOptions,x=void 0===S?{}:S,I=a.maskTextFn,E=a.maskInputFn,_=a.slimDOMOptions,N=a.dataURLOptions,D=void 0===N?{}:N,L=a.inlineImages,O=void 0!==L&&L,A=a.recordCanvas,R=void 0!==A&&A,M=a.onSerialize,F=a.onIframeLoad,U=a.iframeLoadTimeout,W=void 0===U?5e3:U,j=a.keepIframeSrcFn,P=void 0===j?function(){return!1}:j,B=a.preserveWhiteSpace,H=void 0===B||B,G=T(n,{doc:o,blockClass:l,blockSelector:u,unblockSelector:f,maskTextClass:m,maskTextSelector:p,unmaskTextSelector:d,inlineStylesheet:y,maskInputSelector:k,unmaskInputSelector:b,maskInputOptions:x,maskTextFn:I,maskInputFn:E,dataURLOptions:D,inlineImages:O,recordCanvas:R,keepIframeSrcFn:P});if(!G)return console.warn(n,"not serialized"),null;i="__sn"in n?n.__sn.id:!function(t,r){if(r.comment&&t.type===e.Comment)return!0;if(t.type===e.Element){if(r.script&&("script"===t.tagName||"link"===t.tagName&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===t.tagName&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")))return!0;if(r.headFavicon&&("link"===t.tagName&&"shortcut icon"===t.attributes.rel||"meta"===t.tagName&&(C(t.attributes.name).match(/^msapplication-tile(image|color)$/)||"application-name"===C(t.attributes.name)||"icon"===C(t.attributes.rel)||"apple-touch-icon"===C(t.attributes.rel)||"shortcut icon"===C(t.attributes.rel))))return!0;if("meta"===t.tagName){if(r.headMetaDescKeywords&&C(t.attributes.name).match(/^description|keywords$/))return!0;if(r.headMetaSocial&&(C(t.attributes.property).match(/^(og|twitter|fb):/)||C(t.attributes.name).match(/^(og|twitter):/)||"pinterest"===C(t.attributes.name)))return!0;if(r.headMetaRobots&&("robots"===C(t.attributes.name)||"googlebot"===C(t.attributes.name)||"bingbot"===C(t.attributes.name)))return!0;if(r.headMetaHttpEquiv&&void 0!==t.attributes["http-equiv"])return!0;if(r.headMetaAuthorship&&("author"===C(t.attributes.name)||"generator"===C(t.attributes.name)||"framework"===C(t.attributes.name)||"publisher"===C(t.attributes.name)||"progid"===C(t.attributes.name)||C(t.attributes.property).match(/^article:/)||C(t.attributes.property).match(/^product:/)))return!0;if(r.headMetaVerification&&("google-site-verification"===C(t.attributes.name)||"yandex-verification"===C(t.attributes.name)||"csrf-token"===C(t.attributes.name)||"p:domain_verify"===C(t.attributes.name)||"verify-v1"===C(t.attributes.name)||"verification"===C(t.attributes.name)||"shopify-checkout-api-token"===C(t.attributes.name)))return!0}}return!1}(G,_)&&(H||G.type!==e.Text||G.isStyle||G.textContent.replace(/^\s+|\s+$/gm,"").length)?s++:-2;var z=Object.assign(G,{id:i});if(n.__sn=z,-2===i)return null;c[i]=n,M&&M(n);var q=!v;if(z.type===e.Element&&(q=q&&!z.needBlock,delete z.needBlock,n.shadowRoot&&(z.isShadowHost=!0)),(z.type===e.Document||z.type===e.Element)&&q){_.headWhitespace&&G.type===e.Element&&"head"===G.tagName&&(H=!1);for(var V={doc:o,map:c,blockClass:l,blockSelector:u,unblockSelector:f,maskTextClass:m,maskTextSelector:p,unmaskTextSelector:d,skipChild:v,inlineStylesheet:y,maskInputSelector:k,unmaskInputSelector:b,maskInputOptions:x,maskTextFn:I,maskInputFn:E,slimDOMOptions:_,dataURLOptions:D,inlineImages:O,recordCanvas:R,preserveWhiteSpace:H,onSerialize:M,onIframeLoad:F,iframeLoadTimeout:W,keepIframeSrcFn:P},$=0,X=Array.from(n.childNodes);$<X.length;$++){(Z=w(X[$],V))&&z.childNodes.push(Z)}if(t(n)&&n.shadowRoot)for(var Y=0,K=Array.from(n.shadowRoot.childNodes);Y<K.length;Y++){var Z;(Z=w(K[Y],V))&&(Z.isShadow=!0,z.childNodes.push(Z))}}return n.parentNode&&r(n.parentNode)&&(z.isShadow=!0),z.type===e.Element&&"iframe"===z.tagName&&function(e,t,r){var n=e.contentWindow;if(n){var a,i=!1;try{a=n.document.readyState}catch(e){return}if("complete"===a){var o="about:blank";n.location.href===o&&e.src!==o&&""!==e.src?e.addEventListener("load",t):setTimeout(t,0)}else{var s=setTimeout((function(){i||(t(),i=!0)}),r);e.addEventListener("load",(function(){clearTimeout(s),i=!0,t()}))}}}(n,(function(){var e=n.contentDocument;if(e&&F){var t=w(e,{doc:e,map:c,blockClass:l,blockSelector:u,unblockSelector:f,maskTextClass:m,maskTextSelector:p,unmaskTextSelector:d,skipChild:!1,inlineStylesheet:y,maskInputSelector:k,unmaskInputSelector:b,maskInputOptions:x,maskTextFn:I,maskInputFn:E,slimDOMOptions:_,dataURLOptions:D,inlineImages:O,recordCanvas:R,preserveWhiteSpace:H,onSerialize:M,onIframeLoad:F,iframeLoadTimeout:W,keepIframeSrcFn:P});t&&F(n,t)}}),W),z}function x(e,t){var r=t||{},n=r.blockClass,a=void 0===n?"rr-block":n,i=r.blockSelector,o=void 0===i?null:i,s=r.unblockSelector,c=void 0===s?null:s,l=r.maskTextClass,u=void 0===l?"rr-mask":l,f=r.maskTextSelector,m=void 0===f?null:f,p=r.unmaskTextSelector,d=void 0===p?null:p,h=r.inlineStylesheet,v=void 0===h||h,g=r.inlineImages,y=void 0!==g&&g,k=r.recordCanvas,b=void 0!==k&&k,S=r.maskInputSelector,T=void 0===S?null:S,C=r.unmaskInputSelector,x=void 0===C?null:C,I=r.maskAllInputs,E=void 0!==I&&I,_=r.maskTextFn,N=r.maskInputFn,D=r.slimDOM,L=void 0!==D&&D,O=r.dataURLOptions,A=r.preserveWhiteSpace,R=r.onSerialize,M=r.onIframeLoad,F=r.iframeLoadTimeout,U=r.keepIframeSrcFn,W={};return[w(e,{doc:e,map:W,blockClass:a,blockSelector:o,unblockSelector:c,maskTextClass:u,maskTextSelector:m,unmaskTextSelector:d,skipChild:!1,inlineStylesheet:v,maskInputSelector:T,unmaskInputSelector:x,maskInputOptions:!0===E?{color:!0,date:!0,"datetime-local":!0,email:!0,month:!0,number:!0,range:!0,search:!0,tel:!0,text:!0,time:!0,url:!0,week:!0,textarea:!0,select:!0,password:!0}:!1===E?{password:!0}:E,maskTextFn:_,maskInputFn:N,slimDOMOptions:!0===L||"all"===L?{script:!0,comment:!0,headFavicon:!0,headWhitespace:!0,headMetaDescKeywords:"all"===L,headMetaSocial:!0,headMetaRobots:!0,headMetaHttpEquiv:!0,headMetaAuthorship:!0,headMetaVerification:!0}:!1===L?{}:L,dataURLOptions:O,inlineImages:y,recordCanvas:b,preserveWhiteSpace:A,onSerialize:R,onIframeLoad:M,iframeLoadTimeout:F,keepIframeSrcFn:void 0===U?function(){return!1}:U}),W]}function I(t,r){!function t(n){r(n),n.type!==e.Document&&n.type!==e.Element||n.childNodes.forEach(t)}(t)}function E(){s=1}var _=/\/\*[^*]*\*+([^/*][^*]*\*+)*\//g;function N(e,t){void 0===t&&(t={});var r=1,n=1;function a(e){var t=e.match(/\n/g);t&&(r+=t.length);var a=e.lastIndexOf("\n");n=-1===a?n+e.length:e.length-a}function i(){var e={line:r,column:n};return function(t){return t.position=new o(e),p(),t}}var o=function(e){this.start=e,this.end={line:r,column:n},this.source=t.source};o.prototype.content=e;var s=[];function c(a){var i=new Error(t.source+":"+r+":"+n+": "+a);if(i.reason=a,i.filename=t.source,i.line=r,i.column=n,i.source=e,!t.silent)throw i;s.push(i)}function l(){return m(/^{\s*/)}function u(){return m(/^}/)}function f(){var t,r=[];for(p(),d(r);e.length&&"}"!==e.charAt(0)&&(t=x()||I());)!1!==t&&(r.push(t),d(r));return r}function m(t){var r=t.exec(e);if(r){var n=r[0];return a(n),e=e.slice(n.length),r}}function p(){m(/^\s*/)}function d(e){var t;for(void 0===e&&(e=[]);t=h();)!1!==t&&e.push(t),t=h();return e}function h(){var t=i();if("/"===e.charAt(0)&&"*"===e.charAt(1)){for(var r=2;""!==e.charAt(r)&&("*"!==e.charAt(r)||"/"!==e.charAt(r+1));)++r;if(r+=2,""===e.charAt(r-1))return c("End of comment missing");var o=e.slice(2,r-2);return n+=2,a(o),e=e.slice(r),n+=2,t({type:"comment",comment:o})}}function v(){var e=m(/^([^{]+)/);if(e)return D(e[0]).replace(/\/\*([^*]|[\r\n]|(\*+([^*/]|[\r\n])))*\*\/+/g,"").replace(/"(?:\\"|[^"])*"|'(?:\\'|[^'])*'/g,(function(e){return e.replace(/,/g,"‌")})).split(/\s*(?![^(]*\)),\s*/).map((function(e){return e.replace(/\u200C/g,",")}))}function g(){var e=i(),t=m(/^(\*?[-#\/\*\\\w]+(\[[0-9a-z_-]+\])?)\s*/);if(t){var r=D(t[0]);if(!m(/^:\s*/))return c("property missing ':'");var n=m(/^((?:'(?:\\'|.)*?'|"(?:\\"|.)*?"|\([^\)]*?\)|[^};])+)/),a=e({type:"declaration",property:r.replace(_,""),value:n?D(n[0]).replace(_,""):""});return m(/^[;\s]*/),a}}function y(){var e,t=[];if(!l())return c("missing '{'");for(d(t);e=g();)!1!==e&&(t.push(e),d(t)),e=g();return u()?t:c("missing '}'")}function k(){for(var e,t=[],r=i();e=m(/^((\d+\.\d+|\.\d+|\d+)%?|[a-z]+)\s*/);)t.push(e[1]),m(/^,\s*/);if(t.length)return r({type:"keyframe",values:t,declarations:y()})}var b,S=w("import"),T=w("charset"),C=w("namespace");function w(e){var t=new RegExp("^@"+e+"\\s*([^;]+);");return function(){var r=i(),n=m(t);if(n){var a={type:e};return a[e]=n[1].trim(),r(a)}}}function x(){if("@"===e[0])return function(){var e=i(),t=m(/^@([-\w]+)?keyframes\s*/);if(t){var r=t[1];if(!(t=m(/^([-\w]+)\s*/)))return c("@keyframes missing name");var n,a=t[1];if(!l())return c("@keyframes missing '{'");for(var o=d();n=k();)o.push(n),o=o.concat(d());return u()?e({type:"keyframes",name:a,vendor:r,keyframes:o}):c("@keyframes missing '}'")}}()||function(){var e=i(),t=m(/^@media *([^{]+)/);if(t){var r=D(t[1]);if(!l())return c("@media missing '{'");var n=d().concat(f());return u()?e({type:"media",media:r,rules:n}):c("@media missing '}'")}}()||function(){var e=i(),t=m(/^@custom-media\s+(--[^\s]+)\s*([^{;]+);/);if(t)return e({type:"custom-media",name:D(t[1]),media:D(t[2])})}()||function(){var e=i(),t=m(/^@supports *([^{]+)/);if(t){var r=D(t[1]);if(!l())return c("@supports missing '{'");var n=d().concat(f());return u()?e({type:"supports",supports:r,rules:n}):c("@supports missing '}'")}}()||S()||T()||C()||function(){var e=i(),t=m(/^@([-\w]+)?document *([^{]+)/);if(t){var r=D(t[1]),n=D(t[2]);if(!l())return c("@document missing '{'");var a=d().concat(f());return u()?e({type:"document",document:n,vendor:r,rules:a}):c("@document missing '}'")}}()||function(){var e=i();if(m(/^@page */)){var t=v()||[];if(!l())return c("@page missing '{'");for(var r,n=d();r=g();)n.push(r),n=n.concat(d());return u()?e({type:"page",selectors:t,declarations:n}):c("@page missing '}'")}}()||function(){var e=i();if(m(/^@host\s*/)){if(!l())return c("@host missing '{'");var t=d().concat(f());return u()?e({type:"host",rules:t}):c("@host missing '}'")}}()||function(){var e=i();if(m(/^@font-face\s*/)){if(!l())return c("@font-face missing '{'");for(var t,r=d();t=g();)r.push(t),r=r.concat(d());return u()?e({type:"font-face",declarations:r}):c("@font-face missing '}'")}}()}function I(){var e=i(),t=v();return t?(d(),e({type:"rule",selectors:t,declarations:y()})):c("selector missing")}return L((b=f(),{type:"stylesheet",stylesheet:{source:t.source,rules:b,parsingErrors:s}}))}function D(e){return e?e.replace(/^\s+|\s+$/g,""):""}function L(e,t){for(var r=e&&"string"==typeof e.type,n=r?e:t,a=0,i=Object.keys(e);a<i.length;a++){var o=e[i[a]];Array.isArray(o)?o.forEach((function(e){L(e,n)})):o&&"object"==typeof o&&L(o,n)}return r&&Object.defineProperty(e,"parent",{configurable:!0,writable:!0,enumerable:!1,value:t||null}),e}var O={script:"noscript",altglyph:"altGlyph",altglyphdef:"altGlyphDef",altglyphitem:"altGlyphItem",animatecolor:"animateColor",animatemotion:"animateMotion",animatetransform:"animateTransform",clippath:"clipPath",feblend:"feBlend",fecolormatrix:"feColorMatrix",fecomponenttransfer:"feComponentTransfer",fecomposite:"feComposite",feconvolvematrix:"feConvolveMatrix",fediffuselighting:"feDiffuseLighting",fedisplacementmap:"feDisplacementMap",fedistantlight:"feDistantLight",fedropshadow:"feDropShadow",feflood:"feFlood",fefunca:"feFuncA",fefuncb:"feFuncB",fefuncg:"feFuncG",fefuncr:"feFuncR",fegaussianblur:"feGaussianBlur",feimage:"feImage",femerge:"feMerge",femergenode:"feMergeNode",femorphology:"feMorphology",feoffset:"feOffset",fepointlight:"fePointLight",fespecularlighting:"feSpecularLighting",fespotlight:"feSpotLight",fetile:"feTile",feturbulence:"feTurbulence",foreignobject:"foreignObject",glyphref:"glyphRef",lineargradient:"linearGradient",radialgradient:"radialGradient"};var A=/([^\\]):hover/,R=new RegExp(A.source,"g");function M(e,t){var r=null==t?void 0:t.stylesWithHoverClass.get(e);if(r)return r;var n=N(e,{silent:!0});if(!n.stylesheet)return e;var a=[];if(n.stylesheet.rules.forEach((function(e){"selectors"in e&&(e.selectors||[]).forEach((function(e){A.test(e)&&a.push(e)}))})),0===a.length)return e;var i=new RegExp(a.filter((function(e,t){return a.indexOf(e)===t})).sort((function(e,t){return t.length-e.length})).map((function(e){return e.replace(/[.*+?^${}()|[\]\\]/g,"\\$&")})).join("|"),"g"),o=e.replace(i,(function(e){var t=e.replace(R,"$1.\\:hover");return e+", "+t}));return null==t||t.stylesWithHoverClass.set(e,o),o}function F(){return{stylesWithHoverClass:new Map}}function U(t,r){var n=r.doc,a=r.hackCss,i=r.cache;switch(t.type){case e.Document:return n.implementation.createDocument(null,"",null);case e.DocumentType:return n.implementation.createDocumentType(t.name||"html",t.publicId,t.systemId);case e.Element:var o,s=function(e){var t=O[e.tagName]?O[e.tagName]:e.tagName;return"link"===t&&e.attributes._cssText&&(t="style"),t}(t);o=t.isSVG?n.createElementNS("http://www.w3.org/2000/svg",s):n.createElement(s);var c=function(e){if(!t.attributes.hasOwnProperty(e))return"continue";var r=t.attributes[e];if("option"===s&&"selected"===e&&!1===r)return"continue";if(r="boolean"==typeof r||"number"==typeof r?"":r,e.startsWith("rr_")){if("canvas"===s&&"rr_dataURL"===e){var c=document.createElement("img");c.src=r,c.onload=function(){var e=o.getContext("2d");e&&e.drawImage(c,0,0,c.width,c.height)}}else if("img"===s&&"rr_dataURL"===e){var l=o;l.currentSrc.startsWith("data:")||(l.setAttribute("rrweb-original-src",t.attributes.src),l.src=r)}if("rr_width"===e)o.style.width=r;else if("rr_height"===e)o.style.height=r;else if("rr_mediaCurrentTime"===e)o.currentTime=t.attributes.rr_mediaCurrentTime;else if("rr_mediaState"===e)switch(r){case"played":o.play().catch((function(e){return console.warn("media playback error",e)}));break;case"paused":o.pause()}}else{var u="textarea"===s&&"value"===e,f="style"===s&&"_cssText"===e;if(f&&a&&(r=M(r,i)),u||f){for(var m=n.createTextNode(r),p=0,d=Array.from(o.childNodes);p<d.length;p++){var h=d[p];h.nodeType===o.TEXT_NODE&&o.removeChild(h)}return o.appendChild(m),"continue"}try{if(t.isSVG&&"xlink:href"===e)o.setAttributeNS("http://www.w3.org/1999/xlink",e,r);else if("onload"===e||"onclick"===e||"onmouse"===e.substring(0,7))o.setAttribute("_"+e,r);else{if("meta"===s&&"Content-Security-Policy"===t.attributes["http-equiv"]&&"content"===e)return o.setAttribute("csp-content",r),"continue";"link"===s&&"preload"===t.attributes.rel&&"script"===t.attributes.as||"link"===s&&"prefetch"===t.attributes.rel&&"string"==typeof t.attributes.href&&t.attributes.href.endsWith(".js")||("img"===s&&t.attributes.srcset&&t.attributes.rr_dataURL?o.setAttribute("rrweb-original-srcset",t.attributes.srcset):o.setAttribute(e,r))}}catch(e){}}};for(var l in t.attributes)c(l);if(t.isShadowHost)if(o.shadowRoot)for(;o.shadowRoot.firstChild;)o.shadowRoot.removeChild(o.shadowRoot.firstChild);else o.attachShadow({mode:"open"});return o;case e.Text:return n.createTextNode(t.isStyle&&a?M(t.textContent,i):t.textContent);case e.CDATA:return n.createCDATASection(t.textContent);case e.Comment:return n.createComment(t.textContent);default:return null}}function W(r,n){var a=n.doc,i=n.map,o=n.skipChild,s=void 0!==o&&o,c=n.hackCss,l=void 0===c||c,u=n.afterAppend,f=n.cache,m=U(r,{doc:a,hackCss:l,cache:f});if(!m)return null;if(r.rootId&&console.assert(i[r.rootId]===a,"Target document should has the same root id."),r.type===e.Document&&(a.close(),a.open(),"BackCompat"===r.compatMode&&r.childNodes&&r.childNodes[0].type!==e.DocumentType&&(r.childNodes[0].type===e.Element&&"xmlns"in r.childNodes[0].attributes&&"http://www.w3.org/1999/xhtml"===r.childNodes[0].attributes.xmlns?a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "">'):a.write('<!DOCTYPE html PUBLIC "-//W3C//DTD HTML 4.0 Transitional//EN" "">')),m=a),m.__sn=r,i[r.id]=m,(r.type===e.Document||r.type===e.Element)&&!s)for(var p=0,d=r.childNodes;p<d.length;p++){var h=d[p],v=W(h,{doc:a,map:i,skipChild:!1,hackCss:l,afterAppend:u,cache:f});v?(h.isShadow&&t(m)&&m.shadowRoot?m.shadowRoot.appendChild(v):m.appendChild(v),u&&u(v)):console.warn("Failed to rebuild",h)}return m}function j(t,r){var n=r.doc,a=r.onVisit,i=r.hackCss,o={},s=W(t,{doc:n,map:o,skipChild:!1,hackCss:void 0===i||i,afterAppend:r.afterAppend,cache:r.cache});return function(e,t){for(var r in e)e[r]&&(n=e[r],t(n));var n}(o,(function(t){a&&a(t),function(t){var r=t.__sn;if(r.type===e.Element){var n=t;for(var a in r.attributes)if(r.attributes.hasOwnProperty(a)&&a.startsWith("rr_")){var i=r.attributes[a];"rr_scrollLeft"===a&&(n.scrollLeft=i),"rr_scrollTop"===a&&(n.scrollTop=i)}}}(t)})),[s,o]}export{l as IGNORED_NODE,e as NodeType,M as addHoverClass,W as buildNodeWithSN,E as cleanupSnapshot,F as createCache,a as is2DCanvasBlank,t as isElement,r as isShadowRoot,n as maskInputValue,S as needMaskingText,j as rebuild,w as serializeNodeWithId,x as snapshot,b as transformAttribute,I as visitSnapshot};
 //# sourceMappingURL=rrweb-snapshot.min.js.map
diff --git a/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js.map b/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js.map
old mode 100644
new mode 100755
index 5781795..6b2c7b4
--- a/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js.map
+++ b/node_modules/rrweb-snapshot/es/rrweb-snapshot.min.js.map
@@ -1 +1 @@
-{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/utils.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n  compatMode?: string;\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport interface ICanvas extends HTMLCanvasElement {\n  __context: string;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type DataURLOptions = Partial<{\n  type: string;\n  quality: number;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\nexport type MaskInputFn = (text: string) => string;\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\nexport type BuildCache = {\n  stylesWithHoverClass: Map<string, string>;\n};\n","import { INode, MaskInputFn, MaskInputOptions } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n\nexport function maskInputValue({\n  maskInputOptions,\n  tagName,\n  type,\n  value,\n  maskInputFn,\n}: {\n  maskInputOptions: MaskInputOptions;\n  tagName: string;\n  type: string | number | boolean | null;\n  value: string | null;\n  maskInputFn?: MaskInputFn;\n}): string {\n  let text = value || '';\n  if (\n    maskInputOptions[tagName.toLowerCase() as keyof MaskInputOptions] ||\n    maskInputOptions[type as keyof MaskInputOptions]\n  ) {\n    if (maskInputFn) {\n      text = maskInputFn(text);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n  return text;\n}\n\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\ntype PatchedGetImageData = {\n  [ORIGINAL_ATTRIBUTE_NAME]: CanvasImageData['getImageData'];\n} & CanvasImageData['getImageData'];\n\nexport function is2DCanvasBlank(canvas: HTMLCanvasElement): boolean {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n\n  const chunkSize = 50;\n\n  // get chunks of the canvas and check if it is blank\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData as PatchedGetImageData;\n      const originalGetImageData =\n        ORIGINAL_ATTRIBUTE_NAME in getImageData\n          ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\n          : getImageData;\n      // by getting the canvas in chunks we avoid an expensive\n      // `getImageData` call that retrieves everything\n      // even if we can already tell from the first chunk(s) that\n      // the canvas isn't blank\n      const pixelBuffer = new Uint32Array(\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y),\n        ).data.buffer,\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  DataURLOptions,\n  MaskTextFn,\n  MaskInputFn,\n  KeepIframeSrcFn,\n  ICanvas,\n} from './types';\nimport {\n  is2DCanvasBlank,\n  isElement,\n  isShadowRoot,\n  maskInputValue,\n} from './utils';\n\nlet _id = 1;\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  let cssStringified = rule.cssText;\n  if (isCSSImportRule(rule)) {\n    try {\n      cssStringified = getCssRulesString(rule.styleSheet) || cssStringified;\n    } catch {\n      // ignore\n    }\n  }\n  return cssStringified;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction stringifyStyleSheet(sheet: CSSStyleSheet): string {\n  return sheet.cssRules\n    ? Array.from(sheet.cssRules)\n        .map((rule) => rule.cssText || '')\n        .join('')\n    : '';\n}\n\nfunction extractOrigin(url: string): string {\n  let origin = '';\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nlet canvasService: HTMLCanvasElement | null;\nlet canvasCtx: CanvasRenderingContext2D | null;\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    let chars: string;\n    let match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return Boolean(el.tagName === 'svg' || (el as SVGElement).ownerSVGElement);\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || (name === 'href' && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value && value[0] !== '#') {\n    // xlink:href starts with # is an id pointer\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else if (tagName === 'object' && name === 'data' && value) {\n    return absoluteToDoc(doc, value);\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n): boolean {\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      // tslint:disable-next-line: prefer-for-of\n      for (\n        let eIndex = 0;\n        eIndex < (node as HTMLElement).classList.length;\n        eIndex++\n      ) {\n        const className = (node as HTMLElement).classList[eIndex];\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    // iframe was already loaded, make sure we wait to trigger the listener\n    // till _after_ the mutation that found this iframe has had time to process\n    setTimeout(listener, 0);\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if ((n as HTMLDocument).compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: (n as HTMLDocument).compatMode, // probably \"BackCompat\"\n          rootId,\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          rootId,\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        let cssText: string | null = null;\n        if (stylesheet) {\n          cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        }\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value = maskInputValue({\n            type: attributes.type,\n            tagName,\n            value,\n            maskInputOptions,\n            maskInputFn,\n          });\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        if ((n as HTMLOptionElement).selected && !maskInputOptions['select']) {\n          attributes.selected = true;\n        } else {\n          // ignore the html attribute (which corresponds to DOM (n as HTMLOptionElement).defaultSelected)\n          // if it's already been changed\n          delete attributes.selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        if ((n as ICanvas).__context === '2d') {\n          // only record this on 2d canvas\n          if (!is2DCanvasBlank(n as HTMLCanvasElement)) {\n            attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          }\n        } else if (!('__context' in n)) {\n          // context is unknown, better not call getContext to trigger it\n          const canvasDataURL = (n as HTMLCanvasElement).toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // create blank canvas of same dimensions\n          const blankCanvas = document.createElement('canvas');\n          blankCanvas.width = (n as HTMLCanvasElement).width;\n          blankCanvas.height = (n as HTMLCanvasElement).height;\n          const blankCanvasDataURL = blankCanvas.toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // no need to save dataURL if it's the same as blank canvas\n          if (canvasDataURL !== blankCanvasDataURL) {\n            attributes.rr_dataURL = canvasDataURL;\n          }\n        }\n      }\n      // save image offline\n      if (tagName === 'img' && inlineImages) {\n        if (!canvasService) {\n          canvasService = doc.createElement('canvas');\n          canvasCtx = canvasService.getContext('2d');\n        }\n        const image = n as HTMLImageElement;\n        const oldValue = image.crossOrigin;\n        image.crossOrigin = 'anonymous';\n        const recordInlineImage = () => {\n          try {\n            canvasService!.width = image.naturalWidth;\n            canvasService!.height = image.naturalHeight;\n            canvasCtx!.drawImage(image, 0, 0);\n            attributes.rr_dataURL = canvasService!.toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          } catch (err) {\n            console.warn(\n              `Cannot inline img src=${image.currentSrc}! Error: ${err}`,\n            );\n          }\n          oldValue\n            ? (attributes.crossOrigin = oldValue)\n            : delete attributes.crossOrigin;\n        };\n        // The image content may not have finished loading yet.\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.onload = recordInlineImage;\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n        attributes.rr_mediaCurrentTime = (n as HTMLMediaElement).currentTime;\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src as string)) {\n        if (!(n as HTMLIFrameElement).contentDocument) {\n          // we can't record it directly as we can't see into it\n          // preserve the src attribute so a decision can be taken at replay time\n          attributes.rr_src = attributes.src;\n        }\n        delete attributes.src; // prevent auto loading\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        try {\n          // try to read style sheet\n          if (n.nextSibling || n.previousSibling) {\n            // This is not the only child of the stylesheet.\n            // We can't read all of the sheet's .cssRules and expect them\n            // to _only_ include the current rule(s) added by the text node.\n            // So we'll be conservative and keep textContent as-is.\n          } else if ((n.parentNode as HTMLStyleElement).sheet?.cssRules) {\n            textContent = stringifyStyleSheet(\n              (n.parentNode as HTMLStyleElement).sheet!,\n            );\n          }\n        } catch (err) {\n          console.warn(\n            `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n            n,\n          );\n        }\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      // script tag\n      (sn.tagName === 'script' ||\n        // preload link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script') ||\n        // prefetch link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'prefetch' &&\n          typeof sn.attributes.href === 'string' &&\n          sn.attributes.href.endsWith('.js')))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    maskTextClass,\n    maskTextSelector,\n    inlineStylesheet,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n    if ((n as HTMLElement).shadowRoot) serializedNode.isShadowHost = true;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            maskTextClass,\n            maskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    maskInputFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskAllInputs = false,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    keepIframeSrcFn = () => false,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      maskTextClass,\n      maskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n\n/* tslint:disable no-conditional-assignment interface-name no-shadowed-variable */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends Node {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport interface Host extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each “selector” is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends Node {\n  /** The part following @media. */\n  media?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends Node {\n  /** The part following @supports. */\n  supports?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules {\n  source?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}) {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    let i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.prototype.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    return trim(m[0])\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      })\n      .split(/\\s*(?![^(]*\\)),\\s*/)\n      .map((s) => {\n        return s.replace(/\\u200C/g, ',');\n      });\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    let propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet) {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent((value as unknown) as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { parse } from './css';\nimport {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n  BuildCache,\n} from './types';\nimport { isElement } from './utils';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nfunction escapeRegExp(str: string) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\nexport function addHoverClass(cssText: string, cache: BuildCache): string {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n\n  const ast = parse(cssText, {\n    silent: true,\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  const selectors: string[] = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n\n  if (selectors.length === 0) {\n    return cssText;\n  }\n\n  const selectorMatcher = new RegExp(\n    selectors\n      .filter((selector, index) => selectors.indexOf(selector) === index)\n      .sort((a, b) => b.length - a.length)\n      .map((selector) => {\n        return escapeRegExp(selector);\n      })\n      .join('|'),\n    'g',\n  );\n\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nexport function createCache(): BuildCache {\n  const stylesWithHoverClass: Map<string, string> = new Map();\n  return {\n    stylesWithHoverClass,\n  };\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n    cache: BuildCache;\n  },\n): Node | null {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        if (!n.attributes.hasOwnProperty(name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (tagName === 'option' && name === 'selected' && value === false) {\n          // legacy fix (TODO: if `value === false` can be generated for other attrs, should we also omit those other attrs from build?)\n          continue;\n        }\n        value =\n          typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (!name.startsWith('rr_')) {\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss && hackCss) {\n            value = addHoverClass(value, cache);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            // https://github.com/rrweb-io/rrweb/issues/112\n            for (const c of Array.from(node.childNodes)) {\n              if (c.nodeType === node.TEXT_NODE) {\n                node.removeChild(c);\n              }\n            }\n            node.appendChild(child);\n            continue;\n          }\n\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else if (\n              name === 'onload' ||\n              name === 'onclick' ||\n              name.substring(0, 7) === 'onmouse'\n            ) {\n              // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n              // as setting them triggers a console.error (which shows up despite the try/catch)\n              // Assumption: these attributes are not used to css\n              node.setAttribute('_' + name, value);\n            } else if (\n              tagName === 'meta' &&\n              n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n              name === 'content'\n            ) {\n              // If CSP contains style-src and inline-style is disabled, there will be an error \"Refused to apply inline style because it violates the following Content Security Policy directive: style-src '*'\".\n              // And the function insertStyleRules in rrweb replayer will throw an error \"Uncaught TypeError: Cannot read property 'insertRule' of null\".\n              node.setAttribute('csp-content', value);\n              continue;\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'preload' &&\n              n.attributes.as === 'script'\n            ) {\n              // ignore\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'prefetch' &&\n              typeof n.attributes.href === 'string' &&\n              n.attributes.href.endsWith('.js')\n            ) {\n              // ignore\n            } else if (\n              tagName === 'img' &&\n              n.attributes.srcset &&\n              n.attributes.rr_dataURL\n            ) {\n              // backup original img srcset\n              node.setAttribute('rrweb-original-srcset', n.attributes.srcset as string);\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (tagName === 'canvas' && name === 'rr_dataURL') {\n            const image = document.createElement('img');\n            image.src = value;\n            image.onload = () => {\n              const ctx = (node as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n          } else if (tagName === 'img' && name === 'rr_dataURL') {\n            const image = node as HTMLImageElement;\n            if (!image.currentSrc.startsWith('data:')) {\n              // Backup original img src. It may not have been set yet.\n              image.setAttribute(\n                'rrweb-original-src',\n                n.attributes.src as string,\n              );\n              image.src = value;\n            }\n          }\n\n          if (name === 'rr_width') {\n            (node as HTMLElement).style.width = value;\n          } else if (name === 'rr_height') {\n            (node as HTMLElement).style.height = value;\n          } else if (name === 'rr_mediaCurrentTime') {\n            (node as HTMLMediaElement).currentTime = n.attributes\n              .rr_mediaCurrentTime as number;\n          } else if (name === 'rr_mediaState') {\n            switch (value) {\n              case 'played':\n                (node as HTMLMediaElement)\n                  .play()\n                  .catch((e) => console.warn('media playback error', e));\n                break;\n              case 'paused':\n                (node as HTMLMediaElement).pause();\n                break;\n              default:\n            }\n          }\n        }\n      }\n\n      if (n.isShadowHost) {\n        /**\n         * Since node is newly rebuilt, it should be a normal element\n         * without shadowRoot.\n         * But if there are some weird situations that has defined\n         * custom element in the scope before we rebuild node, it may\n         * register the shadowRoot earlier.\n         * The logic in the 'else' block is just a try-my-best solution\n         * for the corner case, please let we know if it is wrong and\n         * we can remove it.\n         */\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: 'open' });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss\n          ? addHoverClass(n.textContent, cache)\n          : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    skipChild?: boolean;\n    hackCss: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): INode | null {\n  const {\n    doc,\n    map,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache,\n  } = options;\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n.rootId) {\n    console.assert(\n      ((map[n.rootId] as unknown) as Document) === doc,\n      'Target document should has the same root id.',\n    );\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    if (\n      n.compatMode === 'BackCompat' &&\n      n.childNodes &&\n      n.childNodes[0].type !== NodeType.DocumentType // there isn't one already defined\n    ) {\n      // Trigger compatMode in the iframe\n      // this is needed as document.createElement('iframe') otherwise inherits a CSS1Compat mode from the parent replayer environment\n      if (\n        n.childNodes[0].type === NodeType.Element &&\n        'xmlns' in n.childNodes[0].attributes &&\n        n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml'\n      ) {\n        // might as well use an xhtml doctype if we've got an xhtml namespace\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">',\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">',\n        );\n      }\n    }\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        map,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode);\n      }\n    }\n  }\n\n  return node as INode;\n}\n\nfunction visit(idNodeMap: idNodeMap, onVisit: (node: INode) => void) {\n  function walk(node: INode) {\n    onVisit(node);\n  }\n\n  for (const key in idNodeMap) {\n    if (idNodeMap[key]) {\n      walk(idNodeMap[key]);\n    }\n  }\n}\n\nfunction handleScroll(node: INode) {\n  const n = node.__sn;\n  if (n.type !== NodeType.Element) {\n    return;\n  }\n  const el = (node as Node) as HTMLElement;\n  for (const name in n.attributes) {\n    if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: INode) => unknown;\n    hackCss?: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): [Node | null, idNodeMap] {\n  const { doc, onVisit, hackCss = true, afterAppend, cache } = options;\n  const idNodeMap: idNodeMap = {};\n  const node = buildNodeWithSN(n, {\n    doc,\n    map: idNodeMap,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache,\n  });\n  visit(idNodeMap, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode);\n  });\n  return [node, idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","isElement","n","nodeType","ELEMENT_NODE","isShadowRoot","host","Boolean","shadowRoot","maskInputValue","_a","maskInputOptions","tagName","type","value","maskInputFn","text","toLowerCase","repeat","length","is2DCanvasBlank","canvas","ctx","getContext","x","width","y","height","getImageData","originalGetImageData","Uint32Array","call","Math","min","data","buffer","some","pixel","canvasService","canvasCtx","_id","tagNameRegex","RegExp","IGNORED_NODE","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","cssStringified","cssText","isCSSImportRule","styleSheet","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","slice","stack","parts","pop","parts_1","_i","part","push","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","document","transformAttribute","name","pos","collectCharacters","regEx","chars","match","exec","substring","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","classList","contains","eIndex","className","matches","parentNode","TEXT_NODE","serializeNode","options","rootId","sheet","el","blockClass","blockSelector","inlineStylesheet","_b","maskTextFn","_c","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","__sn","docId","id","undefined","DOCUMENT_NODE","compatMode","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes_1","_d","attributes","_e","name_1","stylesheet","styleSheets","find","rel","_cssText","innerText","textContent","checked","selected","__context","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","image_1","oldValue_1","crossOrigin","recordInlineImage","naturalWidth","naturalHeight","drawImage","err","console","warn","currentSrc","complete","onload","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_f","getBoundingClientRect","class","rr_width","rr_height","src","contentDocument","rr_src","Element","isSVG","ownerSVGElement","parentTagName","isStyle","isScript","nextSibling","previousSibling","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","serializeNodeWithId","skipChild","slimDOMOptions","onSerialize","onIframeLoad","_g","iframeLoadTimeout","_h","_j","preserveWhiteSpace","_serializedNode","sn","comment","script","as","endsWith","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","isShadowHost","headWhitespace","bypassOptions","_k","serializedChildNode","_m","_l","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","setTimeout","timer_1","clearTimeout","onceIframeLoaded","iframeDoc","serializedIframeNode","snapshot","maskAllInputs","slimDOM","idNodeMap","color","date","email","month","number","range","search","tel","time","week","textarea","select","password","visitSnapshot","onVisit","walk","current","forEach","cleanupSnapshot","commentre","parse","css","lineno","column","updatePosition","str","lines","i","lastIndexOf","position","start","line","Position","whitespace","this","end","source","prototype","content","errorsList","msg","Error","reason","filename","silent","open","close","comments","atrule","re","m","selector","declaration","propMatch","prop","val","ret","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","vendor","frame","frames","concat","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","atdocument","sel","selectors","atpage","athost","atfontface","addParent","parsingErrors","obj","parent","isNode","childParent","keys","isArray","v","defineProperty","configurable","writable","enumerable","tagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","HOVER_SELECTOR","HOVER_SELECTOR_GLOBAL","addHoverClass","cache","cachedStyle","stylesWithHoverClass","get","ast","selectorMatcher","filter","index","sort","b","result","newSelector","set","createCache","Map","buildNode","hackCss","implementation","createDocument","createDocumentType","node_1","getTagName","createElementNS","hasOwnProperty","startsWith","image","setAttribute","play","e","pause","isTextarea","isRemoteOrDynamicCss","child","createTextNode","removeChild","appendChild","setAttributeNS","srcset","firstChild","attachShadow","mode","createCDATASection","createComment","buildNodeWithSN","afterAppend","assert","xmlns","write","childN","childNode","rebuild","key","visit","visitedNode","name_2","handleScroll"],"mappings":"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"}
\ No newline at end of file
+{"version":3,"file":"rrweb-snapshot.min.js","sources":["../src/types.ts","../src/utils.ts","../src/snapshot.ts","../src/css.ts","../src/rebuild.ts"],"sourcesContent":["export enum NodeType {\n  Document,\n  DocumentType,\n  Element,\n  Text,\n  CDATA,\n  Comment,\n}\n\nexport type documentNode = {\n  type: NodeType.Document;\n  childNodes: serializedNodeWithId[];\n  compatMode?: string;\n};\n\nexport type documentTypeNode = {\n  type: NodeType.DocumentType;\n  name: string;\n  publicId: string;\n  systemId: string;\n};\n\nexport type attributes = {\n  [key: string]: string | number | boolean;\n};\nexport type elementNode = {\n  type: NodeType.Element;\n  tagName: string;\n  attributes: attributes;\n  childNodes: serializedNodeWithId[];\n  isSVG?: true;\n  needBlock?: boolean;\n};\n\nexport type textNode = {\n  type: NodeType.Text;\n  textContent: string;\n  isStyle?: true;\n};\n\nexport type cdataNode = {\n  type: NodeType.CDATA;\n  textContent: '';\n};\n\nexport type commentNode = {\n  type: NodeType.Comment;\n  textContent: string;\n};\n\nexport type serializedNode = (\n  | documentNode\n  | documentTypeNode\n  | elementNode\n  | textNode\n  | cdataNode\n  | commentNode\n) & {\n  rootId?: number;\n  isShadowHost?: boolean;\n  isShadow?: boolean;\n};\n\nexport type serializedNodeWithId = serializedNode & { id: number };\n\nexport type tagMap = {\n  [key: string]: string;\n};\n\nexport interface INode extends Node {\n  __sn: serializedNodeWithId;\n}\n\nexport interface ICanvas extends HTMLCanvasElement {\n  __context: string;\n}\n\nexport type idNodeMap = {\n  [key: number]: INode;\n};\n\nexport type MaskInputOptions = Partial<{\n  color: boolean;\n  date: boolean;\n  'datetime-local': boolean;\n  email: boolean;\n  month: boolean;\n  number: boolean;\n  range: boolean;\n  search: boolean;\n  tel: boolean;\n  text: boolean;\n  time: boolean;\n  url: boolean;\n  week: boolean;\n  // unify textarea and select element with text input\n  textarea: boolean;\n  select: boolean;\n  password: boolean;\n}>;\n\nexport type SlimDOMOptions = Partial<{\n  script: boolean;\n  comment: boolean;\n  headFavicon: boolean;\n  headWhitespace: boolean;\n  headMetaDescKeywords: boolean;\n  headMetaSocial: boolean;\n  headMetaRobots: boolean;\n  headMetaHttpEquiv: boolean;\n  headMetaAuthorship: boolean;\n  headMetaVerification: boolean;\n}>;\n\nexport type DataURLOptions = Partial<{\n  type: string;\n  quality: number;\n}>;\n\nexport type MaskTextFn = (text: string) => string;\nexport type MaskInputFn = (text: string) => string;\n\nexport type KeepIframeSrcFn = (src: string) => boolean;\n\nexport type BuildCache = {\n  stylesWithHoverClass: Map<string, string>;\n};\n","import { INode, MaskInputFn, MaskInputOptions } from './types';\n\nexport function isElement(n: Node | INode): n is Element {\n  return n.nodeType === n.ELEMENT_NODE;\n}\n\nexport function isShadowRoot(n: Node): n is ShadowRoot {\n  const host: Element | null = (n as ShadowRoot)?.host;\n  return Boolean(host && host.shadowRoot && host.shadowRoot === n);\n}\n\nexport function maskInputValue({\n  input,\n  maskInputSelector,\n  unmaskInputSelector,\n  maskInputOptions,\n  tagName,\n  type,\n  value,\n  maskInputFn,\n}: {\n  input: HTMLElement;\n  maskInputSelector: string|null;\n  unmaskInputSelector: string|null;\n  maskInputOptions: MaskInputOptions;\n  tagName: string;\n  type: string | number | boolean | null;\n  value: string | null;\n  maskInputFn?: MaskInputFn;\n}): string {\n  let text = value || '';\n\n  if (unmaskInputSelector && input.matches(unmaskInputSelector)) {\n    return text;\n  }\n\n  if (\n    maskInputOptions[tagName.toLowerCase() as keyof MaskInputOptions] ||\n    maskInputOptions[type as keyof MaskInputOptions] ||\n    (maskInputSelector && input.matches(maskInputSelector))\n  ) {\n    if (maskInputFn) {\n      text = maskInputFn(text);\n    } else {\n      text = '*'.repeat(text.length);\n    }\n  }\n  return text;\n}\n\nconst ORIGINAL_ATTRIBUTE_NAME = '__rrweb_original__';\ntype PatchedGetImageData = {\n  [ORIGINAL_ATTRIBUTE_NAME]: CanvasImageData['getImageData'];\n} & CanvasImageData['getImageData'];\n\nexport function is2DCanvasBlank(canvas: HTMLCanvasElement): boolean {\n  const ctx = canvas.getContext('2d');\n  if (!ctx) return true;\n\n  const chunkSize = 50;\n\n  // get chunks of the canvas and check if it is blank\n  for (let x = 0; x < canvas.width; x += chunkSize) {\n    for (let y = 0; y < canvas.height; y += chunkSize) {\n      const getImageData = ctx.getImageData as PatchedGetImageData;\n      const originalGetImageData =\n        ORIGINAL_ATTRIBUTE_NAME in getImageData\n          ? getImageData[ORIGINAL_ATTRIBUTE_NAME]\n          : getImageData;\n      // by getting the canvas in chunks we avoid an expensive\n      // `getImageData` call that retrieves everything\n      // even if we can already tell from the first chunk(s) that\n      // the canvas isn't blank\n      const pixelBuffer = new Uint32Array(\n        originalGetImageData.call(\n          ctx,\n          x,\n          y,\n          Math.min(chunkSize, canvas.width - x),\n          Math.min(chunkSize, canvas.height - y),\n        ).data.buffer,\n      );\n      if (pixelBuffer.some((pixel) => pixel !== 0)) return false;\n    }\n  }\n  return true;\n}\n","import {\n  serializedNode,\n  serializedNodeWithId,\n  NodeType,\n  attributes,\n  INode,\n  idNodeMap,\n  MaskInputOptions,\n  SlimDOMOptions,\n  DataURLOptions,\n  MaskTextFn,\n  MaskInputFn,\n  KeepIframeSrcFn,\n  ICanvas,\n} from './types';\nimport {\n  is2DCanvasBlank,\n  isElement,\n  isShadowRoot,\n  maskInputValue,\n} from './utils';\n\nlet _id = 1;\nconst tagNameRegex = new RegExp('[^a-z0-9-_:]');\n\nexport const IGNORED_NODE = -2;\n\nfunction genId(): number {\n  return _id++;\n}\n\nfunction getValidTagName(element: HTMLElement): string {\n  if (element instanceof HTMLFormElement) {\n    return 'form';\n  }\n\n  const processedTagName = element.tagName.toLowerCase().trim();\n\n  if (tagNameRegex.test(processedTagName)) {\n    // if the tag name is odd and we cannot extract\n    // anything from the string, then we return a\n    // generic div\n    return 'div';\n  }\n\n  return processedTagName;\n}\n\nfunction getCssRulesString(s: CSSStyleSheet): string | null {\n  try {\n    const rules = s.rules || s.cssRules;\n    return rules ? Array.from(rules).map(getCssRuleString).join('') : null;\n  } catch (error) {\n    return null;\n  }\n}\n\nfunction getCssRuleString(rule: CSSRule): string {\n  let cssStringified = rule.cssText;\n  if (isCSSImportRule(rule)) {\n    try {\n      cssStringified = getCssRulesString(rule.styleSheet) || cssStringified;\n    } catch {\n      // ignore\n    }\n  }\n  return cssStringified;\n}\n\nfunction isCSSImportRule(rule: CSSRule): rule is CSSImportRule {\n  return 'styleSheet' in rule;\n}\n\nfunction stringifyStyleSheet(sheet: CSSStyleSheet): string {\n  return sheet.cssRules\n    ? Array.from(sheet.cssRules)\n        .map((rule) => rule.cssText || '')\n        .join('')\n    : '';\n}\n\nfunction extractOrigin(url: string): string {\n  let origin = '';\n  if (url.indexOf('//') > -1) {\n    origin = url.split('/').slice(0, 3).join('/');\n  } else {\n    origin = url.split('/')[0];\n  }\n  origin = origin.split('?')[0];\n  return origin;\n}\n\nlet canvasService: HTMLCanvasElement | null;\nlet canvasCtx: CanvasRenderingContext2D | null;\n\nconst URL_IN_CSS_REF = /url\\((?:(')([^']*)'|(\")(.*?)\"|([^)]*))\\)/gm;\nconst RELATIVE_PATH = /^(?!www\\.|(?:http|ftp)s?:\\/\\/|[A-Za-z]:\\\\|\\/\\/|#).*/;\nconst DATA_URI = /^(data:)([^,]*),(.*)/i;\nexport function absoluteToStylesheet(\n  cssText: string | null,\n  href: string,\n): string {\n  return (cssText || '').replace(\n    URL_IN_CSS_REF,\n    (origin, quote1, path1, quote2, path2, path3) => {\n      const filePath = path1 || path2 || path3;\n      const maybeQuote = quote1 || quote2 || '';\n      if (!filePath) {\n        return origin;\n      }\n      if (!RELATIVE_PATH.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (DATA_URI.test(filePath)) {\n        return `url(${maybeQuote}${filePath}${maybeQuote})`;\n      }\n      if (filePath[0] === '/') {\n        return `url(${maybeQuote}${\n          extractOrigin(href) + filePath\n        }${maybeQuote})`;\n      }\n      const stack = href.split('/');\n      const parts = filePath.split('/');\n      stack.pop();\n      for (const part of parts) {\n        if (part === '.') {\n          continue;\n        } else if (part === '..') {\n          stack.pop();\n        } else {\n          stack.push(part);\n        }\n      }\n      return `url(${maybeQuote}${stack.join('/')}${maybeQuote})`;\n    },\n  );\n}\n\nconst SRCSET_NOT_SPACES = /^[^ \\t\\n\\r\\u000c]+/; // Don't use \\s, to avoid matching non-breaking space\nconst SRCSET_COMMAS_OR_SPACES = /^[, \\t\\n\\r\\u000c]+/;\nfunction getAbsoluteSrcsetString(doc: Document, attributeValue: string) {\n  /*\n    run absoluteToDoc over every url in the srcset\n\n    this is adapted from https://github.com/albell/parse-srcset/\n    without the parsing of the descriptors (we return these as-is)\n    parce-srcset is in turn based on\n    https://html.spec.whatwg.org/multipage/embedded-content.html#parse-a-srcset-attribute\n  */\n  if (attributeValue.trim() === '') {\n    return attributeValue;\n  }\n\n  let pos = 0;\n\n  function collectCharacters(regEx: RegExp) {\n    let chars: string;\n    let match = regEx.exec(attributeValue.substring(pos));\n    if (match) {\n      chars = match[0];\n      pos += chars.length;\n      return chars;\n    }\n    return '';\n  }\n\n  let output = [];\n  while (true) {\n    collectCharacters(SRCSET_COMMAS_OR_SPACES);\n    if (pos >= attributeValue.length) {\n      break;\n    }\n    // don't split on commas within urls\n    let url = collectCharacters(SRCSET_NOT_SPACES);\n    if (url.slice(-1) === ',') {\n      // aside: according to spec more than one comma at the end is a parse error, but we ignore that\n      url = absoluteToDoc(doc, url.substring(0, url.length - 1));\n      // the trailing comma splits the srcset, so the interpretion is that\n      // another url will follow, and the descriptor is empty\n      output.push(url);\n    } else {\n      let descriptorsStr = '';\n      url = absoluteToDoc(doc, url);\n      let inParens = false;\n      while (true) {\n        let c = attributeValue.charAt(pos);\n        if (c === '') {\n          output.push((url + descriptorsStr).trim());\n          break;\n        } else if (!inParens) {\n          if (c === ',') {\n            pos += 1;\n            output.push((url + descriptorsStr).trim());\n            break; // parse the next url\n          } else if (c === '(') {\n            inParens = true;\n          }\n        } else {\n          // in parenthesis; ignore commas\n          // (parenthesis may be supported by future additions to spec)\n          if (c === ')') {\n            inParens = false;\n          }\n        }\n        descriptorsStr += c;\n        pos += 1;\n      }\n    }\n  }\n  return output.join(', ');\n}\n\nexport function absoluteToDoc(doc: Document, attributeValue: string): string {\n  if (!attributeValue || attributeValue.trim() === '') {\n    return attributeValue;\n  }\n  const a: HTMLAnchorElement = doc.createElement('a');\n  a.href = attributeValue;\n  return a.href;\n}\n\nfunction isSVGElement(el: Element): boolean {\n  return Boolean(el.tagName === 'svg' || (el as SVGElement).ownerSVGElement);\n}\n\nfunction getHref() {\n  // return a href without hash\n  const a = document.createElement('a');\n  a.href = '';\n  return a.href;\n}\n\nexport function transformAttribute(\n  doc: Document,\n  tagName: string,\n  name: string,\n  value: string,\n): string {\n  // relative path in attribute\n  if (name === 'src' || (name === 'href' && value)) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'xlink:href' && value && value[0] !== '#') {\n    // xlink:href starts with # is an id pointer\n    return absoluteToDoc(doc, value);\n  } else if (\n    name === 'background' &&\n    value &&\n    (tagName === 'table' || tagName === 'td' || tagName === 'th')\n  ) {\n    return absoluteToDoc(doc, value);\n  } else if (name === 'srcset' && value) {\n    return getAbsoluteSrcsetString(doc, value);\n  } else if (name === 'style' && value) {\n    return absoluteToStylesheet(value, getHref());\n  } else if (tagName === 'object' && name === 'data' && value) {\n    return absoluteToDoc(doc, value);\n  } else {\n    return value;\n  }\n}\n\nexport function _isBlockedElement(\n  element: HTMLElement,\n  blockClass: string | RegExp,\n  blockSelector: string | null,\n  unblockSelector: string | null,\n): boolean {\n  if (unblockSelector && element.matches(unblockSelector)) {\n    return false;\n  }\n\n  if (typeof blockClass === 'string') {\n    if (element.classList.contains(blockClass)) {\n      return true;\n    }\n  } else {\n    // tslint:disable-next-line: prefer-for-of\n    for (let eIndex = 0; eIndex < element.classList.length; eIndex++) {\n      const className = element.classList[eIndex];\n      if (blockClass.test(className)) {\n        return true;\n      }\n    }\n  }\n  if (blockSelector) {\n    return element.matches(blockSelector);\n  }\n\n  return false;\n}\n\nexport function needMaskingText(\n  node: Node | null,\n  maskTextClass: string | RegExp,\n  maskTextSelector: string | null,\n  unmaskTextSelector: string | null,\n): boolean {\n  if (!node) {\n    return false;\n  }\n  if (node.nodeType === node.ELEMENT_NODE) {\n    if (unmaskTextSelector) {\n      if ((node as HTMLElement).matches(unmaskTextSelector) || (node as HTMLElement).closest(unmaskTextSelector)) {\n        return false;\n      }\n    }\n\n    if (typeof maskTextClass === 'string') {\n      if ((node as HTMLElement).classList.contains(maskTextClass)) {\n        return true;\n      }\n    } else {\n      // tslint:disable-next-line: prefer-for-of\n      for (\n        let eIndex = 0;\n        eIndex < (node as HTMLElement).classList.length;\n        eIndex++\n      ) {\n        const className = (node as HTMLElement).classList[eIndex];\n        if (maskTextClass.test(className)) {\n          return true;\n        }\n      }\n    }\n    if (maskTextSelector) {\n      if ((node as HTMLElement).matches(maskTextSelector)) {\n        return true;\n      }\n    }\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);\n  }\n\n  if (node.nodeType === node.TEXT_NODE) {\n    // check parent node since text node do not have class name\n    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);\n  }\n  return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);\n}\n\n// https://stackoverflow.com/a/36155560\nfunction onceIframeLoaded(\n  iframeEl: HTMLIFrameElement,\n  listener: () => unknown,\n  iframeLoadTimeout: number,\n) {\n  const win = iframeEl.contentWindow;\n  if (!win) {\n    return;\n  }\n  // document is loading\n  let fired = false;\n\n  let readyState: DocumentReadyState;\n  try {\n    readyState = win.document.readyState;\n  } catch (error) {\n    return;\n  }\n  if (readyState !== 'complete') {\n    const timer = setTimeout(() => {\n      if (!fired) {\n        listener();\n        fired = true;\n      }\n    }, iframeLoadTimeout);\n    iframeEl.addEventListener('load', () => {\n      clearTimeout(timer);\n      fired = true;\n      listener();\n    });\n    return;\n  }\n  // check blank frame for Chrome\n  const blankUrl = 'about:blank';\n  if (\n    win.location.href !== blankUrl ||\n    iframeEl.src === blankUrl ||\n    iframeEl.src === ''\n  ) {\n    // iframe was already loaded, make sure we wait to trigger the listener\n    // till _after_ the mutation that found this iframe has had time to process\n    setTimeout(listener, 0);\n    return;\n  }\n  // use default listener\n  iframeEl.addEventListener('load', listener);\n}\n\nfunction serializeNode(\n  n: Node,\n  options: {\n    doc: Document;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    unblockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    unmaskTextSelector: string | null;\n    maskInputSelector: string | null;\n    unmaskInputSelector: string | null;\n    inlineStylesheet: boolean;\n    maskInputOptions: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    dataURLOptions?: DataURLOptions;\n    inlineImages: boolean;\n    recordCanvas: boolean;\n    keepIframeSrcFn: KeepIframeSrcFn;\n  },\n): serializedNode | false {\n  const {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputSelector,\n    unmaskInputSelector,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions = {},\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  } = options;\n  // Only record root id when document object is not the base document\n  let rootId: number | undefined;\n  if (((doc as unknown) as INode).__sn) {\n    const docId = ((doc as unknown) as INode).__sn.id;\n    rootId = docId === 1 ? undefined : docId;\n  }\n  switch (n.nodeType) {\n    case n.DOCUMENT_NODE:\n      if ((n as HTMLDocument).compatMode !== 'CSS1Compat') {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          compatMode: (n as HTMLDocument).compatMode, // probably \"BackCompat\"\n          rootId,\n        };\n      } else {\n        return {\n          type: NodeType.Document,\n          childNodes: [],\n          rootId,\n        };\n      }\n    case n.DOCUMENT_TYPE_NODE:\n      return {\n        type: NodeType.DocumentType,\n        name: (n as DocumentType).name,\n        publicId: (n as DocumentType).publicId,\n        systemId: (n as DocumentType).systemId,\n        rootId,\n      };\n    case n.ELEMENT_NODE:\n      const needBlock = _isBlockedElement(\n        n as HTMLElement,\n        blockClass,\n        blockSelector,\n        unblockSelector\n      );\n      const tagName = getValidTagName(n as HTMLElement);\n      let attributes: attributes = {};\n      for (const { name, value } of Array.from((n as HTMLElement).attributes)) {\n        attributes[name] = transformAttribute(doc, tagName, name, value);\n      }\n      // remote css\n      if (tagName === 'link' && inlineStylesheet) {\n        const stylesheet = Array.from(doc.styleSheets).find((s) => {\n          return s.href === (n as HTMLLinkElement).href;\n        });\n        let cssText: string | null = null;\n        if (stylesheet) {\n          cssText = getCssRulesString(stylesheet as CSSStyleSheet);\n        }\n        if (cssText) {\n          delete attributes.rel;\n          delete attributes.href;\n          attributes._cssText = absoluteToStylesheet(\n            cssText,\n            stylesheet!.href!,\n          );\n        }\n      }\n      // dynamic stylesheet\n      if (\n        tagName === 'style' &&\n        (n as HTMLStyleElement).sheet &&\n        // TODO: Currently we only try to get dynamic stylesheet when it is an empty style element\n        !(\n          (n as HTMLElement).innerText ||\n          (n as HTMLElement).textContent ||\n          ''\n        ).trim().length\n      ) {\n        const cssText = getCssRulesString(\n          (n as HTMLStyleElement).sheet as CSSStyleSheet,\n        );\n        if (cssText) {\n          attributes._cssText = absoluteToStylesheet(cssText, getHref());\n        }\n      }\n      // form fields\n      if (\n        tagName === 'input' ||\n        tagName === 'textarea' ||\n        tagName === 'select'\n      ) {\n        const value = (n as HTMLInputElement | HTMLTextAreaElement).value;\n        if (\n          attributes.type !== 'radio' &&\n          attributes.type !== 'checkbox' &&\n          attributes.type !== 'submit' &&\n          attributes.type !== 'button' &&\n          value\n        ) {\n          attributes.value = maskInputValue({\n            input: n as HTMLElement,\n            type: attributes.type,\n            tagName,\n            value,\n            maskInputSelector,\n            unmaskInputSelector,\n            maskInputOptions,\n            maskInputFn,\n          });\n        } else if ((n as HTMLInputElement).checked) {\n          attributes.checked = (n as HTMLInputElement).checked;\n        }\n      }\n      if (tagName === 'option') {\n        if ((n as HTMLOptionElement).selected && !maskInputOptions['select']) {\n          attributes.selected = true;\n        } else {\n          // ignore the html attribute (which corresponds to DOM (n as HTMLOptionElement).defaultSelected)\n          // if it's already been changed\n          delete attributes.selected;\n        }\n      }\n      // canvas image data\n      if (tagName === 'canvas' && recordCanvas) {\n        if ((n as ICanvas).__context === '2d') {\n          // only record this on 2d canvas\n          if (!is2DCanvasBlank(n as HTMLCanvasElement)) {\n            attributes.rr_dataURL = (n as HTMLCanvasElement).toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          }\n        } else if (!('__context' in n)) {\n          // context is unknown, better not call getContext to trigger it\n          const canvasDataURL = (n as HTMLCanvasElement).toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // create blank canvas of same dimensions\n          const blankCanvas = document.createElement('canvas');\n          blankCanvas.width = (n as HTMLCanvasElement).width;\n          blankCanvas.height = (n as HTMLCanvasElement).height;\n          const blankCanvasDataURL = blankCanvas.toDataURL(\n            dataURLOptions.type,\n            dataURLOptions.quality,\n          );\n\n          // no need to save dataURL if it's the same as blank canvas\n          if (canvasDataURL !== blankCanvasDataURL) {\n            attributes.rr_dataURL = canvasDataURL;\n          }\n        }\n      }\n      // save image offline\n      if (tagName === 'img' && inlineImages) {\n        if (!canvasService) {\n          canvasService = doc.createElement('canvas');\n          canvasCtx = canvasService.getContext('2d');\n        }\n        const image = n as HTMLImageElement;\n        const oldValue = image.crossOrigin;\n        image.crossOrigin = 'anonymous';\n        const recordInlineImage = () => {\n          try {\n            canvasService!.width = image.naturalWidth;\n            canvasService!.height = image.naturalHeight;\n            canvasCtx!.drawImage(image, 0, 0);\n            attributes.rr_dataURL = canvasService!.toDataURL(\n              dataURLOptions.type,\n              dataURLOptions.quality,\n            );\n          } catch (err) {\n            console.warn(\n              `Cannot inline img src=${image.currentSrc}! Error: ${err}`,\n            );\n          }\n          oldValue\n            ? (attributes.crossOrigin = oldValue)\n            : delete attributes.crossOrigin;\n        };\n        // The image content may not have finished loading yet.\n        if (image.complete && image.naturalWidth !== 0) recordInlineImage();\n        else image.onload = recordInlineImage;\n      }\n      // media elements\n      if (tagName === 'audio' || tagName === 'video') {\n        attributes.rr_mediaState = (n as HTMLMediaElement).paused\n          ? 'paused'\n          : 'played';\n        attributes.rr_mediaCurrentTime = (n as HTMLMediaElement).currentTime;\n      }\n      // scroll\n      if ((n as HTMLElement).scrollLeft) {\n        attributes.rr_scrollLeft = (n as HTMLElement).scrollLeft;\n      }\n      if ((n as HTMLElement).scrollTop) {\n        attributes.rr_scrollTop = (n as HTMLElement).scrollTop;\n      }\n      // block element\n      if (needBlock) {\n        const { width, height } = (n as HTMLElement).getBoundingClientRect();\n        attributes = {\n          class: attributes.class,\n          rr_width: `${width}px`,\n          rr_height: `${height}px`,\n        };\n      }\n      // iframe\n      if (tagName === 'iframe' && !keepIframeSrcFn(attributes.src as string)) {\n        if (!(n as HTMLIFrameElement).contentDocument) {\n          // we can't record it directly as we can't see into it\n          // preserve the src attribute so a decision can be taken at replay time\n          attributes.rr_src = attributes.src;\n        }\n        delete attributes.src; // prevent auto loading\n      }\n      return {\n        type: NodeType.Element,\n        tagName,\n        attributes,\n        childNodes: [],\n        isSVG: isSVGElement(n as Element) || undefined,\n        needBlock,\n        rootId,\n      };\n    case n.TEXT_NODE:\n      // The parent node may not be a html element which has a tagName attribute.\n      // So just let it be undefined which is ok in this use case.\n      const parentTagName =\n        n.parentNode && (n.parentNode as HTMLElement).tagName;\n      let textContent = (n as Text).textContent;\n      const isStyle = parentTagName === 'STYLE' ? true : undefined;\n      const isScript = parentTagName === 'SCRIPT' ? true : undefined;\n      if (isStyle && textContent) {\n        try {\n          // try to read style sheet\n          if (n.nextSibling || n.previousSibling) {\n            // This is not the only child of the stylesheet.\n            // We can't read all of the sheet's .cssRules and expect them\n            // to _only_ include the current rule(s) added by the text node.\n            // So we'll be conservative and keep textContent as-is.\n          } else if ((n.parentNode as HTMLStyleElement).sheet?.cssRules) {\n            textContent = stringifyStyleSheet(\n              (n.parentNode as HTMLStyleElement).sheet!,\n            );\n          }\n        } catch (err) {\n          console.warn(\n            `Cannot get CSS styles from text's parentNode. Error: ${err}`,\n            n,\n          );\n        }\n        textContent = absoluteToStylesheet(textContent, getHref());\n      }\n      if (isScript) {\n        textContent = 'SCRIPT_PLACEHOLDER';\n      }\n      if (\n        !isStyle &&\n        !isScript &&\n        needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextSelector) &&\n        textContent\n      ) {\n        textContent = maskTextFn\n          ? maskTextFn(textContent)\n          : textContent.replace(/[\\S]/g, '*');\n      }\n      return {\n        type: NodeType.Text,\n        textContent: textContent || '',\n        isStyle,\n        rootId,\n      };\n    case n.CDATA_SECTION_NODE:\n      return {\n        type: NodeType.CDATA,\n        textContent: '',\n        rootId,\n      };\n    case n.COMMENT_NODE:\n      return {\n        type: NodeType.Comment,\n        textContent: (n as Comment).textContent || '',\n        rootId,\n      };\n    default:\n      return false;\n  }\n}\n\nfunction lowerIfExists(maybeAttr: string | number | boolean): string {\n  if (maybeAttr === undefined) {\n    return '';\n  } else {\n    return (maybeAttr as string).toLowerCase();\n  }\n}\n\nfunction slimDOMExcluded(\n  sn: serializedNode,\n  slimDOMOptions: SlimDOMOptions,\n): boolean {\n  if (slimDOMOptions.comment && sn.type === NodeType.Comment) {\n    // TODO: convert IE conditional comments to real nodes\n    return true;\n  } else if (sn.type === NodeType.Element) {\n    if (\n      slimDOMOptions.script &&\n      // script tag\n      (sn.tagName === 'script' ||\n        // preload link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'preload' &&\n          sn.attributes.as === 'script') ||\n        // prefetch link\n        (sn.tagName === 'link' &&\n          sn.attributes.rel === 'prefetch' &&\n          typeof sn.attributes.href === 'string' &&\n          sn.attributes.href.endsWith('.js')))\n    ) {\n      return true;\n    } else if (\n      slimDOMOptions.headFavicon &&\n      ((sn.tagName === 'link' && sn.attributes.rel === 'shortcut icon') ||\n        (sn.tagName === 'meta' &&\n          (lowerIfExists(sn.attributes.name).match(\n            /^msapplication-tile(image|color)$/,\n          ) ||\n            lowerIfExists(sn.attributes.name) === 'application-name' ||\n            lowerIfExists(sn.attributes.rel) === 'icon' ||\n            lowerIfExists(sn.attributes.rel) === 'apple-touch-icon' ||\n            lowerIfExists(sn.attributes.rel) === 'shortcut icon')))\n    ) {\n      return true;\n    } else if (sn.tagName === 'meta') {\n      if (\n        slimDOMOptions.headMetaDescKeywords &&\n        lowerIfExists(sn.attributes.name).match(/^description|keywords$/)\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaSocial &&\n        (lowerIfExists(sn.attributes.property).match(/^(og|twitter|fb):/) || // og = opengraph (facebook)\n          lowerIfExists(sn.attributes.name).match(/^(og|twitter):/) ||\n          lowerIfExists(sn.attributes.name) === 'pinterest')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaRobots &&\n        (lowerIfExists(sn.attributes.name) === 'robots' ||\n          lowerIfExists(sn.attributes.name) === 'googlebot' ||\n          lowerIfExists(sn.attributes.name) === 'bingbot')\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaHttpEquiv &&\n        sn.attributes['http-equiv'] !== undefined\n      ) {\n        // e.g. X-UA-Compatible, Content-Type, Content-Language,\n        // cache-control, X-Translated-By\n        return true;\n      } else if (\n        slimDOMOptions.headMetaAuthorship &&\n        (lowerIfExists(sn.attributes.name) === 'author' ||\n          lowerIfExists(sn.attributes.name) === 'generator' ||\n          lowerIfExists(sn.attributes.name) === 'framework' ||\n          lowerIfExists(sn.attributes.name) === 'publisher' ||\n          lowerIfExists(sn.attributes.name) === 'progid' ||\n          lowerIfExists(sn.attributes.property).match(/^article:/) ||\n          lowerIfExists(sn.attributes.property).match(/^product:/))\n      ) {\n        return true;\n      } else if (\n        slimDOMOptions.headMetaVerification &&\n        (lowerIfExists(sn.attributes.name) === 'google-site-verification' ||\n          lowerIfExists(sn.attributes.name) === 'yandex-verification' ||\n          lowerIfExists(sn.attributes.name) === 'csrf-token' ||\n          lowerIfExists(sn.attributes.name) === 'p:domain_verify' ||\n          lowerIfExists(sn.attributes.name) === 'verify-v1' ||\n          lowerIfExists(sn.attributes.name) === 'verification' ||\n          lowerIfExists(sn.attributes.name) === 'shopify-checkout-api-token')\n      ) {\n        return true;\n      }\n    }\n  }\n  return false;\n}\n\nexport function serializeNodeWithId(\n  n: Node | INode,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    blockClass: string | RegExp;\n    blockSelector: string | null;\n    unblockSelector: string | null;\n    maskTextClass: string | RegExp;\n    maskTextSelector: string | null;\n    unmaskTextSelector: string | null;\n    skipChild: boolean;\n    inlineStylesheet: boolean;\n    maskInputSelector: string | null;\n    unmaskInputSelector: string | null;\n    maskInputOptions?: MaskInputOptions;\n    maskTextFn: MaskTextFn | undefined;\n    maskInputFn: MaskInputFn | undefined;\n    slimDOMOptions: SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n  },\n): serializedNodeWithId | null {\n  const {\n    doc,\n    map,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    skipChild = false,\n    inlineStylesheet = true,\n    maskInputSelector,\n    unmaskInputSelector,\n    maskInputOptions = {},\n    maskTextFn,\n    maskInputFn,\n    slimDOMOptions,\n    dataURLOptions = {},\n    inlineImages = false,\n    recordCanvas = false,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout = 5000,\n    keepIframeSrcFn = () => false,\n  } = options;\n  let { preserveWhiteSpace = true } = options;\n  const _serializedNode = serializeNode(n, {\n    doc,\n    blockClass,\n    blockSelector,\n    unblockSelector,\n    maskTextClass,\n    maskTextSelector,\n    unmaskTextSelector,\n    inlineStylesheet,\n    maskInputSelector,\n    unmaskInputSelector,\n    maskInputOptions,\n    maskTextFn,\n    maskInputFn,\n    dataURLOptions,\n    inlineImages,\n    recordCanvas,\n    keepIframeSrcFn,\n  });\n  if (!_serializedNode) {\n    // TODO: dev only\n    console.warn(n, 'not serialized');\n    return null;\n  }\n\n  let id;\n  // Try to reuse the previous id\n  if ('__sn' in n) {\n    id = n.__sn.id;\n  } else if (\n    slimDOMExcluded(_serializedNode, slimDOMOptions) ||\n    (!preserveWhiteSpace &&\n      _serializedNode.type === NodeType.Text &&\n      !_serializedNode.isStyle &&\n      !_serializedNode.textContent.replace(/^\\s+|\\s+$/gm, '').length)\n  ) {\n    id = IGNORED_NODE;\n  } else {\n    id = genId();\n  }\n  const serializedNode = Object.assign(_serializedNode, { id });\n  (n as INode).__sn = serializedNode;\n  if (id === IGNORED_NODE) {\n    return null; // slimDOM\n  }\n  map[id] = n as INode;\n  if (onSerialize) {\n    onSerialize(n as INode);\n  }\n  let recordChild = !skipChild;\n  if (serializedNode.type === NodeType.Element) {\n    recordChild = recordChild && !serializedNode.needBlock;\n    // this property was not needed in replay side\n    delete serializedNode.needBlock;\n    if ((n as HTMLElement).shadowRoot) serializedNode.isShadowHost = true;\n  }\n  if (\n    (serializedNode.type === NodeType.Document ||\n      serializedNode.type === NodeType.Element) &&\n    recordChild\n  ) {\n    if (\n      slimDOMOptions.headWhitespace &&\n      _serializedNode.type === NodeType.Element &&\n      _serializedNode.tagName === 'head'\n      // would impede performance: || getComputedStyle(n)['white-space'] === 'normal'\n    ) {\n      preserveWhiteSpace = false;\n    }\n    const bypassOptions = {\n      doc,\n      map,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild,\n      inlineStylesheet,\n      maskInputSelector,\n      unmaskInputSelector,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    };\n    for (const childN of Array.from(n.childNodes)) {\n      const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n      if (serializedChildNode) {\n        serializedNode.childNodes.push(serializedChildNode);\n      }\n    }\n\n    if (isElement(n) && n.shadowRoot) {\n      for (const childN of Array.from(n.shadowRoot.childNodes)) {\n        const serializedChildNode = serializeNodeWithId(childN, bypassOptions);\n        if (serializedChildNode) {\n          serializedChildNode.isShadow = true;\n          serializedNode.childNodes.push(serializedChildNode);\n        }\n      }\n    }\n  }\n\n  if (n.parentNode && isShadowRoot(n.parentNode)) {\n    serializedNode.isShadow = true;\n  }\n\n  if (\n    serializedNode.type === NodeType.Element &&\n    serializedNode.tagName === 'iframe'\n  ) {\n    onceIframeLoaded(\n      n as HTMLIFrameElement,\n      () => {\n        const iframeDoc = (n as HTMLIFrameElement).contentDocument;\n        if (iframeDoc && onIframeLoad) {\n          const serializedIframeNode = serializeNodeWithId(iframeDoc, {\n            doc: iframeDoc,\n            map,\n            blockClass,\n            blockSelector,\n            unblockSelector,\n            maskTextClass,\n            maskTextSelector,\n            unmaskTextSelector,\n            skipChild: false,\n            inlineStylesheet,\n            maskInputSelector,\n            unmaskInputSelector,\n            maskInputOptions,\n            maskTextFn,\n            maskInputFn,\n            slimDOMOptions,\n            dataURLOptions,\n            inlineImages,\n            recordCanvas,\n            preserveWhiteSpace,\n            onSerialize,\n            onIframeLoad,\n            iframeLoadTimeout,\n            keepIframeSrcFn,\n          });\n\n          if (serializedIframeNode) {\n            onIframeLoad(n as INode, serializedIframeNode);\n          }\n        }\n      },\n      iframeLoadTimeout,\n    );\n  }\n\n  return serializedNode;\n}\n\nfunction snapshot(\n  n: Document,\n  options?: {\n    blockClass?: string | RegExp;\n    blockSelector?: string | null;\n    unblockSelector?: string | null;\n    maskTextClass?: string | RegExp;\n    maskTextSelector?: string | null;\n    unmaskTextSelector?: string | null;\n    maskInputSelector?: string | null;\n    unmaskInputSelector?: string | null;\n    inlineStylesheet?: boolean;\n    maskAllInputs?: boolean | MaskInputOptions;\n    maskTextFn?: MaskTextFn;\n    maskInputFn?: MaskTextFn;\n    slimDOM?: boolean | SlimDOMOptions;\n    dataURLOptions?: DataURLOptions;\n    inlineImages?: boolean;\n    recordCanvas?: boolean;\n    preserveWhiteSpace?: boolean;\n    onSerialize?: (n: INode) => unknown;\n    onIframeLoad?: (iframeINode: INode, node: serializedNodeWithId) => unknown;\n    iframeLoadTimeout?: number;\n    keepIframeSrcFn?: KeepIframeSrcFn;\n  },\n): [serializedNodeWithId | null, idNodeMap] {\n  const {\n    blockClass = 'rr-block',\n    blockSelector = null,\n    unblockSelector = null,\n    maskTextClass = 'rr-mask',\n    maskTextSelector = null,\n    unmaskTextSelector = null,\n    inlineStylesheet = true,\n    inlineImages = false,\n    recordCanvas = false,\n    maskInputSelector = null,\n    unmaskInputSelector = null,\n    maskAllInputs = false,\n    maskTextFn,\n    maskInputFn,\n    slimDOM = false,\n    dataURLOptions,\n    preserveWhiteSpace,\n    onSerialize,\n    onIframeLoad,\n    iframeLoadTimeout,\n    keepIframeSrcFn = () => false,\n  } = options || {};\n  const idNodeMap: idNodeMap = {};\n  const maskInputOptions: MaskInputOptions =\n    maskAllInputs === true\n      ? {\n          color: true,\n          date: true,\n          'datetime-local': true,\n          email: true,\n          month: true,\n          number: true,\n          range: true,\n          search: true,\n          tel: true,\n          text: true,\n          time: true,\n          url: true,\n          week: true,\n          textarea: true,\n          select: true,\n          password: true,\n        }\n      : maskAllInputs === false\n      ? {\n          password: true,\n        }\n      : maskAllInputs;\n  const slimDOMOptions: SlimDOMOptions =\n    slimDOM === true || slimDOM === 'all'\n      ? // if true: set of sensible options that should not throw away any information\n        {\n          script: true,\n          comment: true,\n          headFavicon: true,\n          headWhitespace: true,\n          headMetaDescKeywords: slimDOM === 'all', // destructive\n          headMetaSocial: true,\n          headMetaRobots: true,\n          headMetaHttpEquiv: true,\n          headMetaAuthorship: true,\n          headMetaVerification: true,\n        }\n      : slimDOM === false\n      ? {}\n      : slimDOM;\n  return [\n    serializeNodeWithId(n, {\n      doc: n,\n      map: idNodeMap,\n      blockClass,\n      blockSelector,\n      unblockSelector,\n      maskTextClass,\n      maskTextSelector,\n      unmaskTextSelector,\n      skipChild: false,\n      inlineStylesheet,\n      maskInputSelector,\n      unmaskInputSelector,\n      maskInputOptions,\n      maskTextFn,\n      maskInputFn,\n      slimDOMOptions,\n      dataURLOptions,\n      inlineImages,\n      recordCanvas,\n      preserveWhiteSpace,\n      onSerialize,\n      onIframeLoad,\n      iframeLoadTimeout,\n      keepIframeSrcFn,\n    }),\n    idNodeMap,\n  ];\n}\n\nexport function visitSnapshot(\n  node: serializedNodeWithId,\n  onVisit: (node: serializedNodeWithId) => unknown,\n) {\n  function walk(current: serializedNodeWithId) {\n    onVisit(current);\n    if (\n      current.type === NodeType.Document ||\n      current.type === NodeType.Element\n    ) {\n      current.childNodes.forEach(walk);\n    }\n  }\n\n  walk(node);\n}\n\nexport function cleanupSnapshot() {\n  // allow a new recording to start numbering nodes from scratch\n  _id = 1;\n}\n\nexport default snapshot;\n","/**\n * This file is a fork of https://github.com/reworkcss/css/blob/master/lib/parse/index.js\n * I fork it because:\n * 1. The css library was built for node.js which does not have tree-shaking supports.\n * 2. Rewrites into typescript give us a better type interface.\n */\n\n/* tslint:disable no-conditional-assignment interface-name no-shadowed-variable */\n\nexport interface ParserOptions {\n  /** Silently fail on parse errors */\n  silent?: boolean;\n  /**\n   * The path to the file containing css.\n   * Makes errors and source maps more helpful, by letting them know where code comes from.\n   */\n  source?: string;\n}\n\n/**\n * Error thrown during parsing.\n */\nexport interface ParserError {\n  /** The full error message with the source position. */\n  message?: string;\n  /** The error message without position. */\n  reason?: string;\n  /** The value of options.source if passed to css.parse. Otherwise undefined. */\n  filename?: string;\n  line?: number;\n  column?: number;\n  /** The portion of code that couldn't be parsed. */\n  source?: string;\n}\n\nexport interface Loc {\n  line?: number;\n  column?: number;\n}\n\n/**\n * Base AST Tree Node.\n */\nexport interface Node {\n  /** The possible values are the ones listed in the Types section on https://github.com/reworkcss/css page. */\n  type?: string;\n  /** A reference to the parent node, or null if the node has no parent. */\n  parent?: Node;\n  /** Information about the position in the source string that corresponds to the node. */\n  position?: {\n    start?: Loc;\n    end?: Loc;\n    /** The value of options.source if passed to css.parse. Otherwise undefined. */\n    source?: string;\n    /** The full source string passed to css.parse. */\n    content?: string;\n  };\n}\n\nexport interface Rule extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\nexport interface Declaration extends Node {\n  /** The property name, trimmed from whitespace and comments. May not be empty. */\n  property?: string;\n  /** The value of the property, trimmed from whitespace and comments. Empty values are allowed. */\n  value?: string;\n}\n\n/**\n * A rule-level or declaration-level comment. Comments inside selectors, properties and values etc. are lost.\n */\nexport interface Comment extends Node {\n  comment?: string;\n}\n\n/**\n * The @charset at-rule.\n */\nexport interface Charset extends Node {\n  /** The part following @charset. */\n  charset?: string;\n}\n\n/**\n * The @custom-media at-rule\n */\nexport interface CustomMedia extends Node {\n  /** The ---prefixed name. */\n  name?: string;\n  /** The part following the name. */\n  media?: string;\n}\n\n/**\n * The @document at-rule.\n */\nexport interface Document extends Node {\n  /** The part following @document. */\n  document?: string;\n  /** The vendor prefix in @document, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @font-face at-rule.\n */\nexport interface FontFace extends Node {\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @host at-rule.\n */\nexport interface Host extends Node {\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @import at-rule.\n */\nexport interface Import extends Node {\n  /** The part following @import. */\n  import?: string;\n}\n\n/**\n * The @keyframes at-rule.\n */\nexport interface KeyFrames extends Node {\n  /** The name of the keyframes rule. */\n  name?: string;\n  /** The vendor prefix in @keyframes, or undefined if there is none. */\n  vendor?: string;\n  /** Array of nodes with the types keyframe and comment. */\n  keyframes?: Array<KeyFrame | Comment>;\n}\n\nexport interface KeyFrame extends Node {\n  /** The list of \"selectors\" of the keyframe rule, split on commas. Each “selector” is trimmed from whitespace. */\n  values?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @media at-rule.\n */\nexport interface Media extends Node {\n  /** The part following @media. */\n  media?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/**\n * The @namespace at-rule.\n */\nexport interface Namespace extends Node {\n  /** The part following @namespace. */\n  namespace?: string;\n}\n\n/**\n * The @page at-rule.\n */\nexport interface Page extends Node {\n  /** The list of selectors of the rule, split on commas. Each selector is trimmed from whitespace and comments. */\n  selectors?: string[];\n  /** Array of nodes with the types declaration and comment. */\n  declarations?: Array<Declaration | Comment>;\n}\n\n/**\n * The @supports at-rule.\n */\nexport interface Supports extends Node {\n  /** The part following @supports. */\n  supports?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules?: Array<Rule | Comment | AtRule>;\n}\n\n/** All at-rules. */\nexport type AtRule =\n  | Charset\n  | CustomMedia\n  | Document\n  | FontFace\n  | Host\n  | Import\n  | KeyFrames\n  | Media\n  | Namespace\n  | Page\n  | Supports;\n\n/**\n * A collection of rules\n */\nexport interface StyleRules {\n  source?: string;\n  /** Array of nodes with the types rule, comment and any of the at-rule types. */\n  rules: Array<Rule | Comment | AtRule>;\n  /** Array of Errors. Errors collected during parsing when option silent is true. */\n  parsingErrors?: ParserError[];\n}\n\n/**\n * The root node returned by css.parse.\n */\nexport interface Stylesheet extends Node {\n  stylesheet?: StyleRules;\n}\n\n// http://www.w3.org/TR/CSS21/grammar.html\n// https://github.com/visionmedia/css-parse/pull/49#issuecomment-30088027\nconst commentre = /\\/\\*[^*]*\\*+([^/*][^*]*\\*+)*\\//g;\n\nexport function parse(css: string, options: ParserOptions = {}) {\n  /**\n   * Positional.\n   */\n\n  let lineno = 1;\n  let column = 1;\n\n  /**\n   * Update lineno and column based on `str`.\n   */\n\n  function updatePosition(str: string) {\n    const lines = str.match(/\\n/g);\n    if (lines) {\n      lineno += lines.length;\n    }\n    let i = str.lastIndexOf('\\n');\n    column = i === -1 ? column + str.length : str.length - i;\n  }\n\n  /**\n   * Mark position and patch `node.position`.\n   */\n\n  function position() {\n    const start = { line: lineno, column };\n    return (\n      node: Rule | Declaration | Comment | AtRule | Stylesheet | KeyFrame,\n    ) => {\n      node.position = new Position(start);\n      whitespace();\n      return node;\n    };\n  }\n\n  /**\n   * Store position information for a node\n   */\n\n  class Position {\n    public content!: string;\n    public start!: Loc;\n    public end!: Loc;\n    public source?: string;\n\n    constructor(start: Loc) {\n      this.start = start;\n      this.end = { line: lineno, column };\n      this.source = options.source;\n    }\n  }\n\n  /**\n   * Non-enumerable source string\n   */\n\n  Position.prototype.content = css;\n\n  const errorsList: ParserError[] = [];\n\n  function error(msg: string) {\n    const err = new Error(\n      options.source + ':' + lineno + ':' + column + ': ' + msg,\n    ) as ParserError;\n    err.reason = msg;\n    err.filename = options.source;\n    err.line = lineno;\n    err.column = column;\n    err.source = css;\n\n    if (options.silent) {\n      errorsList.push(err);\n    } else {\n      throw err;\n    }\n  }\n\n  /**\n   * Parse stylesheet.\n   */\n\n  function stylesheet(): Stylesheet {\n    const rulesList = rules();\n\n    return {\n      type: 'stylesheet',\n      stylesheet: {\n        source: options.source,\n        rules: rulesList,\n        parsingErrors: errorsList,\n      },\n    };\n  }\n\n  /**\n   * Opening brace.\n   */\n\n  function open() {\n    return match(/^{\\s*/);\n  }\n\n  /**\n   * Closing brace.\n   */\n\n  function close() {\n    return match(/^}/);\n  }\n\n  /**\n   * Parse ruleset.\n   */\n\n  function rules() {\n    let node: Rule | void;\n    const rules: Rule[] = [];\n    whitespace();\n    comments(rules);\n    while (css.length && css.charAt(0) !== '}' && (node = atrule() || rule())) {\n      if (node !== false) {\n        rules.push(node);\n        comments(rules);\n      }\n    }\n    return rules;\n  }\n\n  /**\n   * Match `re` and return captures.\n   */\n\n  function match(re: RegExp) {\n    const m = re.exec(css);\n    if (!m) {\n      return;\n    }\n    const str = m[0];\n    updatePosition(str);\n    css = css.slice(str.length);\n    return m;\n  }\n\n  /**\n   * Parse whitespace.\n   */\n\n  function whitespace() {\n    match(/^\\s*/);\n  }\n\n  /**\n   * Parse comments;\n   */\n\n  function comments(rules: Rule[] = []) {\n    let c: Comment | void;\n    while ((c = comment())) {\n      if (c !== false) {\n        rules.push(c);\n      }\n      c = comment();\n    }\n    return rules;\n  }\n\n  /**\n   * Parse comment.\n   */\n\n  function comment() {\n    const pos = position();\n    if ('/' !== css.charAt(0) || '*' !== css.charAt(1)) {\n      return;\n    }\n\n    let i = 2;\n    while (\n      '' !== css.charAt(i) &&\n      ('*' !== css.charAt(i) || '/' !== css.charAt(i + 1))\n    ) {\n      ++i;\n    }\n    i += 2;\n\n    if ('' === css.charAt(i - 1)) {\n      return error('End of comment missing');\n    }\n\n    const str = css.slice(2, i - 2);\n    column += 2;\n    updatePosition(str);\n    css = css.slice(i);\n    column += 2;\n\n    return pos({\n      type: 'comment',\n      comment: str,\n    });\n  }\n\n  /**\n   * Parse selector.\n   */\n\n  function selector() {\n    const m = match(/^([^{]+)/);\n    if (!m) {\n      return;\n    }\n    /* @fix Remove all comments from selectors\n     * http://ostermiller.org/findcomment.html */\n    return trim(m[0])\n      .replace(/\\/\\*([^*]|[\\r\\n]|(\\*+([^*/]|[\\r\\n])))*\\*\\/+/g, '')\n      .replace(/\"(?:\\\\\"|[^\"])*\"|'(?:\\\\'|[^'])*'/g, (m) => {\n        return m.replace(/,/g, '\\u200C');\n      })\n      .split(/\\s*(?![^(]*\\)),\\s*/)\n      .map((s) => {\n        return s.replace(/\\u200C/g, ',');\n      });\n  }\n\n  /**\n   * Parse declaration.\n   */\n\n  function declaration(): Declaration | void | never {\n    const pos = position();\n\n    // prop\n    let propMatch = match(/^(\\*?[-#\\/\\*\\\\\\w]+(\\[[0-9a-z_-]+\\])?)\\s*/);\n    if (!propMatch) {\n      return;\n    }\n    const prop = trim(propMatch[0]);\n\n    // :\n    if (!match(/^:\\s*/)) {\n      return error(`property missing ':'`);\n    }\n\n    // val\n    const val = match(/^((?:'(?:\\\\'|.)*?'|\"(?:\\\\\"|.)*?\"|\\([^\\)]*?\\)|[^};])+)/);\n\n    const ret = pos({\n      type: 'declaration',\n      property: prop.replace(commentre, ''),\n      value: val ? trim(val[0]).replace(commentre, '') : '',\n    });\n\n    // ;\n    match(/^[;\\s]*/);\n\n    return ret;\n  }\n\n  /**\n   * Parse declarations.\n   */\n\n  function declarations() {\n    const decls: Array<object> = [];\n\n    if (!open()) {\n      return error(`missing '{'`);\n    }\n    comments(decls);\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      if ((decl as unknown) !== false) {\n        decls.push(decl);\n        comments(decls);\n      }\n      decl = declaration();\n    }\n\n    if (!close()) {\n      return error(`missing '}'`);\n    }\n    return decls;\n  }\n\n  /**\n   * Parse keyframe.\n   */\n\n  function keyframe() {\n    let m;\n    const vals = [];\n    const pos = position();\n\n    while ((m = match(/^((\\d+\\.\\d+|\\.\\d+|\\d+)%?|[a-z]+)\\s*/))) {\n      vals.push(m[1]);\n      match(/^,\\s*/);\n    }\n\n    if (!vals.length) {\n      return;\n    }\n\n    return pos({\n      type: 'keyframe',\n      values: vals,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  /**\n   * Parse keyframes.\n   */\n\n  function atkeyframes() {\n    const pos = position();\n    let m = match(/^@([-\\w]+)?keyframes\\s*/);\n\n    if (!m) {\n      return;\n    }\n    const vendor = m[1];\n\n    // identifier\n    m = match(/^([-\\w]+)\\s*/);\n    if (!m) {\n      return error('@keyframes missing name');\n    }\n    const name = m[1];\n\n    if (!open()) {\n      return error(`@keyframes missing '{'`);\n    }\n\n    let frame;\n    let frames = comments();\n    while ((frame = keyframe())) {\n      frames.push(frame);\n      frames = frames.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@keyframes missing '}'`);\n    }\n\n    return pos({\n      type: 'keyframes',\n      name,\n      vendor,\n      keyframes: frames,\n    });\n  }\n\n  /**\n   * Parse supports.\n   */\n\n  function atsupports() {\n    const pos = position();\n    const m = match(/^@supports *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const supports = trim(m[1]);\n\n    if (!open()) {\n      return error(`@supports missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@supports missing '}'`);\n    }\n\n    return pos({\n      type: 'supports',\n      supports,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse host.\n   */\n\n  function athost() {\n    const pos = position();\n    const m = match(/^@host\\s*/);\n\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@host missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@host missing '}'`);\n    }\n\n    return pos({\n      type: 'host',\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse media.\n   */\n\n  function atmedia() {\n    const pos = position();\n    const m = match(/^@media *([^{]+)/);\n\n    if (!m) {\n      return;\n    }\n    const media = trim(m[1]);\n\n    if (!open()) {\n      return error(`@media missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@media missing '}'`);\n    }\n\n    return pos({\n      type: 'media',\n      media,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse custom-media.\n   */\n\n  function atcustommedia() {\n    const pos = position();\n    const m = match(/^@custom-media\\s+(--[^\\s]+)\\s*([^{;]+);/);\n    if (!m) {\n      return;\n    }\n\n    return pos({\n      type: 'custom-media',\n      name: trim(m[1]),\n      media: trim(m[2]),\n    });\n  }\n\n  /**\n   * Parse paged media.\n   */\n\n  function atpage() {\n    const pos = position();\n    const m = match(/^@page */);\n    if (!m) {\n      return;\n    }\n\n    const sel = selector() || [];\n\n    if (!open()) {\n      return error(`@page missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@page missing '}'`);\n    }\n\n    return pos({\n      type: 'page',\n      selectors: sel,\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse document.\n   */\n\n  function atdocument() {\n    const pos = position();\n    const m = match(/^@([-\\w]+)?document *([^{]+)/);\n    if (!m) {\n      return;\n    }\n\n    const vendor = trim(m[1]);\n    const doc = trim(m[2]);\n\n    if (!open()) {\n      return error(`@document missing '{'`);\n    }\n\n    const style = comments().concat(rules());\n\n    if (!close()) {\n      return error(`@document missing '}'`);\n    }\n\n    return pos({\n      type: 'document',\n      document: doc,\n      vendor,\n      rules: style,\n    });\n  }\n\n  /**\n   * Parse font-face.\n   */\n\n  function atfontface() {\n    const pos = position();\n    const m = match(/^@font-face\\s*/);\n    if (!m) {\n      return;\n    }\n\n    if (!open()) {\n      return error(`@font-face missing '{'`);\n    }\n    let decls = comments();\n\n    // declarations\n    let decl;\n    while ((decl = declaration())) {\n      decls.push(decl);\n      decls = decls.concat(comments());\n    }\n\n    if (!close()) {\n      return error(`@font-face missing '}'`);\n    }\n\n    return pos({\n      type: 'font-face',\n      declarations: decls,\n    });\n  }\n\n  /**\n   * Parse import\n   */\n\n  const atimport = _compileAtrule('import');\n\n  /**\n   * Parse charset\n   */\n\n  const atcharset = _compileAtrule('charset');\n\n  /**\n   * Parse namespace\n   */\n\n  const atnamespace = _compileAtrule('namespace');\n\n  /**\n   * Parse non-block at-rules\n   */\n\n  function _compileAtrule(name: string) {\n    const re = new RegExp('^@' + name + '\\\\s*([^;]+);');\n    return () => {\n      const pos = position();\n      const m = match(re);\n      if (!m) {\n        return;\n      }\n      const ret: Record<string, string> = { type: name };\n      ret[name] = m[1].trim();\n      return pos(ret);\n    };\n  }\n\n  /**\n   * Parse at rule.\n   */\n\n  function atrule() {\n    if (css[0] !== '@') {\n      return;\n    }\n\n    return (\n      atkeyframes() ||\n      atmedia() ||\n      atcustommedia() ||\n      atsupports() ||\n      atimport() ||\n      atcharset() ||\n      atnamespace() ||\n      atdocument() ||\n      atpage() ||\n      athost() ||\n      atfontface()\n    );\n  }\n\n  /**\n   * Parse rule.\n   */\n\n  function rule() {\n    const pos = position();\n    const sel = selector();\n\n    if (!sel) {\n      return error('selector missing');\n    }\n    comments();\n\n    return pos({\n      type: 'rule',\n      selectors: sel,\n      declarations: declarations() as Declaration[],\n    });\n  }\n\n  return addParent(stylesheet());\n}\n\n/**\n * Trim `str`.\n */\n\nfunction trim(str: string) {\n  return str ? str.replace(/^\\s+|\\s+$/g, '') : '';\n}\n\n/**\n * Adds non-enumerable parent node reference to each node.\n */\n\nfunction addParent(obj: Stylesheet, parent?: Stylesheet) {\n  const isNode = obj && typeof obj.type === 'string';\n  const childParent = isNode ? obj : parent;\n\n  for (const k of Object.keys(obj)) {\n    const value = obj[k as keyof Stylesheet];\n    if (Array.isArray(value)) {\n      value.forEach((v) => {\n        addParent(v, childParent);\n      });\n    } else if (value && typeof value === 'object') {\n      addParent((value as unknown) as Stylesheet, childParent);\n    }\n  }\n\n  if (isNode) {\n    Object.defineProperty(obj, 'parent', {\n      configurable: true,\n      writable: true,\n      enumerable: false,\n      value: parent || null,\n    });\n  }\n\n  return obj;\n}\n","import { parse } from './css';\nimport {\n  serializedNodeWithId,\n  NodeType,\n  tagMap,\n  elementNode,\n  idNodeMap,\n  INode,\n  BuildCache,\n} from './types';\nimport { isElement } from './utils';\n\nconst tagMap: tagMap = {\n  script: 'noscript',\n  // camel case svg element tag names\n  altglyph: 'altGlyph',\n  altglyphdef: 'altGlyphDef',\n  altglyphitem: 'altGlyphItem',\n  animatecolor: 'animateColor',\n  animatemotion: 'animateMotion',\n  animatetransform: 'animateTransform',\n  clippath: 'clipPath',\n  feblend: 'feBlend',\n  fecolormatrix: 'feColorMatrix',\n  fecomponenttransfer: 'feComponentTransfer',\n  fecomposite: 'feComposite',\n  feconvolvematrix: 'feConvolveMatrix',\n  fediffuselighting: 'feDiffuseLighting',\n  fedisplacementmap: 'feDisplacementMap',\n  fedistantlight: 'feDistantLight',\n  fedropshadow: 'feDropShadow',\n  feflood: 'feFlood',\n  fefunca: 'feFuncA',\n  fefuncb: 'feFuncB',\n  fefuncg: 'feFuncG',\n  fefuncr: 'feFuncR',\n  fegaussianblur: 'feGaussianBlur',\n  feimage: 'feImage',\n  femerge: 'feMerge',\n  femergenode: 'feMergeNode',\n  femorphology: 'feMorphology',\n  feoffset: 'feOffset',\n  fepointlight: 'fePointLight',\n  fespecularlighting: 'feSpecularLighting',\n  fespotlight: 'feSpotLight',\n  fetile: 'feTile',\n  feturbulence: 'feTurbulence',\n  foreignobject: 'foreignObject',\n  glyphref: 'glyphRef',\n  lineargradient: 'linearGradient',\n  radialgradient: 'radialGradient',\n};\nfunction getTagName(n: elementNode): string {\n  let tagName = tagMap[n.tagName] ? tagMap[n.tagName] : n.tagName;\n  if (tagName === 'link' && n.attributes._cssText) {\n    tagName = 'style';\n  }\n  return tagName;\n}\n\n// based on https://developer.mozilla.org/en-US/docs/Web/JavaScript/Guide/Regular_Expressions#escaping\nfunction escapeRegExp(str: string) {\n  return str.replace(/[.*+?^${}()|[\\]\\\\]/g, '\\\\$&'); // $& means the whole matched string\n}\n\nconst HOVER_SELECTOR = /([^\\\\]):hover/;\nconst HOVER_SELECTOR_GLOBAL = new RegExp(HOVER_SELECTOR.source, 'g');\nexport function addHoverClass(cssText: string, cache: BuildCache): string {\n  const cachedStyle = cache?.stylesWithHoverClass.get(cssText);\n  if (cachedStyle) return cachedStyle;\n\n  const ast = parse(cssText, {\n    silent: true,\n  });\n\n  if (!ast.stylesheet) {\n    return cssText;\n  }\n\n  const selectors: string[] = [];\n  ast.stylesheet.rules.forEach((rule) => {\n    if ('selectors' in rule) {\n      (rule.selectors || []).forEach((selector: string) => {\n        if (HOVER_SELECTOR.test(selector)) {\n          selectors.push(selector);\n        }\n      });\n    }\n  });\n\n  if (selectors.length === 0) {\n    return cssText;\n  }\n\n  const selectorMatcher = new RegExp(\n    selectors\n      .filter((selector, index) => selectors.indexOf(selector) === index)\n      .sort((a, b) => b.length - a.length)\n      .map((selector) => {\n        return escapeRegExp(selector);\n      })\n      .join('|'),\n    'g',\n  );\n\n  const result = cssText.replace(selectorMatcher, (selector) => {\n    const newSelector = selector.replace(HOVER_SELECTOR_GLOBAL, '$1.\\\\:hover');\n    return `${selector}, ${newSelector}`;\n  });\n  cache?.stylesWithHoverClass.set(cssText, result);\n  return result;\n}\n\nexport function createCache(): BuildCache {\n  const stylesWithHoverClass: Map<string, string> = new Map();\n  return {\n    stylesWithHoverClass,\n  };\n}\n\nfunction buildNode(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    hackCss: boolean;\n    cache: BuildCache;\n  },\n): Node | null {\n  const { doc, hackCss, cache } = options;\n  switch (n.type) {\n    case NodeType.Document:\n      return doc.implementation.createDocument(null, '', null);\n    case NodeType.DocumentType:\n      return doc.implementation.createDocumentType(\n        n.name || 'html',\n        n.publicId,\n        n.systemId,\n      );\n    case NodeType.Element:\n      const tagName = getTagName(n);\n      let node: Element;\n      if (n.isSVG) {\n        node = doc.createElementNS('http://www.w3.org/2000/svg', tagName);\n      } else {\n        node = doc.createElement(tagName);\n      }\n      for (const name in n.attributes) {\n        if (!n.attributes.hasOwnProperty(name)) {\n          continue;\n        }\n        let value = n.attributes[name];\n        if (tagName === 'option' && name === 'selected' && value === false) {\n          // legacy fix (TODO: if `value === false` can be generated for other attrs, should we also omit those other attrs from build?)\n          continue;\n        }\n        value =\n          typeof value === 'boolean' || typeof value === 'number' ? '' : value;\n        // attribute names start with rr_ are internal attributes added by rrweb\n        if (!name.startsWith('rr_')) {\n          const isTextarea = tagName === 'textarea' && name === 'value';\n          const isRemoteOrDynamicCss =\n            tagName === 'style' && name === '_cssText';\n          if (isRemoteOrDynamicCss && hackCss) {\n            value = addHoverClass(value, cache);\n          }\n          if (isTextarea || isRemoteOrDynamicCss) {\n            const child = doc.createTextNode(value);\n            // https://github.com/rrweb-io/rrweb/issues/112\n            for (const c of Array.from(node.childNodes)) {\n              if (c.nodeType === node.TEXT_NODE) {\n                node.removeChild(c);\n              }\n            }\n            node.appendChild(child);\n            continue;\n          }\n\n          try {\n            if (n.isSVG && name === 'xlink:href') {\n              node.setAttributeNS('http://www.w3.org/1999/xlink', name, value);\n            } else if (\n              name === 'onload' ||\n              name === 'onclick' ||\n              name.substring(0, 7) === 'onmouse'\n            ) {\n              // Rename some of the more common atttributes from https://www.w3schools.com/tags/ref_eventattributes.asp\n              // as setting them triggers a console.error (which shows up despite the try/catch)\n              // Assumption: these attributes are not used to css\n              node.setAttribute('_' + name, value);\n            } else if (\n              tagName === 'meta' &&\n              n.attributes['http-equiv'] === 'Content-Security-Policy' &&\n              name === 'content'\n            ) {\n              // If CSP contains style-src and inline-style is disabled, there will be an error \"Refused to apply inline style because it violates the following Content Security Policy directive: style-src '*'\".\n              // And the function insertStyleRules in rrweb replayer will throw an error \"Uncaught TypeError: Cannot read property 'insertRule' of null\".\n              node.setAttribute('csp-content', value);\n              continue;\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'preload' &&\n              n.attributes.as === 'script'\n            ) {\n              // ignore\n            } else if (\n              tagName === 'link' &&\n              n.attributes.rel === 'prefetch' &&\n              typeof n.attributes.href === 'string' &&\n              n.attributes.href.endsWith('.js')\n            ) {\n              // ignore\n            } else if (\n              tagName === 'img' &&\n              n.attributes.srcset &&\n              n.attributes.rr_dataURL\n            ) {\n              // backup original img srcset\n              node.setAttribute('rrweb-original-srcset', n.attributes.srcset as string);\n            } else {\n              node.setAttribute(name, value);\n            }\n          } catch (error) {\n            // skip invalid attribute\n          }\n        } else {\n          // handle internal attributes\n          if (tagName === 'canvas' && name === 'rr_dataURL') {\n            const image = document.createElement('img');\n            image.src = value;\n            image.onload = () => {\n              const ctx = (node as HTMLCanvasElement).getContext('2d');\n              if (ctx) {\n                ctx.drawImage(image, 0, 0, image.width, image.height);\n              }\n            };\n          } else if (tagName === 'img' && name === 'rr_dataURL') {\n            const image = node as HTMLImageElement;\n            if (!image.currentSrc.startsWith('data:')) {\n              // Backup original img src. It may not have been set yet.\n              image.setAttribute(\n                'rrweb-original-src',\n                n.attributes.src as string,\n              );\n              image.src = value;\n            }\n          }\n\n          if (name === 'rr_width') {\n            (node as HTMLElement).style.width = value;\n          } else if (name === 'rr_height') {\n            (node as HTMLElement).style.height = value;\n          } else if (name === 'rr_mediaCurrentTime') {\n            (node as HTMLMediaElement).currentTime = n.attributes\n              .rr_mediaCurrentTime as number;\n          } else if (name === 'rr_mediaState') {\n            switch (value) {\n              case 'played':\n                (node as HTMLMediaElement)\n                  .play()\n                  .catch((e) => console.warn('media playback error', e));\n                break;\n              case 'paused':\n                (node as HTMLMediaElement).pause();\n                break;\n              default:\n            }\n          }\n        }\n      }\n\n      if (n.isShadowHost) {\n        /**\n         * Since node is newly rebuilt, it should be a normal element\n         * without shadowRoot.\n         * But if there are some weird situations that has defined\n         * custom element in the scope before we rebuild node, it may\n         * register the shadowRoot earlier.\n         * The logic in the 'else' block is just a try-my-best solution\n         * for the corner case, please let we know if it is wrong and\n         * we can remove it.\n         */\n        if (!node.shadowRoot) {\n          node.attachShadow({ mode: 'open' });\n        } else {\n          while (node.shadowRoot.firstChild) {\n            node.shadowRoot.removeChild(node.shadowRoot.firstChild);\n          }\n        }\n      }\n      return node;\n    case NodeType.Text:\n      return doc.createTextNode(\n        n.isStyle && hackCss\n          ? addHoverClass(n.textContent, cache)\n          : n.textContent,\n      );\n    case NodeType.CDATA:\n      return doc.createCDATASection(n.textContent);\n    case NodeType.Comment:\n      return doc.createComment(n.textContent);\n    default:\n      return null;\n  }\n}\n\nexport function buildNodeWithSN(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    map: idNodeMap;\n    skipChild?: boolean;\n    hackCss: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): INode | null {\n  const {\n    doc,\n    map,\n    skipChild = false,\n    hackCss = true,\n    afterAppend,\n    cache,\n  } = options;\n  let node = buildNode(n, { doc, hackCss, cache });\n  if (!node) {\n    return null;\n  }\n  if (n.rootId) {\n    console.assert(\n      ((map[n.rootId] as unknown) as Document) === doc,\n      'Target document should has the same root id.',\n    );\n  }\n  // use target document as root document\n  if (n.type === NodeType.Document) {\n    // close before open to make sure document was closed\n    doc.close();\n    doc.open();\n    if (\n      n.compatMode === 'BackCompat' &&\n      n.childNodes &&\n      n.childNodes[0].type !== NodeType.DocumentType // there isn't one already defined\n    ) {\n      // Trigger compatMode in the iframe\n      // this is needed as document.createElement('iframe') otherwise inherits a CSS1Compat mode from the parent replayer environment\n      if (\n        n.childNodes[0].type === NodeType.Element &&\n        'xmlns' in n.childNodes[0].attributes &&\n        n.childNodes[0].attributes.xmlns === 'http://www.w3.org/1999/xhtml'\n      ) {\n        // might as well use an xhtml doctype if we've got an xhtml namespace\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD XHTML 1.0 Transitional//EN\" \"\">',\n        );\n      } else {\n        doc.write(\n          '<!DOCTYPE html PUBLIC \"-//W3C//DTD HTML 4.0 Transitional//EN\" \"\">',\n        );\n      }\n    }\n    node = doc;\n  }\n\n  (node as INode).__sn = n;\n  map[n.id] = node as INode;\n\n  if (\n    (n.type === NodeType.Document || n.type === NodeType.Element) &&\n    !skipChild\n  ) {\n    for (const childN of n.childNodes) {\n      const childNode = buildNodeWithSN(childN, {\n        doc,\n        map,\n        skipChild: false,\n        hackCss,\n        afterAppend,\n        cache,\n      });\n      if (!childNode) {\n        console.warn('Failed to rebuild', childN);\n        continue;\n      }\n\n      if (childN.isShadow && isElement(node) && node.shadowRoot) {\n        node.shadowRoot.appendChild(childNode);\n      } else {\n        node.appendChild(childNode);\n      }\n      if (afterAppend) {\n        afterAppend(childNode);\n      }\n    }\n  }\n\n  return node as INode;\n}\n\nfunction visit(idNodeMap: idNodeMap, onVisit: (node: INode) => void) {\n  function walk(node: INode) {\n    onVisit(node);\n  }\n\n  for (const key in idNodeMap) {\n    if (idNodeMap[key]) {\n      walk(idNodeMap[key]);\n    }\n  }\n}\n\nfunction handleScroll(node: INode) {\n  const n = node.__sn;\n  if (n.type !== NodeType.Element) {\n    return;\n  }\n  const el = (node as Node) as HTMLElement;\n  for (const name in n.attributes) {\n    if (!(n.attributes.hasOwnProperty(name) && name.startsWith('rr_'))) {\n      continue;\n    }\n    const value = n.attributes[name];\n    if (name === 'rr_scrollLeft') {\n      el.scrollLeft = value as number;\n    }\n    if (name === 'rr_scrollTop') {\n      el.scrollTop = value as number;\n    }\n  }\n}\n\nfunction rebuild(\n  n: serializedNodeWithId,\n  options: {\n    doc: Document;\n    onVisit?: (node: INode) => unknown;\n    hackCss?: boolean;\n    afterAppend?: (n: INode) => unknown;\n    cache: BuildCache;\n  },\n): [Node | null, idNodeMap] {\n  const { doc, onVisit, hackCss = true, afterAppend, cache } = options;\n  const idNodeMap: idNodeMap = {};\n  const node = buildNodeWithSN(n, {\n    doc,\n    map: idNodeMap,\n    skipChild: false,\n    hackCss,\n    afterAppend,\n    cache,\n  });\n  visit(idNodeMap, (visitedNode) => {\n    if (onVisit) {\n      onVisit(visitedNode);\n    }\n    handleScroll(visitedNode);\n  });\n  return [node, idNodeMap];\n}\n\nexport default rebuild;\n"],"names":["NodeType","isElement","n","nodeType","ELEMENT_NODE","isShadowRoot","host","Boolean","shadowRoot","maskInputValue","_a","input","maskInputSelector","unmaskInputSelector","maskInputOptions","tagName","type","value","maskInputFn","text","matches","toLowerCase","repeat","length","is2DCanvasBlank","canvas","ctx","getContext","x","width","y","height","getImageData","originalGetImageData","Uint32Array","call","Math","min","data","buffer","some","pixel","canvasService","canvasCtx","_id","tagNameRegex","RegExp","IGNORED_NODE","getCssRulesString","s","rules","cssRules","Array","from","map","getCssRuleString","join","error","rule","cssStringified","cssText","isCSSImportRule","styleSheet","URL_IN_CSS_REF","RELATIVE_PATH","DATA_URI","absoluteToStylesheet","href","replace","origin","quote1","path1","quote2","path2","path3","url","filePath","maybeQuote","test","indexOf","split","slice","stack","parts","pop","parts_1","_i","part","push","SRCSET_NOT_SPACES","SRCSET_COMMAS_OR_SPACES","absoluteToDoc","doc","attributeValue","trim","a","createElement","getHref","document","transformAttribute","name","pos","collectCharacters","regEx","chars","match","exec","substring","output","descriptorsStr","inParens","c","charAt","getAbsoluteSrcsetString","needMaskingText","node","maskTextClass","maskTextSelector","unmaskTextSelector","closest","classList","contains","eIndex","className","parentNode","TEXT_NODE","serializeNode","options","rootId","sheet","el","blockClass","blockSelector","unblockSelector","inlineStylesheet","_b","maskTextFn","_c","dataURLOptions","inlineImages","recordCanvas","keepIframeSrcFn","__sn","docId","id","undefined","DOCUMENT_NODE","compatMode","Document","childNodes","DOCUMENT_TYPE_NODE","DocumentType","publicId","systemId","needBlock","element","_isBlockedElement","HTMLFormElement","processedTagName","getValidTagName","attributes_1","_d","attributes","_e","name_1","stylesheet","styleSheets","find","rel","_cssText","innerText","textContent","checked","selected","__context","rr_dataURL","toDataURL","quality","canvasDataURL","blankCanvas","image_1","oldValue_1","crossOrigin","recordInlineImage","naturalWidth","naturalHeight","drawImage","err","console","warn","currentSrc","complete","onload","rr_mediaState","paused","rr_mediaCurrentTime","currentTime","scrollLeft","rr_scrollLeft","scrollTop","rr_scrollTop","_f","getBoundingClientRect","class","rr_width","rr_height","src","contentDocument","rr_src","Element","isSVG","ownerSVGElement","parentTagName","isStyle","isScript","nextSibling","previousSibling","Text","CDATA_SECTION_NODE","CDATA","COMMENT_NODE","Comment","lowerIfExists","maybeAttr","serializeNodeWithId","skipChild","slimDOMOptions","onSerialize","onIframeLoad","_g","iframeLoadTimeout","_h","_j","preserveWhiteSpace","_serializedNode","sn","comment","script","as","endsWith","headFavicon","headMetaDescKeywords","headMetaSocial","property","headMetaRobots","headMetaHttpEquiv","headMetaAuthorship","headMetaVerification","slimDOMExcluded","serializedNode","Object","assign","recordChild","isShadowHost","headWhitespace","bypassOptions","_k","serializedChildNode","_m","_l","isShadow","iframeEl","listener","win","contentWindow","readyState","fired","blankUrl","location","addEventListener","setTimeout","timer_1","clearTimeout","onceIframeLoaded","iframeDoc","serializedIframeNode","snapshot","_o","maskAllInputs","_p","slimDOM","_q","idNodeMap","color","date","email","month","number","range","search","tel","time","week","textarea","select","password","visitSnapshot","onVisit","walk","current","forEach","cleanupSnapshot","commentre","parse","css","lineno","column","updatePosition","str","lines","i","lastIndexOf","position","start","line","Position","whitespace","this","end","source","prototype","content","errorsList","msg","Error","reason","filename","silent","open","close","comments","atrule","re","m","selector","declaration","propMatch","prop","val","ret","declarations","decl","decls","keyframe","vals","values","rulesList","atimport","_compileAtrule","atcharset","atnamespace","vendor","frame","frames","concat","keyframes","atkeyframes","media","style","atmedia","atcustommedia","supports","atsupports","atdocument","sel","selectors","atpage","athost","atfontface","addParent","parsingErrors","obj","parent","isNode","childParent","keys","isArray","v","defineProperty","configurable","writable","enumerable","tagMap","altglyph","altglyphdef","altglyphitem","animatecolor","animatemotion","animatetransform","clippath","feblend","fecolormatrix","fecomponenttransfer","fecomposite","feconvolvematrix","fediffuselighting","fedisplacementmap","fedistantlight","fedropshadow","feflood","fefunca","fefuncb","fefuncg","fefuncr","fegaussianblur","feimage","femerge","femergenode","femorphology","feoffset","fepointlight","fespecularlighting","fespotlight","fetile","feturbulence","foreignobject","glyphref","lineargradient","radialgradient","HOVER_SELECTOR","HOVER_SELECTOR_GLOBAL","addHoverClass","cache","cachedStyle","stylesWithHoverClass","get","ast","selectorMatcher","filter","index","sort","b","result","newSelector","set","createCache","Map","buildNode","hackCss","implementation","createDocument","createDocumentType","node_1","getTagName","createElementNS","hasOwnProperty","startsWith","image","setAttribute","play","e","pause","isTextarea","isRemoteOrDynamicCss","child","createTextNode","removeChild","appendChild","setAttributeNS","srcset","firstChild","attachShadow","mode","createCDATASection","createComment","buildNodeWithSN","afterAppend","assert","xmlns","write","childN","childNode","rebuild","key","visit","visitedNode","name_2","handleScroll"],"mappings":"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"}
\ No newline at end of file
diff --git a/node_modules/rrweb-snapshot/lib/rrweb-snapshot.js b/node_modules/rrweb-snapshot/lib/rrweb-snapshot.js
old mode 100644
new mode 100755
index 3040b7d..8ce75cf
--- a/node_modules/rrweb-snapshot/lib/rrweb-snapshot.js
+++ b/node_modules/rrweb-snapshot/lib/rrweb-snapshot.js
@@ -21,10 +21,14 @@ function isShadowRoot(n) {
     return Boolean(host && host.shadowRoot && host.shadowRoot === n);
 }
 function maskInputValue(_a) {
-    var maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;
+    var input = _a.input, maskInputSelector = _a.maskInputSelector, unmaskInputSelector = _a.unmaskInputSelector, maskInputOptions = _a.maskInputOptions, tagName = _a.tagName, type = _a.type, value = _a.value, maskInputFn = _a.maskInputFn;
     var text = value || '';
+    if (unmaskInputSelector && input.matches(unmaskInputSelector)) {
+        return text;
+    }
     if (maskInputOptions[tagName.toLowerCase()] ||
-        maskInputOptions[type]) {
+        maskInputOptions[type] ||
+        (maskInputSelector && input.matches(maskInputSelector))) {
         if (maskInputFn) {
             text = maskInputFn(text);
         }
@@ -251,7 +255,10 @@ function transformAttribute(doc, tagName, name, value) {
         return value;
     }
 }
-function _isBlockedElement(element, blockClass, blockSelector) {
+function _isBlockedElement(element, blockClass, blockSelector, unblockSelector) {
+    if (unblockSelector && element.matches(unblockSelector)) {
+        return false;
+    }
     if (typeof blockClass === 'string') {
         if (element.classList.contains(blockClass)) {
             return true;
@@ -270,11 +277,16 @@ function _isBlockedElement(element, blockClass, blockSelector) {
     }
     return false;
 }
-function needMaskingText(node, maskTextClass, maskTextSelector) {
+function needMaskingText(node, maskTextClass, maskTextSelector, unmaskTextSelector) {
     if (!node) {
         return false;
     }
     if (node.nodeType === node.ELEMENT_NODE) {
+        if (unmaskTextSelector) {
+            if (node.matches(unmaskTextSelector) || node.closest(unmaskTextSelector)) {
+                return false;
+            }
+        }
         if (typeof maskTextClass === 'string') {
             if (node.classList.contains(maskTextClass)) {
                 return true;
@@ -293,12 +305,12 @@ function needMaskingText(node, maskTextClass, maskTextSelector) {
                 return true;
             }
         }
-        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
     }
     if (node.nodeType === node.TEXT_NODE) {
-        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+        return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
     }
-    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector);
+    return needMaskingText(node.parentNode, maskTextClass, maskTextSelector, unmaskTextSelector);
 }
 function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
     var win = iframeEl.contentWindow;
@@ -338,7 +350,7 @@ function onceIframeLoaded(iframeEl, listener, iframeLoadTimeout) {
 }
 function serializeNode(n, options) {
     var _a;
-    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, inlineStylesheet = options.inlineStylesheet, _b = options.maskInputOptions, maskInputOptions = _b === void 0 ? {} : _b, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _c = options.dataURLOptions, dataURLOptions = _c === void 0 ? {} : _c, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;
+    var doc = options.doc, blockClass = options.blockClass, blockSelector = options.blockSelector, unblockSelector = options.unblockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, unmaskTextSelector = options.unmaskTextSelector, inlineStylesheet = options.inlineStylesheet, maskInputSelector = options.maskInputSelector, unmaskInputSelector = options.unmaskInputSelector, _b = options.maskInputOptions, maskInputOptions = _b === void 0 ? {} : _b, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, _c = options.dataURLOptions, dataURLOptions = _c === void 0 ? {} : _c, inlineImages = options.inlineImages, recordCanvas = options.recordCanvas, keepIframeSrcFn = options.keepIframeSrcFn;
     var rootId;
     if (doc.__sn) {
         var docId = doc.__sn.id;
@@ -370,7 +382,7 @@ function serializeNode(n, options) {
                 rootId: rootId
             };
         case n.ELEMENT_NODE:
-            var needBlock = _isBlockedElement(n, blockClass, blockSelector);
+            var needBlock = _isBlockedElement(n, blockClass, blockSelector, unblockSelector);
             var tagName = getValidTagName(n);
             var attributes_1 = {};
             for (var _i = 0, _d = Array.from(n.attributes); _i < _d.length; _i++) {
@@ -411,9 +423,12 @@ function serializeNode(n, options) {
                     attributes_1.type !== 'button' &&
                     value) {
                     attributes_1.value = maskInputValue({
+                        input: n,
                         type: attributes_1.type,
                         tagName: tagName,
                         value: value,
+                        maskInputSelector: maskInputSelector,
+                        unmaskInputSelector: unmaskInputSelector,
                         maskInputOptions: maskInputOptions,
                         maskInputFn: maskInputFn
                     });
@@ -532,7 +547,7 @@ function serializeNode(n, options) {
             }
             if (!isStyle &&
                 !isScript &&
-                needMaskingText(n, maskTextClass, maskTextSelector) &&
+                needMaskingText(n, maskTextClass, maskTextSelector, unmaskTextSelector) &&
                 textContent) {
                 textContent = maskTextFn
                     ? maskTextFn(textContent)
@@ -640,15 +655,19 @@ function slimDOMExcluded(sn, slimDOMOptions) {
     return false;
 }
 function serializeNodeWithId(n, options) {
-    var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, _h = options.keepIframeSrcFn, keepIframeSrcFn = _h === void 0 ? function () { return false; } : _h;
+    var doc = options.doc, map = options.map, blockClass = options.blockClass, blockSelector = options.blockSelector, unblockSelector = options.unblockSelector, maskTextClass = options.maskTextClass, maskTextSelector = options.maskTextSelector, unmaskTextSelector = options.unmaskTextSelector, _a = options.skipChild, skipChild = _a === void 0 ? false : _a, _b = options.inlineStylesheet, inlineStylesheet = _b === void 0 ? true : _b, maskInputSelector = options.maskInputSelector, unmaskInputSelector = options.unmaskInputSelector, _c = options.maskInputOptions, maskInputOptions = _c === void 0 ? {} : _c, maskTextFn = options.maskTextFn, maskInputFn = options.maskInputFn, slimDOMOptions = options.slimDOMOptions, _d = options.dataURLOptions, dataURLOptions = _d === void 0 ? {} : _d, _e = options.inlineImages, inlineImages = _e === void 0 ? false : _e, _f = options.recordCanvas, recordCanvas = _f === void 0 ? false : _f, onSerialize = options.onSerialize, onIframeLoad = options.onIframeLoad, _g = options.iframeLoadTimeout, iframeLoadTimeout = _g === void 0 ? 5000 : _g, _h = options.keepIframeSrcFn, keepIframeSrcFn = _h === void 0 ? function () { return false; } : _h;
     var _j = options.preserveWhiteSpace, preserveWhiteSpace = _j === void 0 ? true : _j;
     var _serializedNode = serializeNode(n, {
         doc: doc,
         blockClass: blockClass,
         blockSelector: blockSelector,
+        unblockSelector: unblockSelector,
         maskTextClass: maskTextClass,
         maskTextSelector: maskTextSelector,
+        unmaskTextSelector: unmaskTextSelector,
         inlineStylesheet: inlineStylesheet,
+        maskInputSelector: maskInputSelector,
+        unmaskInputSelector: unmaskInputSelector,
         maskInputOptions: maskInputOptions,
         maskTextFn: maskTextFn,
         maskInputFn: maskInputFn,
@@ -704,10 +723,14 @@ function serializeNodeWithId(n, options) {
             map: map,
             blockClass: blockClass,
             blockSelector: blockSelector,
+            unblockSelector: unblockSelector,
             maskTextClass: maskTextClass,
             maskTextSelector: maskTextSelector,
+            unmaskTextSelector: unmaskTextSelector,
             skipChild: skipChild,
             inlineStylesheet: inlineStylesheet,
+            maskInputSelector: maskInputSelector,
+            unmaskInputSelector: unmaskInputSelector,
             maskInputOptions: maskInputOptions,
             maskTextFn: maskTextFn,
             maskInputFn: maskInputFn,
@@ -752,10 +775,14 @@ function serializeNodeWithId(n, options) {
                     map: map,
                     blockClass: blockClass,
                     blockSelector: blockSelector,
+                    unblockSelector: unblockSelector,
                     maskTextClass: maskTextClass,
                     maskTextSelector: maskTextSelector,
+                    unmaskTextSelector: unmaskTextSelector,
                     skipChild: false,
                     inlineStylesheet: inlineStylesheet,
+                    maskInputSelector: maskInputSelector,
+                    unmaskInputSelector: unmaskInputSelector,
                     maskInputOptions: maskInputOptions,
                     maskTextFn: maskTextFn,
                     maskInputFn: maskInputFn,
@@ -778,7 +805,7 @@ function serializeNodeWithId(n, options) {
     return serializedNode;
 }
 function snapshot(n, options) {
-    var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.maskTextClass, maskTextClass = _d === void 0 ? 'rr-mask' : _d, _e = _a.maskTextSelector, maskTextSelector = _e === void 0 ? null : _e, _f = _a.inlineStylesheet, inlineStylesheet = _f === void 0 ? true : _f, _g = _a.inlineImages, inlineImages = _g === void 0 ? false : _g, _h = _a.recordCanvas, recordCanvas = _h === void 0 ? false : _h, _j = _a.maskAllInputs, maskAllInputs = _j === void 0 ? false : _j, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _k = _a.slimDOM, slimDOM = _k === void 0 ? false : _k, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _l = _a.keepIframeSrcFn, keepIframeSrcFn = _l === void 0 ? function () { return false; } : _l;
+    var _a = options || {}, _b = _a.blockClass, blockClass = _b === void 0 ? 'rr-block' : _b, _c = _a.blockSelector, blockSelector = _c === void 0 ? null : _c, _d = _a.unblockSelector, unblockSelector = _d === void 0 ? null : _d, _e = _a.maskTextClass, maskTextClass = _e === void 0 ? 'rr-mask' : _e, _f = _a.maskTextSelector, maskTextSelector = _f === void 0 ? null : _f, _g = _a.unmaskTextSelector, unmaskTextSelector = _g === void 0 ? null : _g, _h = _a.inlineStylesheet, inlineStylesheet = _h === void 0 ? true : _h, _j = _a.inlineImages, inlineImages = _j === void 0 ? false : _j, _k = _a.recordCanvas, recordCanvas = _k === void 0 ? false : _k, _l = _a.maskInputSelector, maskInputSelector = _l === void 0 ? null : _l, _m = _a.unmaskInputSelector, unmaskInputSelector = _m === void 0 ? null : _m, _o = _a.maskAllInputs, maskAllInputs = _o === void 0 ? false : _o, maskTextFn = _a.maskTextFn, maskInputFn = _a.maskInputFn, _p = _a.slimDOM, slimDOM = _p === void 0 ? false : _p, dataURLOptions = _a.dataURLOptions, preserveWhiteSpace = _a.preserveWhiteSpace, onSerialize = _a.onSerialize, onIframeLoad = _a.onIframeLoad, iframeLoadTimeout = _a.iframeLoadTimeout, _q = _a.keepIframeSrcFn, keepIframeSrcFn = _q === void 0 ? function () { return false; } : _q;
     var idNodeMap = {};
     var maskInputOptions = maskAllInputs === true
         ? {
@@ -827,10 +854,14 @@ function snapshot(n, options) {
             map: idNodeMap,
             blockClass: blockClass,
             blockSelector: blockSelector,
+            unblockSelector: unblockSelector,
             maskTextClass: maskTextClass,
             maskTextSelector: maskTextSelector,
+            unmaskTextSelector: unmaskTextSelector,
             skipChild: false,
             inlineStylesheet: inlineStylesheet,
+            maskInputSelector: maskInputSelector,
+            unmaskInputSelector: unmaskInputSelector,
             maskInputOptions: maskInputOptions,
             maskTextFn: maskTextFn,
             maskInputFn: maskInputFn,
diff --git a/node_modules/rrweb-snapshot/typings/snapshot.d.ts b/node_modules/rrweb-snapshot/typings/snapshot.d.ts
index b970f75..a49fa7d 100644
--- a/node_modules/rrweb-snapshot/typings/snapshot.d.ts
+++ b/node_modules/rrweb-snapshot/typings/snapshot.d.ts
@@ -3,17 +3,21 @@ export declare const IGNORED_NODE = -2;
 export declare function absoluteToStylesheet(cssText: string | null, href: string): string;
 export declare function absoluteToDoc(doc: Document, attributeValue: string): string;
 export declare function transformAttribute(doc: Document, tagName: string, name: string, value: string): string;
-export declare function _isBlockedElement(element: HTMLElement, blockClass: string | RegExp, blockSelector: string | null): boolean;
-export declare function needMaskingText(node: Node | null, maskTextClass: string | RegExp, maskTextSelector: string | null): boolean;
+export declare function _isBlockedElement(element: HTMLElement, blockClass: string | RegExp, blockSelector: string | null, unblockSelector: string | null): boolean;
+export declare function needMaskingText(node: Node | null, maskTextClass: string | RegExp, maskTextSelector: string | null, unmaskTextSelector: string | null): boolean;
 export declare function serializeNodeWithId(n: Node | INode, options: {
     doc: Document;
     map: idNodeMap;
     blockClass: string | RegExp;
     blockSelector: string | null;
+    unblockSelector: string | null;
     maskTextClass: string | RegExp;
     maskTextSelector: string | null;
+    unmaskTextSelector: string | null;
     skipChild: boolean;
     inlineStylesheet: boolean;
+    maskInputSelector: string | null;
+    unmaskInputSelector: string | null;
     maskInputOptions?: MaskInputOptions;
     maskTextFn: MaskTextFn | undefined;
     maskInputFn: MaskInputFn | undefined;
@@ -30,8 +34,12 @@ export declare function serializeNodeWithId(n: Node | INode, options: {
 declare function snapshot(n: Document, options?: {
     blockClass?: string | RegExp;
     blockSelector?: string | null;
+    unblockSelector?: string | null;
     maskTextClass?: string | RegExp;
     maskTextSelector?: string | null;
+    unmaskTextSelector?: string | null;
+    maskInputSelector?: string | null;
+    unmaskInputSelector?: string | null;
     inlineStylesheet?: boolean;
     maskAllInputs?: boolean | MaskInputOptions;
     maskTextFn?: MaskTextFn;
diff --git a/node_modules/rrweb-snapshot/typings/utils.d.ts b/node_modules/rrweb-snapshot/typings/utils.d.ts
index 6572ab8..708fb96 100644
--- a/node_modules/rrweb-snapshot/typings/utils.d.ts
+++ b/node_modules/rrweb-snapshot/typings/utils.d.ts
@@ -1,7 +1,10 @@
 import { INode, MaskInputFn, MaskInputOptions } from './types';
 export declare function isElement(n: Node | INode): n is Element;
 export declare function isShadowRoot(n: Node): n is ShadowRoot;
-export declare function maskInputValue({ maskInputOptions, tagName, type, value, maskInputFn, }: {
+export declare function maskInputValue({ input, maskInputSelector, unmaskInputSelector, maskInputOptions, tagName, type, value, maskInputFn, }: {
+    input: HTMLElement;
+    maskInputSelector: string | null;
+    unmaskInputSelector: string | null;
     maskInputOptions: MaskInputOptions;
     tagName: string;
     type: string | number | boolean | null;
