name: 'Build & Test'
on:
  push:
    branches:
      - master
      - release/**
  pull_request:
  workflow_dispatch:
    inputs:
      commit:
        description: If the commit you want to test isn't the head of a branch, provide its SHA here
        required: false

# Cancel in progress workflows on pull_requests.
# https://docs.github.com/en/actions/using-jobs/using-concurrency#example-using-a-fallback-value
concurrency:
  group: ${{ github.workflow }}-${{ github.head_ref || github.run_id }}
  cancel-in-progress: true

env:
  HEAD_COMMIT: ${{ github.event.inputs.commit || github.sha }}

  CACHED_DEPENDENCY_PATHS: |
    ${{ github.workspace }}/node_modules
    ${{ github.workspace }}/packages/*/node_modules
    ~/.cache/ms-playwright/
    ~/.cache/mongodb-binaries/

  # DEPENDENCY_CACHE_KEY: can't be set here because we don't have access to yarn.lock

  # packages/utils/cjs and packages/utils/esm: Symlinks to the folders inside of `build`, needed for tests
  CACHED_BUILD_PATHS: |
    ${{ github.workspace }}/packages/*/build
    ${{ github.workspace }}/packages/ember/*.d.ts
    ${{ github.workspace }}/packages/gatsby/*.d.ts
    ${{ github.workspace }}/packages/core/src/version.ts
    ${{ github.workspace }}/packages/serverless
    ${{ github.workspace }}/packages/utils/cjs
    ${{ github.workspace }}/packages/utils/esm

  BUILD_CACHE_KEY: ${{ github.event.inputs.commit || github.sha }}

  # GH will use the first restore-key it finds that matches
  # So it will start by looking for one from the same branch, else take the newest one it can find elsewhere
  # We want to prefer the cache from the current master branch, if we don't find any on the current branch
  NX_CACHE_RESTORE_KEYS: |
    nx-Linux-${{ github.ref }}-${{ github.event.inputs.commit || github.sha }}
    nx-Linux-${{ github.ref }}
    nx-Linux-refs/heads/master
    nx-Linux

jobs:
  job_get_metadata:
    name: Get Metadata
    runs-on: ubuntu-20.04
    permissions:
      pull-requests: read
    steps:
      - name: Check out current commit
        uses: actions/checkout@v3
        with:
          ref: ${{ env.HEAD_COMMIT }}
          # We need to check out not only the fake merge commit between the PR and the base branch which GH creates, but
          # also its parents, so that we can pull the commit message from the head commit of the PR
          fetch-depth: 2
      - name: Get metadata
        id: get_metadata
        # We need to try a number of different options for finding the head commit, because each kind of trigger event
        # stores it in a different location
        run: |
          COMMIT_SHA=$(git rev-parse --short ${{ github.event.pull_request.head.sha || github.event.head_commit.id || env.HEAD_COMMIT }})
          echo "COMMIT_SHA=$COMMIT_SHA" >> $GITHUB_ENV
          echo "COMMIT_MESSAGE=$(git log -n 1 --pretty=format:%s $COMMIT_SHA)" >> $GITHUB_ENV

      - name: Determine changed packages
        uses: getsentry/paths-filter@v2.11.1
        id: changed
        with:
          filters: |
            shared: &shared
              - '*.{js,ts,json,yml,lock}'
              - 'CHANGELOG.md'
              - '.github/**'
              - 'jest/**'
              - 'rollup/**'
              - 'scripts/**'
              - 'packages/core/**'
              - 'packages/tracing/**'
              - 'packages/utils/**'
              - 'packages/types/**'
              - 'packages/integrations/**'
            browser: &browser
              - *shared
              - 'packages/browser/**'
              - 'packages/replay/**'
            browser_integration:
              - *shared
              - *browser
              - 'packages/integration-tests/**'
            ember:
              - *shared
              - *browser
              - 'packages/ember/**'
            nextjs:
              - *shared
              - *browser
              - 'packages/nextjs/**'
              - 'packages/node/**'
              - 'packages/react/**'
            remix:
              - *shared
              - *browser
              - 'packages/remix/**'
              - 'packages/node/**'
              - 'packages/react/**'
            node:
              - *shared
              - 'packages/node/**'
              - 'packages/node-integration-tests/**'
            any_code:
              - '!**/*.md'

      - name: Get PR labels
        id: pr-labels
        uses: mydea/pr-labels-action@update-core

    outputs:
      commit_label: '${{ env.COMMIT_SHA }}: ${{ env.COMMIT_MESSAGE }}'
      changed_nextjs: ${{ steps.changed.outputs.nextjs }}
      changed_ember: ${{ steps.changed.outputs.ember }}
      changed_remix: ${{ steps.changed.outputs.remix }}
      changed_node: ${{ steps.changed.outputs.node }}
      changed_browser: ${{ steps.changed.outputs.browser }}
      changed_browser_integration: ${{ steps.changed.outputs.browser_integration }}
      changed_any_code: ${{ steps.changed.outputs.any_code }}
      # Note: These next three have to be checked as strings ('true'/'false')!
      is_master: ${{ github.ref == 'refs/heads/master' }}
      is_release: ${{ startsWith(github.ref, 'refs/heads/release/') }}
      force_skip_cache:
        ${{ github.event_name == 'pull_request' && contains(steps.pr-labels.outputs.labels, ' ci-skip-cache ') }}

  job_install_deps:
    name: Install Dependencies
    needs: job_get_metadata
    runs-on: ubuntu-20.04
    timeout-minutes: 15
    if: needs.job_get_metadata.outputs.changed_any_code == 'true' || github.event_name != 'pull_request'
    steps:
      - name: 'Check out current commit (${{ needs.job_get_metadata.outputs.commit_label }})'
        uses: actions/checkout@v3
        with:
          ref: ${{ env.HEAD_COMMIT }}
      - name: Set up Node
        uses: volta-cli/action@v4
        # we use a hash of yarn.lock as our cache key, because if it hasn't changed, our dependencies haven't changed,
        # so no need to reinstall them
      - name: Compute dependency cache key
        id: compute_lockfile_hash
        run: echo "hash=${{ hashFiles('yarn.lock') }}" >> "$GITHUB_OUTPUT"

      # When the `ci-skip-cache` label is added to a PR, we always want to skip dependency cache
      - name: Check dependency cache
        uses: actions/cache@v3
        id: cache_dependencies
        if: needs.job_get_metadata.outputs.force_skip_cache == 'false'
        with:
          path: ${{ env.CACHED_DEPENDENCY_PATHS }}
          key: ${{ steps.compute_lockfile_hash.outputs.hash }}

      - name: Install dependencies
        if:
          steps.cache_dependencies.outputs.cache-hit == '' || needs.job_get_metadata.outputs.force_skip_cache == 'true'
        run: yarn install --ignore-engines --frozen-lockfile
    outputs:
      dependency_cache_key: ${{ steps.compute_lockfile_hash.outputs.hash }}

  job_size_check:
    name: Size Check
    needs: [job_get_metadata, job_install_deps]
    timeout-minutes: 15
    runs-on: ubuntu-20.04
    # Size Check will error out outside of the context of a PR
    if: github.event_name == 'pull_request' || needs.job_get_metadata.outputs.is_master == 'true'
    steps:
      - name: Check out current commit (${{ needs.job_get_metadata.outputs.commit_label }})
        uses: actions/checkout@v3
        with:
          ref: ${{ env.HEAD_COMMIT }}
      - name: Set up Node
        uses: actions/setup-node@v3
        with:
          # The size limit action runs `yarn` and `yarn build` when this job is executed on
          # `master`. We can't change this without making changes to the action, so we'll
          # use Node 14 for now.
          node-version: '14'
      - name: Check dependency cache
        uses: actions/cache@v3
        with:
          path: ${{ env.CACHED_DEPENDENCY_PATHS }}
          key: ${{ needs.job_install_deps.outputs.dependency_cache_key }}

      - name: build without cache
        run: |
          yarn lerna run build:types --skip-nx-cache
          yarn lerna run build:transpile --skip-nx-cache
          yarn lerna run build:bundle --skip-nx-cache

      - run: yarn size-limit --json

      - name: Check bundle sizes
        uses: getsentry/size-limit-action@v5
        # Don't run size check on release branches - at that point, we're already committed
        if: needs.job_get_metadata.outputs.is_release == 'false'
        with:
          github_token: ${{ secrets.GITHUB_TOKEN }}
          skip_step: build
